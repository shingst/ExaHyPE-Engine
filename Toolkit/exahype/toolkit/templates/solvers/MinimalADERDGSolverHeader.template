// This file was generated by the ExaHyPE toolkit.
// 
// ========================
//   www.exahype.eu
// ========================
#ifndef __{{Solver}}_CLASS_HEADER__
#define __{{Solver}}_CLASS_HEADER__

#include "exahype/solvers/ADERDGSolver.h"

{{ProfilerInclude}}

namespace {{Project}}{
  class {{Solver}};
}

class {{Project}}::{{Solver}}: public exahype::solvers::ADERDGSolver {
  public:
    {{Solver}}( // TODO out of date
      double maximumMeshSize, exahype::solvers::Solver::TimeStepping timeSteppingexahype::solvers::Solver::TimeStepping timeStepping{{SolverConstructorSignatureExtension}}
    ):

    void spaceTimePredictor(double* const lQhbnd,double* const lFhbnd, double** const tempSpaceTimeUnknowns, double** const tempSpaceTimeFluxUnknowns, double* const tempUnknowns, double* const tempFluxUnknowns, const double* const luh, const tarch::la::Vector<DIMENSIONS,double>& cellSize, const double dt) override; 
    void solutionUpdate(double* const luh, const double* const lduh, const double dt) override;
    void volumeIntegral(double* const lduh, const double* const lFhi, const tarch::la::Vector<DIMENSIONS,double>& cellSize) override;
    void surfaceIntegral(double* const lduh, const double* const lFhbnd, const tarch::la::Vector<DIMENSIONS,double>& cellSize) override;
    void riemannSolver(double* const FL, double* const FR, const double* const QL, const double* const QR, double* const tempFaceUnknownsArray, double** const tempStateSizedVectors, double** const tempStateSizedSquareMatrices, const double t, const double dt, const int direction) override;
    void boundaryConditions(double* const fluxOut, double* const stateOut, const double* const fluxIn, const double* const stateIn, const double* const luh, const tarch::la::Vector<DIMENSIONS, double>& cellCentre, const tarch::la::Vector<DIMENSIONS,double>& cellSize, const double t,const double dt, const int faceIndex, const int direction) override;
    double stableTimeStepSize(const double* const luh, const tarch::la::Vector<DIMENSIONS,double>& cellSize) override;
    void adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,double dt) override;
    exahype::solvers::Solver::RefinementControl refinementCriterion(const double* const luh, const tarch::la::Vector<DIMENSIONS, double>& cellCentre, const tarch::la::Vector<DIMENSIONS, double>& cellSize, double t, const int level) override;
    void faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex) override;
    void faceUnknownsRestriction(double* const lQhbndCoarse,double* const lFhbndCoarse,const double* const lQhbndFine,const double* const lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex) override;
    void volumeUnknownsProlongation(double* const luhFine, const double* const luhCoarse, const int coarseGridLevel, const int fineGridLevel, const tarch::la::Vector<DIMENSIONS, int>& subcellIndex) override;
    void volumeUnknownsRestriction(double* const luhCoarse, const double* const luhFine, const int coarseGridLevel, const int fineGridLevel, const tarch::la::Vector<DIMENSIONS, int>& subcellIndex) override;
};

#endif // __{{Solver}}_CLASS_HEADER__
