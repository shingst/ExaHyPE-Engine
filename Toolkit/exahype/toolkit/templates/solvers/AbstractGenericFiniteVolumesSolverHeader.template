// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#ifndef __{{abstractSolver}}_CLASS_HEADER__
#define __{{abstractSolver}}_CLASS_HEADER__

#include <ostream>

#include "exahype/solvers/FiniteVolumesSolver.h"
#include "exahype/solvers/UserSolverInterface.h"
{% if enableProfiler %}
#include "exahype/profilers/Profiler.h"
{% endif %}

/**
 * We include Peano's assertion collection here.
 */
#include "tarch/Assertions.h"

namespace {{project}}{
  class {{abstractSolver}};
  class {{solver}};
}

class {{project}}::{{abstractSolver}} : public exahype::solvers::FiniteVolumesSolver, public exahype::solvers::UserFiniteVolumesSolverInterface  {
  public:
    static constexpr int NumberOfVariables         = {{numberOfVariables}};
    static constexpr int NumberOfParameters        = {{numberOfMaterialParameters}};
    static constexpr int NumberOfGlobalObservables = {{numberOfGlobalObservables}};
    static constexpr int PatchSize                 = {{patchSize}};
    static constexpr int GhostLayerWidth           = {{ghostLayerWidth}};
    static constexpr double CFL                    = 0.9;
    
    // virtual getters for the constexpr's
    int constexpr_getNumberOfVariables()  const override { return NumberOfVariables; };
    int constexpr_getNumberOfParameters() const override { return NumberOfParameters; };
    int constexpr_getPatchSize()          const override { return PatchSize; };
    int constexpr_getGhostLayerWidth()    const override { return GhostLayerWidth; }
    double constexpr_getCFLNumber()       const override { return CFL; };
  
    class VariableMetrics;
    class Variables;
    class ReadOnlyVariables;
    class Fluxes;
    class VariableShortcuts;
    class VariableMultiplicities;
    class VariableNames;
    {% for className in namingSchemes %}
    class {{className}};
    {% endfor %}
    
    {{abstractSolver}}(
        const double maximumMeshSize,
        const exahype::solvers::Solver::TimeStepping timeStepping
        {% if enableProfiler %},std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %});
    
    void solutionUpdate(double* luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) override;
    
    double stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    void adjustSolution(double* luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) override;
    
    void ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) override;
    void ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryConditions(double* luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const tarch::la::Vector<DIMENSIONS, int>& posCell,const tarch::la::Vector<DIMENSIONS, int>& posBoundary) override;

    /// Apr 18, Coding Week: Riemann Solvers in FV. Hopefully inlined as evaluated point wise.
    double riemannSolver(double* fL, double *fR, const double* qL, const double* qR, int direction) override;

    static void constantsToString(std::ostream& os);
    static void abortWithMsg(const char* const msg);
    
    //not used PDE terms
    {% if not useNCP %}
    void nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) final {}
    {% endif %}
    
    {% if not useSource %}
    void algebraicSource(const double* const Q,double* S)  final {}
    {% endif %}
    
    {% if not useFlux or useViscousFlux %}
    void flux(const double* const Q,double** F)  final {}
    {% endif %}
    
    {% if not useViscousFlux %}
    void viscousFlux(const double* const Q,const double* const gradQ, double** F)  final {}
    virtual void viscousEigenvalues(const double* const Q,const int d,double* lambda) final {};
    {% endif %}
    
    {% if not usePointSources  %}
    void pointSource(const double* const Q,const double* const x,const double t,const double dt, double* forceVector,int n)  final {}
    /* Please check if this is at the correct place: */
    {% endif %}
    
    {% if not useMaterialParameters  %}
    virtual void multiplyMaterialParameterMatrix(const double* const Q, double* rhs) final {}
    {% endif %}
};


#endif // __{{abstractSolver}}_CLASS_HEADER__
