// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "{{abstractSolver}}.h"

#include "kernels/finitevolumes/commons/c/commons.h"
#include "kernels/finitevolumes/{{finiteVolumesType}}/c/{{finiteVolumesType}}.h"
#include "kernels/finitevolumes/riemannsolvers/c/riemannsolvers.h"

#include "{{solver}}_Variables.h"
#include "{{solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>
#include <cstdlib> // abort()
#include "kernels/KernelUtils.h" // icellSize

#include "exahype/disableOptimization.h" // we experience compiler bugs sometimes.

{{project}}::{{solver}}::{{solver}}(const double maximumMeshSize,const exahype::solvers::Solver::TimeStepping timeStepping{% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}):
  {{abstractSolver}}::{{abstractSolver}}(maximumMeshSize,timeStepping{% if enableProfiler %}, std::move(profiler){% endif %}) {
}

{{project}}::{{abstractSolver}}::{{abstractSolver}}(const double maximumMeshSize,const exahype::solvers::Solver::TimeStepping timeStepping{% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}):
exahype::solvers::FiniteVolumesSolver("{{solver}}",NumberOfVariables,NumberOfParameters,NumberOfGlobalObservables, PatchSize,
                                        GhostLayerWidth,maximumMeshSize,timeStepping{% if enableProfiler %}, std::move(profiler){% endif %}) {
}

void {{project}}::{{abstractSolver}}::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "{{project}}::{{abstractSolver}}("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "PatchSize=" << PatchSize << ", "
	   << "GhostLayerWidth=" << GhostLayerWidth
	   << ")";
}

void {{project}}::{{abstractSolver}}::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void {{project}}::{{abstractSolver}}::solutionUpdate(double* luh,const tarch::la::Vector<DIMENSIONS,double>& cellCenter,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t, const double dt,double& maxAdmissibleDt) {
  maxAdmissibleDt = kernels::finitevolumes::{{finiteVolumesType}}::c::solutionUpdate<
    {{useSource_s}}, {{useNCP_s}}, {{useFlux_s}}, {{useViscousFlux_s}}, {{useRobustDiagonalLimiting_s}},
    kernels::finitevolumes::commons::c::{{slopeLimiter}},
    {{solver}}
    >(*static_cast<{{solver}}*>(this),luh,cellCenter,cellSize,t,dt);
}


double {{project}}::{{abstractSolver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
  double maxAdmissibleDt = kernels::finitevolumes::commons::c::stableTimeStepSize<{{solver}},{{useViscousFlux_s}}>(*static_cast<{{solver}}*>(this),luh,cellSize);
  return maxAdmissibleDt;
}

void {{project}}::{{abstractSolver}}::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt) {
  kernels::finitevolumes::commons::c::solutionAdjustment<{{solver}}>(*static_cast<{{solver}}*>(this),luh,cellCentre,cellSize,t,dt);
}

void {{project}}::{{abstractSolver}}::boundaryConditions(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const tarch::la::Vector<DIMENSIONS, int>& posCell,const tarch::la::Vector<DIMENSIONS, int>& posBoundary) {
  {% if dimensions==3 %}
  constexpr int cellsPerFace = PatchSize*PatchSize*GhostLayerWidth;
  {% else %}
  constexpr int cellsPerFace = PatchSize*GhostLayerWidth;
  {% endif %}
  {% if tempVarsOnStack %}
  double luhbndInside [(NumberOfVariables+NumberOfParameters)*cellsPerFace];
  double luhbndOutside[(NumberOfVariables+NumberOfParameters)*cellsPerFace];
  {% else %}
  constexpr int sizeLuhbnd = (NumberOfVariables+NumberOfParameters)*cellsPerFace;
  
  const int indexLuhbndInside        = exahype::DataHeap::getInstance().createData(
       sizeLuhbnd,sizeLuhbnd,exahype::DataHeap::Allocation::UseRecycledEntriesIfPossibleCreateNewEntriesIfRequired);
  const int indexLuhbndOutside       = exahype::DataHeap::getInstance().createData(
       sizeLuhbnd,sizeLuhbnd,exahype::DataHeap::Allocation::UseRecycledEntriesIfPossibleCreateNewEntriesIfRequired);
  double* luhbndInside               = exahype::DataHeap::getInstance().getData(indexLuhbndInside).data();
  double* luhbndOutside              = exahype::DataHeap::getInstance().getData(indexLuhbndOutside).data();
  {% endif %}
  
  const int direction   = tarch::la::equalsReturnIndex(posCell, posBoundary);
  const int orientation = (1 + posBoundary(direction) - posCell(direction))/2;
  const int faceIndex   = 2*direction+orientation;
  
  boundaryLayerExtraction(luhbndInside,luh,posBoundary-posCell);
  kernels::finitevolumes::commons::c::boundaryConditions<{{solver}}>(*static_cast<{{solver}}*>(this),luhbndOutside,luhbndInside,cellCentre,cellSize,t,dt,faceIndex,direction);
  ghostLayerFillingAtBoundary(luh,luhbndOutside,posBoundary-posCell);
  {%if tempVarsOnStack==False %}
  
  exahype::DataHeap::getInstance().deleteData(indexLuhbndInside,true);
  exahype::DataHeap::getInstance().deleteData(indexLuhbndOutside,true);
  {% endif %}
}


void {{project}}::{{abstractSolver}}::ghostLayerFilling(double* const luh,const double* const luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFilling<{{solver}}>(*static_cast<{{solver}}*>(this),luh,luhNeighbour,neighbourPosition);
}

void {{project}}::{{abstractSolver}}::ghostLayerFillingAtBoundary(double* const luh,const double* const luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFillingAtBoundary<{{solver}}>(*static_cast<{{solver}}*>(this),luh,luhbnd,boundaryPosition);
}

void {{project}}::{{abstractSolver}}::boundaryLayerExtraction(double* const luhbnd,const double* const luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::boundaryLayerExtraction<{{solver}}>(*static_cast<{{solver}}*>(this),luhbnd,luh,boundaryPosition);
}

double {{project}}::{{abstractSolver}}::riemannSolver(double* fL, double *fR, const double* qL, const double* qR, const double* gradQL, const double* gradQR, const double* cellSize, int direction) {
  // Default FV Riemann Solver
  return kernels::finitevolumes::riemannsolvers::c::rusanov<{{useNCP_s}}, {{useFlux_s}}, {{useViscousFlux_s}}, {{solver}}>(*static_cast<{{solver}}*>(this), fL,fR,qL,qR,gradQL, gradQR, cellSize, direction);

}

//--------

{% if numberOfGlobalObservables > 0 %}
{{project}}::{{abstractSolver}}::ReadOnlyGlobalObservables {{project}}::{{abstractSolver}}::getGlobalObservables() const {
  return ReadOnlyGlobalObservables(_globalObservables.data());
}
{% endif %}

void {{project}}::{{abstractSolver}}::resetGlobalObservables(double* const globalObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables wrappedGlobalObservables(globalObservables);
  static_cast<{{solver}}*>(this)->resetGlobalObservables(wrappedGlobalObservables);
{% endif %}
}

void {{project}}::{{abstractSolver}}::updateGlobalObservables(
    double* const                               globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
{% if numberOfGlobalObservables > 0 %}
  double mappedObservables[NumberOfGlobalObservables];
  GlobalObservables wrappedMappedObservables(mappedObservables);
  static_cast<{{solver}}*>(this)->mapGlobalObservables(wrappedMappedObservables,luh,cellSize);
  // reduce
  GlobalObservables         wrappedGlobalObservables(globalObservables);
  ReadOnlyGlobalObservables wrappedOtherObservables(mappedObservables);
  tarch::multicore::Lock lock(_reductionSemaphore);
  static_cast<{{solver}}*>(this)->mergeGlobalObservables(wrappedGlobalObservables,wrappedOtherObservables);
  lock.free();
{% endif %}
}

void {{project}}::{{abstractSolver}}::mergeGlobalObservables(double* const globalObservables,const double* const otherObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables         wrappedGlobalObservables(globalObservables);
  ReadOnlyGlobalObservables wrappedOtherObservables(otherObservables);
  static_cast<{{solver}}*>(this)->mergeGlobalObservables(wrappedGlobalObservables,wrappedOtherObservables);
{% endif %}
}

void {{project}}::{{abstractSolver}}::wrapUpGlobalObservables(double* const globalObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables wrappedGlobalObservables(globalObservables);
  static_cast<{{solver}}*>(this)->wrapUpGlobalObservables(wrappedGlobalObservables);
{% endif %}
}

//--------

// user hooks
void {{project}}::{{abstractSolver}}::resetGlobalObservables(GlobalObservables& globalObservables) const {
  abortWithMsg("If this operation is entered (resetGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::mapGlobalObservables(
    GlobalObservables&                          globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize) const {
  abortWithMsg("If this operation is entered (mapGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::mergeGlobalObservables(
    GlobalObservables&         globalObservables,
    ReadOnlyGlobalObservables& otherObservables) const {
  abortWithMsg("If this operation is entered (mergeGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::wrapUpGlobalObservables(GlobalObservables& globalObservables) const {
  // Please re-implement if required.
}

/**
 * Fallback implementations of joined functions. Users can either safely ignore this
 * or overwrite with their own implementations.
 **/
 // @todo Can we remove this one?
#include "kernels/fusedMethods.cpph"
