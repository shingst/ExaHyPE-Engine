// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============


//**********************************
//**********************************
//***** USE ONLY FOR DEBUGGING *****
//**********************************
//**********************************

/*
  README
  ------

  This abstractsolver implementation uses the converter to be able to switch some optimised kernels
  with the generic ones. Just change the corresponding boolean hardcoded value in the corresponding
  method. By default uses the optimised code.

  This may help identify a faulty optimised kernel.

  This implementation is not always maintained and might be deprecated.

  Doesn't work with notimeavg
 */

#include "{{abstractSolver}}.h"
#include "{{optKernelPath}}/Kernels.h"
#include "{{optKernelPath}}/converter.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "{{solver}}_Variables.h"
#include "{{solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// We define the constructor of the actual solver here in order to regenerate it easily.
{{project}}::{{solver}}::{{solver}}(double maximumMeshSize,int maximumMeshDepth,int DMPObservables,exahype::solvers::Solver::TimeStepping timeStepping {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}{% if hasConstants %}):
{{abstractSolver}}::{{abstractSolver}}(maximumMeshSize,maximumMeshDepth,DMPObservables,timeStepping {% if enableProfiler %}, std::move(profiler) {% endif %}) {
}



{{project}}::{{abstractSolver}}::{{abstractSolver}}(double maximumMeshSize,int maximumMeshDepth,int DMPObservables,exahype::solvers::Solver::TimeStepping timeStepping {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler {% endif %} ):
      exahype::solvers::ADERDGSolver("{{solver}}",{{optNamespace}}::getNumberOfVariable(),{{optNamespace}}::getNumberOfParameter(),{{optNamespace}}::getBasisSize(),
                                     maximumMeshSize,maximumMeshDepth,DMPObservables,timeStepping {% if enableProfiler %}, std::move(profiler){% endif %}) {
}



void {{project}}::{{abstractSolver}}::constantsToString(std::ostream& os) {
  // This string is used in the --version output to identify compile time constants
  os << "{{project}}::{{abstractSolver}}("
      << "nVar=" << NumberOfVariables << ", "
      << "nParam=" << NumberOfParameters << ", "
      << "nDim=" << Dimensions << ", "
      << "order=" << Order
      << ")";
}



void {{project}}::{{abstractSolver}}::spaceTimePredictor(double* const lQhbnd,double* const lFhbnd,double** const tempSpaceTimeUnknowns,double** const tempSpaceTimeFluxUnknowns,double* const tempUnknowns,double* const tempFluxUnknowns,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx,const double dt, double** const tempPointForceSources) {
  {% if enableProfiler %}
  _profiler->start("spaceTimePredictor");
  {% endif %}

  constexpr bool useGeneric = false;

  if(useGeneric) {

#if DIMENSIONS==2
    double cellSize[2];
#else
    double cellSize[3];
    cellSize[2] = 1.0/inverseDx[2];
#endif
    cellSize[0] = 1.0/inverseDx[0];
    cellSize[1] = 1.0/inverseDx[1];

    double* lQhi = new double[{{optNamespace}}::converter::getQhiGenArraySize()];
    double* lFhi = new double[{{optNamespace}}::converter::getFhiGenArraySize()];
    double* Qbnd = new double[{{optNamespace}}::converter::getQhbndGenArraySize()];
    double* Fbnd = new double[{{optNamespace}}::converter::getFhbndGenArraySize()];
    {{optNamespace}}::converter::Qhi_optimised2generic(tempUnknowns, lQhi);
    {{optNamespace}}::converter::Fhi_optimised2generic(tempFluxUnknowns, lFhi);
    {{optNamespace}}::converter::Qhbnd_optimised2generic(lQhbnd, Qbnd);
    {{optNamespace}}::converter::Fhbnd_optimised2generic(lFhbnd, Fbnd);

    {% if usePointSources %}
    double* pointForceSources_g[2];
    pointForceSources_g[0] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
    pointForceSources_g[1] = tempPointForceSources[1];
    {{optNamespace}}::converter::PSi_optimised2generic(tempPointForceSources[0],pointForceSources_g[0]);
    {% else %}
    double** pointForceSources_g = nullptr;
    {% endif %}


    {% if  isLinear %}
    kernels::aderdg::generic::c::spaceTimePredictorLinear<{{usePointSources_s}}, {{useSource_s}}, {{useFlux_s}}, {{useNCP_s}}, {{useMaterialParameters}}, {{solver}}>(*static_cast<{{solver}}*>(this), Qbnd, Fbnd, tempSpaceTimeUnknowns, tempSpaceTimeFluxUnknowns, lQhi, lFhi, luh, &cellSize[0], dt, pointForceSources_g);
    {% else %}
    kernels::aderdg::generic::c::spaceTimePredictorNonlinear<{{useSource_s}}, {{useFlux_s}}, {{useNCP_s}}, {{noTimeAveraging}}, {{solver}}>(*static_cast<{{solver}}*>(this), Qbnd, Fbnd, tempSpaceTimeUnknowns, tempSpaceTimeFluxUnknowns, lQhi, lFhi, luh, &cellSize[0], dt);
    {% endif %}

    {{optNamespace}}::converter::Qhi_generic2optimised(lQhi, tempUnknowns);
    {{optNamespace}}::converter::Fhi_generic2optimised(lFhi, tempFluxUnknowns);
    {{optNamespace}}::converter::Qhbnd_generic2optimised(Qbnd, lQhbnd);
    {{optNamespace}}::converter::Fhbnd_generic2optimised(Fbnd, lFhbnd);

    delete[] lQhi;
    delete[] lFhi;
    delete[] Qbnd;
    delete[] Fbnd;
    {% if usePointSources %}
    delete[] pointForceSources_g[0];
    {% endif %}


  } else {

    {% if useFlux %}
    {% if dimensions == 2 %}
    constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
    constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**nDim)*nVarPad
    {% else %}
    constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
    constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**nDim)*nVarPad
    {% endif %}
    {% else %}
    constexpr int lSi_offset  = 0; //no Flux
    constexpr int lShi_offset = 0; //no Flux
    {% endif %}

    {% if  isLinear %}
    {{optNamespace}}::spaceTimePredictorLinear(*static_cast<{{solver}}*>(this), lQhbnd, lFhbnd, tempSpaceTimeUnknowns[0] /*lQi*/, tempSpaceTimeFluxUnknowns[0] /*lFi*/, &tempSpaceTimeFluxUnknowns[0][lSi_offset] /*lSi*/, tempUnknowns /*lQhi*/, tempFluxUnknowns /*lFhi*/, &tempFluxUnknowns[lShi_offset] /*lShi*/, tempSpaceTimeFluxUnknowns[1] /*gradQ*/, tempPointForceSources[0] /*PSi*/, tempPointForceSources[1] /*PSderivatives*/, luh, inverseDx, dt);
    {% else %}
    {% if noTimeAveraging %}
    //No Time Averaging scheme
    {{optNamespace}}::picardLoopNonlinear(*static_cast<{{solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], {% if useNCP %}tempSpaceTimeFluxUnknowns[1]{% else %}nullptr{% endif %}); //lSi, gradQ
    {{optNamespace}}::extrapolatorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], lQhbnd, lFhbnd);
    {% else %}
    {{optNamespace}}::picardLoopNonlinear(*static_cast<{{solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], {% if useNCP %}tempSpaceTimeFluxUnknowns[1]{% else %}nullptr{% endif %}); //lSi, gradQ
    {{optNamespace}}::predictorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], tempUnknowns, tempFluxUnknowns, &tempFluxUnknowns[lShi_offset]);
    {{optNamespace}}::extrapolatorNonlinear(tempUnknowns, tempFluxUnknowns, lQhbnd, lFhbnd);
    {% endif %}
    {% endif %}

  }

  {% if enableProfiler %}
  _profiler->stop("spaceTimePredictor");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::addUpdateToSolution(double* const luh,const double* const luhOld,const double* const lduh,const double dt) {
  {% if enableProfiler %}
  _profiler->start("solutionUpdate");
  {% endif %}
  {{optNamespace}}::solutionUpdate( luh, luhOld, lduh, dt );
  {% if enableProfiler %}
  _profiler->stop("solutionUpdate");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::volumeIntegral(double* const lduh,const double* const lFi,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
  {% if enableProfiler %}
  _profiler->start("volumeIntegral");
  {% endif %}

  constexpr bool useGeneric = false;

  if(useGeneric) {

#if DIMENSIONS==2
    double cellSize[2];
#else
    double cellSize[3];
    cellSize[2] = 1.0/inverseDx[2];
#endif
    cellSize[0] = 1.0/inverseDx[0];
    cellSize[1] = 1.0/inverseDx[1];

    double* lFhi_g = new double[{{optNamespace}}::converter::getFhiGenArraySize()];
    {{optNamespace}}::converter::Fhi_optimised2generic(lFhi, lFhi_g);
    {% if isLinear %}
    kernels::aderdg::generic::c::volumeIntegralLinear<{{useSource_s}}, {{useFlux_s}}, NumberOfVariables, Order+1>(lduh,lFhi_g,&cellSize[0]);
    {% else %}  
    kernels::aderdg::generic::c::volumeIntegralNonlinear<{{useSource_s}}, {{useFlux_s}}, {{noTimeAveraging}}, NumberOfVariables, Order+1>(lduh,nullptr,lFhi_g,&cellSize[0]);
    {% endif %}

    delete[] lFhi_g;


  } else {

    {% if useFlux %}
    {% if dimensions == 2 %}
    {% if noTimeAveraging %}
    constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
    {% else %}
    constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
    {% endif %}
    {% else %}
    {% if noTimeAveraging %}
    constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
    {% else %}
    constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
    {% endif %}
    {% endif %}
    {% else %}
    constexpr int lSi_offset  = 0; //no Flux
    constexpr int lShi_offset = 0; //no Flux
    {% endif %}

    {% if noTimeAveraging %}
    //No Time Averaging scheme, lFhi == nullptr
    {{optNamespace}}::volumeIntegral( lduh, lFi, &lFi[lSi_offset], inverseDx );
    {% else %}
    //Time averaging scheme, lFi not required
    {{optNamespace}}::volumeIntegral( lduh, lFhi, &lFhi[lShi_offset], inverseDx );
    {% endif %}

  }

  {% if enableProfiler %}
  _profiler->stop("volumeIntegral");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::surfaceIntegral(double* const lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
  {% if enableProfiler %}
  _profiler->start("surfaceIntegral");
  {% endif %}

  constexpr bool useGeneric = false;

  if(useGeneric) {

#if DIMENSIONS==2
    double cellSize[2];
#else
    double cellSize[3];
    cellSize[2] = 1.0/inverseDx[2];
#endif
    cellSize[0] = 1.0/inverseDx[0];
    cellSize[1] = 1.0/inverseDx[1];

    double* lFhbnd_g = new double[{{optNamespace}}::converter::getFhbndGenArraySize()];
    {{optNamespace}}::converter::Fhbnd_optimised2generic(lFhbnd, lFhbnd_g);
    {% if isLinear %}
    kernels::aderdg::generic::c::surfaceIntegralLinear<NumberOfVariables, Order+1>(lduh,lFhbnd_g,&cellSize[0]);
    {% else %}
    kernels::aderdg::generic::c::surfaceIntegralNonlinear<NumberOfVariables, Order+1>(lduh,lFhbnd_g,&cellSize[0]);
    {% endif %}

    delete[] lFhbnd_g;

  } else {

    {{optNamespace}}::surfaceIntegral( lduh, lFhbnd, inverseDx );

  }
  {% if enableProfiler %}
  _profiler->stop("surfaceIntegral");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double t,const double dt,const int direction,bool isBoundaryFace, int faceIndex) {
  assertion2(direction>=0,dt,direction);
  assertion2(direction<DIMENSIONS,dt,direction);
  {% if enableProfiler %}
  _profiler->start("riemannSolver");
  {% endif %}

  constexpr bool useGeneric = false;

  if(useGeneric) {

    double* FL_g = new double[{{optNamespace}}::converter::getFFaceGenArraySize()];
    double* FR_g = new double[{{optNamespace}}::converter::getFFaceGenArraySize()];
    double* QL_g = new double[{{optNamespace}}::converter::getQFaceGenArraySize()];
    double* QR_g = new double[{{optNamespace}}::converter::getQFaceGenArraySize()];

    {{optNamespace}}::converter::FFace_optimised2generic(FL,FL_g);
    {{optNamespace}}::converter::FFace_optimised2generic(FR,FR_g);
    {{optNamespace}}::converter::QFace_optimised2generic(QL,QL_g);
    {{optNamespace}}::converter::QFace_optimised2generic(QR,QR_g);
    {% if isLinear %}
    kernels::aderdg::generic::c::riemannSolverLinear<{{useFlux_s}},{{useNCP_s}},{{useMaterialParameters_s}},{{solver}}>(*static_cast<{{solver}}*>(this),FL_g,FR_g,QL_g,QR_g,t,dt,direction);
    {% else %}
    kernels::aderdg::generic::c::riemannSolverNonlinear<{{useNCP_s}},{{solver}}>(*static_cast<{{solver}}*>(this),FL_g,FR_g,QL_g,QR_g,t,dt,direction);
    {% endif %}

    {{optNamespace}}::converter::FFace_generic2optimised(FL_g,FL);
    {{optNamespace}}::converter::FFace_generic2optimised(FR_g,FR);

    delete[] FL_g;  
    delete[] FR_g;  
    delete[] QL_g;  
    delete[] QR_g;

  } else {

    {{optNamespace}}::riemannSolver(*static_cast<{{solver}}*>(this), FL, FR, QL, QR, t, dt, direction);

  }
  {% if enableProfiler %}
  _profiler->stop("riemannSolver");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::boundaryConditions(double* const fluxOut,double* const stateOut,const double* const fluxIn,const double* const stateIn,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int direction) {
  {% if enableProfiler %}
  _profiler->start("boundaryConditions");
  {% endif %}
  {{optNamespace}}::boundaryConditions(*static_cast<{{solver}}*>(this), fluxOut, stateOut, fluxIn, stateIn, cellCentre, cellSize, t, dt, faceIndex, direction );
  {% if enableProfiler %}
  _profiler->stop("boundaryConditions");
  {% endif %}
}



double {{project}}::{{abstractSolver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
  {% if enableProfiler %}
  _profiler->start("stableTimeStepSize");
  {% endif %}
  double d = {{optNamespace}}::stableTimeStepSize(*static_cast<{{solver}}*>(this), luh, inverseDx );
  {% if enableProfiler %}
  _profiler->stop("stableTimeStepSize");
  {% endif %}
  return d;
}



{% if !patchwiseAdjust %}
void {{project}}::{{abstractSolver}}::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,double dt) {
  {% if enableProfiler %}
  _profiler->start("solutionAdjustment");
  {% endif %}
  {{optNamespace}}::solutionAdjustment(*static_cast<{{solver}}*>(this), luh, cellCentre, cellSize, t, dt );
  {% if enableProfiler %}
  _profiler->stop("solutionAdjustment");
  {% endif %}
}
{% endif %}


void {{project}}::{{abstractSolver}}::deltaDistribution(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize, double** const tempPointForceSources) {
  {% if usePointSources %}
  {% if enableProfiler %}
  _profiler->start("deltaDistribution");
  {% endif %}
  constexpr bool useGeneric = false;

  if(useGeneric) {
    double** tmp = new double*[2];
    tmp[0] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
    tmp[1] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
    kernels::aderdg::generic::c::deltaDistribution<{{solver}}>(*static_cast<{{solver}}*>(this), t, dt, cellCentre, cellSize,getNodesPerCoordinateAxis(), tmp);

    {{optNamespace}}::converter::PSi_generic2optimised(tmp[0],tempPointForceSources[0]);

    delete[] tmp[0];
    delete[] tmp[1];
    delete[] tmp;
  } else {
    {{optNamespace}}::deltaDistribution(*static_cast<{{solver}}*>(this), t, dt, cellCentre, cellSize, tempPointForceSources);
  }
  {% if enableProfiler %}
  _profiler->stop("deltaDistribution");
  {% endif %}
  {% else %}
  //Point sources aren't defined, this method should be empty
  {% endif %}
}


void {{project}}::{{abstractSolver}}::faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
  {% if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
  {% endif %}
  {{optNamespace}}::faceUnknownsProlongation( lQhbndFine, lFhbndFine, lQhbndCoarse, lFhbndCoarse, coarseGridLevel, fineGridLevel, subfaceIndex);
  {% if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::faceUnknownsRestriction(double* const lQhbndCoarse,double* const lFhbndCoarse,const double* const lQhbndFine,const double* const lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
  {% if enableProfiler %}
  _profiler->start("faceUnknownsRestriction");
  {% endif %}
  {{optNamespace}}::faceUnknownsRestriction( lQhbndCoarse, lFhbndCoarse, lQhbndFine, lFhbndFine, coarseGridLevel, fineGridLevel, subfaceIndex);
  {% if enableProfiler %}
  _profiler->stop("faceUnknownsRestriction");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsProlongation(double* const luhFine,const double* const luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
  {% if enableProfiler %}
  _profiler->start("volumeUnknownsProlongation");
  {% endif %}
  {{optNamespace}}::volumeUnknownsProlongation( luhFine, luhCoarse, coarseGridLevel, fineGridLevel, subcellIndex);
  {% if enableProfiler %}
  _profiler->stop("volumeUnknownsProlongation");
  {% endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsRestriction(double* const luhCoarse,const double* const luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
  {% if enableProfiler %}
  _profiler->start("volumeUnknownsRestriction");
  {% endif %}
  {{optNamespace}}::volumeUnknownsRestriction( luhCoarse, luhFine, coarseGridLevel, fineGridLevel, subcellIndex);
  {% if enableProfiler %}
  _profiler->stop("volumeUnknownsRestriction");
  {% endif %}
}

//--------

{% if numberOfGlobalObservables > 0 %}
{{project}}::{{abstractSolver}}::ReadOnlyGlobalObservables {{project}}::{{abstractSolver}}::getGlobalObservables() const {
  return ReadOnlyGlobalObservables(_globalObservables.data());
}
{% endif %}

void {{project}}::{{abstractSolver}}::resetGlobalObservables(double* const globalObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables wrappedGlobalObservables(globalObservables);
  static_cast<{{solver}}*>(this)->resetGlobalObservables(wrappedGlobalObservables);
{% endif %}
}

void {{project}}::{{abstractSolver}}::updateGlobalObservables(
    double* const                               globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize,
    const double t,
    const double dt) {
{% if numberOfGlobalObservables > 0 %}
  double mappedObservables[NumberOfGlobalObservables];
  GlobalObservables wrappedMappedObservables(mappedObservables);
  static_cast<{{solver}}*>(this)->resetGlobalObservables(wrappedMappedObservables);
  static_cast<{{solver}}*>(this)->mapGlobalObservables(wrappedMappedObservables,luh,cellCentre,cellSize,t,dt);
  // reduce
  GlobalObservables         wrappedGlobalObservables(globalObservables);
  ReadOnlyGlobalObservables wrappedOtherObservables(mappedObservables);
  tarch::multicore::Lock lock(_reductionSemaphore);
  static_cast<{{solver}}*>(this)->mergeGlobalObservables(wrappedGlobalObservables,wrappedOtherObservables);
  lock.free();
{% endif %}
}

void {{project}}::{{abstractSolver}}::mergeGlobalObservables(double* const globalObservables,const double* const otherObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables         wrappedGlobalObservables(globalObservables);
  ReadOnlyGlobalObservables wrappedOtherObservables(otherObservables);
  static_cast<{{solver}}*>(this)->mergeGlobalObservables(wrappedGlobalObservables,wrappedOtherObservables);
{% endif %}
}

void {{project}}::{{abstractSolver}}::wrapUpGlobalObservables(double* const globalObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables wrappedGlobalObservables(globalObservables);
  static_cast<{{solver}}*>(this)->wrapUpGlobalObservables(wrappedGlobalObservables);
{% endif %}
}

//--------

void {{project}}::{{abstractSolver}}::abortWithMsg(const char* const msg) {
  // verbosily fail even without assertions turned on
  puts(msg);
  abort();
}

void {{project}}::{{abstractSolver}}::flux(const double* const Q,double** const F) {
  abortWithMsg("If this operation is entered (flux), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::algebraicSource(const double* const Q,double* const S) {
  abortWithMsg("If this operation is entered (algebraicSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  abortWithMsg("If this operation is entered (nonConservativeProduct), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::pointSource(const double* const x,const double t,const double dt, double* const forceVector, double* const x0, int n) {
  abortWithMsg("If this operation is entered (pointSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::resetGlobalObservables(GlobalObservables& globalObservables) const {
  abortWithMsg("If this operation is entered (resetGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::mapGlobalObservables(
    GlobalObservables&                          globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize,
    const double t,
    const double dt) const {
  abortWithMsg("If this operation is entered (mapGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::mergeGlobalObservables(
    GlobalObservables&         globalObservables,
    ReadOnlyGlobalObservables& otherObservables) const {
  abortWithMsg("If this operation is entered (mergeGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::wrapUpGlobalObservables(GlobalObservables& globalObservables) const {
  // Please re-implement if required.
}
