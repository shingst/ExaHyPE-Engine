#ifndef __{{solver}}_CLASS_HEADER__
#define __{{solver}}_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <string>
{% if aderdgContext.countFlops %}
#include <atomic>
#include <iostream>
{% endif %}

#include "exahype/solvers/LimitingADERDGSolver.h"
#include "{{ADERDGSolver}}.h"
#include "{{FVSolver}}.h"

namespace {{project}}{
  class {{solver}};
}

class {{project}}::{{solver}}: public exahype::solvers::LimitingADERDGSolver {  
  public:
    static constexpr int NumberOfVariables      = {{project}}::{{ADERDGAbstractSolver}}::NumberOfVariables;
    static constexpr int NumberOfParameters     = {{project}}::{{ADERDGAbstractSolver}}::NumberOfParameters;
    static constexpr int Order                  = {{project}}::{{ADERDGAbstractSolver}}::Order;
    static constexpr int NumberOfDMPObservables = {{project}}::{{ADERDGAbstractSolver}}::NumberOfDMPObservables;
    static constexpr int GhostLayerWidth        = {{project}}::{{FVAbstractSolver}}::GhostLayerWidth;
  
    {{solver}}(
        const double maximumMeshSize,
        const int maximumMeshDepth,
        const int haloCells,
        const int regularisedFineGridLevels,
        const exahype::solvers::Solver::TimeStepping timeStepping,
        const int DMPObservables,
        const double DMPRelaxationParameter,
        const double DMPDifferenceScaling
        {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %});
    
    {% if aderdgContext.countFlops %}
    static std::atomic_ulong total_flops;
    static std::atomic_ulong total_time;
    
    static std::atomic_ulong projectOnFVLimiterSpace_f;
    static std::atomic_ulong projectOnFVLimiterSpace_t;
    static std::atomic_ulong projectOnFVLimiterSpace_c;
    
    static std::atomic_ulong projectOnDGSpace_f;
    static std::atomic_ulong projectOnDGSpace_t;
    static std::atomic_ulong projectOnDGSpace_c;
    
    static std::atomic_ulong discreteMaximumPrincipleAndMinAndMaxSearch_f;
    static std::atomic_ulong discreteMaximumPrincipleAndMinAndMaxSearch_t;
    static std::atomic_ulong discreteMaximumPrincipleAndMinAndMaxSearch_c;
    
    static std::atomic_ulong findCellLocalMinAndMax_f;
    static std::atomic_ulong findCellLocalMinAndMax_t;
    static std::atomic_ulong findCellLocalMinAndMax_c;

    static std::atomic_ulong findCellLocalLimiterMinAndMax_f;
    static std::atomic_ulong findCellLocalLimiterMinAndMax_t;
    static std::atomic_ulong findCellLocalLimiterMinAndMax_c;


    virtual ~{{solver}}(){
      std::cout << "Performances, {{solver}}" << std::endl << "------------------------------------" << std::endl << std::endl;
      
      std::cout << "Total flops: " << total_flops.load() << std::endl << "Total time: " << ((double)total_time.load()) / 1000000000.0 << std::endl << "Total GFlops: " <<  ((double) total_flops.load()) / ((double) total_time.load()) << std::endl << std::endl;
      
      std::cout << "projectOnFVLimiterSpace flops: " << projectOnFVLimiterSpace_f.load() << std::endl << "projectOnFVLimiterSpace time: " << ((double)projectOnFVLimiterSpace_t.load()) / 1000000000.0 << std::endl << "projectOnFVLimiterSpace GFlops: " <<  ((double) projectOnFVLimiterSpace_f.load()) / ((double) projectOnFVLimiterSpace_t.load()) << std::endl << "projectOnFVLimiterSpace calls: " << projectOnFVLimiterSpace_c.load() << std::endl << std::endl;
      
      std::cout << "projectOnDGSpace flops: " << projectOnDGSpace_f.load() << std::endl << "projectOnDGSpace time: " << ((double)projectOnDGSpace_t.load()) / 1000000000.0 << std::endl << "projectOnDGSpace GFlops: " <<  ((double) projectOnDGSpace_f.load()) / ((double) projectOnDGSpace_t.load()) << std::endl << "projectOnDGSpace calls: " << projectOnDGSpace_c.load() << std::endl << std::endl;
      
      std::cout << "discreteMaximumPrincipleAndMinAndMaxSearch flops: " << discreteMaximumPrincipleAndMinAndMaxSearch_f.load() << std::endl << "discreteMaximumPrincipleAndMinAndMaxSearch time: " << ((double)discreteMaximumPrincipleAndMinAndMaxSearch_t.load()) / 1000000000.0 << std::endl << "discreteMaximumPrincipleAndMinAndMaxSearch GFlops: " <<  ((double) discreteMaximumPrincipleAndMinAndMaxSearch_f.load()) / ((double) discreteMaximumPrincipleAndMinAndMaxSearch_t.load()) << std::endl << "discreteMaximumPrincipleAndMinAndMaxSearch calls: " << discreteMaximumPrincipleAndMinAndMaxSearch_c.load() << std::endl << std::endl;
      
      std::cout << "findCellLocalMinAndMax flops: " << findCellLocalMinAndMax_f.load() << std::endl << "findCellLocalMinAndMax time: " << ((double)findCellLocalMinAndMax_t.load()) / 1000000000.0 << std::endl << "findCellLocalMinAndMax GFlops: " <<  ((double) findCellLocalMinAndMax_f.load()) / ((double) findCellLocalMinAndMax_t.load()) << std::endl << "findCellLocalMinAndMax calls: " << findCellLocalMinAndMax_c.load() << std::endl << std::endl;
      
      std::cout << "findCellLocalLimiterMinAndMax flops: " << findCellLocalLimiterMinAndMax_f.load() << std::endl << "findCellLocalLimiterMinAndMax time: " << ((double)findCellLocalLimiterMinAndMax_t.load()) / 1000000000.0 << std::endl << "findCellLocalLimiterMinAndMax GFlops: " <<  ((double) findCellLocalLimiterMinAndMax_f.load()) / ((double) findCellLocalLimiterMinAndMax_t.load()) << std::endl << "findCellLocalLimiterMinAndMax calls: " << findCellLocalLimiterMinAndMax_c.load() << std::endl << std::endl;
    }
{% endif %}
    
    void projectOnFVLimiterSpace(const double* const luh, double* const lim) const override;
    void projectOnDGSpace(const double* const lim, double* const luh) const override;
    bool discreteMaximumPrincipleAndMinAndMaxSearch(const double* const luh, double* const boundaryMinPerVariables, double* const boundaryMaxPerVariables) override;
    void findCellLocalMinAndMax(const double* const luh, double* const localMinPerVariables, double* const localMaxPerVariable) override;
    void findCellLocalLimiterMinAndMax(const double* const lim, double* const localMinPerObservable, double* const localMaxPerObservable) override;
};

#endif // __{{solver}}_CLASS_HEADER__
