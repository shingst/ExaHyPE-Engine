
#include "{{Solver}}.h"

#include "tarch/la/ScalarOperations.h"

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{Solver}}.h"

#include "kernels/aderdg/generic/Kernels.h"

{{Project}}::{{Solver}}::{{Solver}}(double maximumMeshSize, exahype::solvers::Solver::TimeStepping timeStepping{{SolverConstructorSignatureExtension}}):
  exahype::solvers::{{Solver}}Solver("{{Solver}}", nVar /* numberOfUnknowns */, nParams /* numberOfParameters */, {{Order}} + 1  /* nodesPerCoordinateAxis */, maximumMeshSize, timeStepping{{SolverConstructorArgumentExtension}}) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::spaceTimePredictor(double* const lQhbnd,double* const lFhbnd,double** const tempSpaceTimeUnknowns,double** const tempSpaceTimeFluxUnknowns,double* const  tempUnknowns,double* const  tempFluxUnknowns,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double dt) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::solutionUpdate(double* const luh, const double* const lduh, const double dt) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::volumeIntegral(double* const lduh, const double* const lFhi, const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::surfaceIntegral(double* const lduh, const double* const lFhbnd, const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::riemannSolver(double* const FL, double* const FR, const double* const QL, const double* const QR, double* const tempFaceUnknownsArray, double** const tempStateSizedVectors, double** const tempStateSizedSquareMatrices, const double t, const double dt, const int direction) {
  assertion2(direction>=0,dt,direction);
  assertion2(direction<DIMENSIONS,dt,direction);
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::boundaryConditions(double* const fluxOut,double* const stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS, double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int direction) {
  // @todo Please implement/augment if required
}



double {{Project}}::{{Solver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
  // @todo Please implement/augment if required
  return std::numeric_limits<double>::max();
}



void {{Project}}::{{Solver}}::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,double dt) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::faceUnknownsRestriction(double* const lQhbndCoarse,double* const lFhbndCoarse,const double* const lQhbndFine,const double* const lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::volumeUnknownsProlongation(double* const luhFine, const double* const luhCoarse, const int coarseGridLevel, const int fineGridLevel, const tarch::la::Vector<DIMENSIONS, int>& subcellIndex) {
  // @todo Please implement/augment if required
}



void {{Project}}::{{Solver}}::volumeUnknownsRestriction(double* const luhCoarse, const double* const luhFine, const int coarseGridLevel, const int fineGridLevel, const tarch::la::Vector<DIMENSIONS, int>& subcellIndex) {
  // @todo Please implement/augment if required
}

