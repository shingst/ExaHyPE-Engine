// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// ==============================================
#include "{{abstractSolver}}.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "kernels/GaussLegendreBasis.h"
#include "kernels/GaussLobattoBasis.h"

#include "{{solver}}_Variables.h"
#include "{{solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// quadrature weights and operators
double**   {{project}}::{{abstractSolver}}::weights                                 = kernels::{{basis}}::weights;
double**   {{project}}::{{abstractSolver}}::nodes                                   = kernels::{{basis}}::nodes;
double***  {{project}}::{{abstractSolver}}::Kxi                                     = kernels::{{basis}}::Kxi;
double***  {{project}}::{{abstractSolver}}::dudx                                    = kernels::{{basis}}::dudx;
double***  {{project}}::{{abstractSolver}}::iK1                                     = kernels::{{basis}}::iK1;
double***  {{project}}::{{abstractSolver}}::equidistantGridProjector                = kernels::{{basis}}::equidistantGridProjector;
double***  {{project}}::{{abstractSolver}}::FCoeff                                  = kernels::{{basis}}::FCoeff;
double**** {{project}}::{{abstractSolver}}::fineGridProjector                       = kernels::{{basis}}::fineGridProjector;
kernels::UnivariateFunction** {{project}}::{{abstractSolver}}::basisFunction                 = kernels::{{basis}}::basisFunction;
kernels::UnivariateFunction** {{project}}::{{abstractSolver}}::basisFunctionFirstDerivative  = kernels::{{basis}}::basisFunctionFirstDerivative;
kernels::UnivariateFunction** {{project}}::{{abstractSolver}}::basisFunctionSecondDerivative = kernels::{{basis}}::basisFunctionSecondDerivative;

// We define the constructor of the actual solver here in order to regenerate it easily.
{{project}}::{{solver}}::{{solver}}(
  const double maximumMeshSize,
  const int maximumMeshDepth,
  const int haloCells,
  const int regularisedFineGridLevels,
  const exahype::solvers::Solver::TimeStepping timeStepping,
  const int DMPObservables
  {% if enableProfiler %},std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %})
  :
  {{abstractSolver}}::{{abstractSolver}}(
      maximumMeshSize,
      maximumMeshDepth,
      haloCells,
      regularisedFineGridLevels,
      timeStepping,
      DMPObservables
      {% if enableProfiler %},std::move(profiler){% endif %}) {
}


{{project}}::{{abstractSolver}}::{{abstractSolver}}(
    const double maximumMeshSize,
    const int maximumMeshDepth,
    const int haloCells,
    const int regularisedFineGridLevels,
    const exahype::solvers::Solver::TimeStepping timeStepping,
    const int DMPObservables
    {% if enableProfiler %},std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %})
  :
  exahype::solvers::ADERDGSolver(
      "{{solver}}",
      NumberOfVariables,
      NumberOfParameters,
      NumberOfGlobalObservables,
      Order+1,
      maximumMeshSize,
      maximumMeshDepth,
      haloCells,
      regularisedFineGridLevels,
      timeStepping,
      DMPObservables
      {% if enableProfiler %},std::move(profiler){% endif %}) {
}

void {{project}}::{{abstractSolver}}::constantsToString(std::ostream& os) {
  // This string is used in the --version output to identify compile time constants
  os << "{{project}}::{{abstractSolver}}("
     << "nVar=" << NumberOfVariables << ", "
     << "nParam=" << NumberOfParameters << ", "
     << "Order=" << Order
     << ")";
}

void {{project}}::{{abstractSolver}}::abortWithMsg(const char* const msg) {
  // verbosily fail even without assertions turned on
  puts(msg);
  abort();
}

int {{project}}::{{abstractSolver}}::fusedSpaceTimePredictorVolumeIntegral(double* lduh, double* lQhbnd, double* lGradQhbnd, double* lFhbnd, double* const luh, const tarch::la::Vector<DIMENSIONS, double>& cellCentre, const tarch::la::Vector<DIMENSIONS, double>& cellSize, const double t ,const double dt,const bool addVolumeIntegralResultToUpdate) {
{% if enableProfiler %}
  _profiler->start("fusedSpaceTimePredictorVolumeIntegral");
{% endif %}
{% if dimensions==3 %}
  constexpr int spaceBasisSize     = (Order+1)*(Order+1)*(Order+1);
{% else %}
  constexpr int spaceBasisSize     = (Order+1)*(Order+1);
{% endif %}
  constexpr int spaceTimeBasisSize = spaceBasisSize*(Order+1);
{% if isLinear %}
  constexpr int sizeLQi                = (NumberOfVariables+NumberOfParameters)*spaceBasisSize*(Order+2);
  constexpr int sizeLFi                = (DIMENSIONS + 1)*NumberOfVariables*spaceTimeBasisSize;
  constexpr int sizeGradQ              = DIMENSIONS*NumberOfVariables*spaceBasisSize;
  constexpr int sizePSi                = NumberOfVariables*spaceBasisSize*(Order+2);
  constexpr int sizePSderivatives      = NumberOfVariables*spaceTimeBasisSize;
  constexpr int sizeTmp_PSderivatives  = sizePSderivatives;

  constexpr int sizeLQhi = (NumberOfVariables+NumberOfParameters)*spaceBasisSize;
  constexpr int sizeLFhi = (DIMENSIONS + 1)*NumberOfVariables*spaceBasisSize;
  
  constexpr int totalSize = sizeLQi + sizeLFi + sizeGradQ +
                            sizePSi + sizePSderivatives + sizeTmp_PSderivatives +
                            sizeLQhi + sizeLFhi;
{%   if tempVarsOnStack %}
  double block[totalSize];
{%   else %}  
  double* block = new double[totalSize]; 
{%   endif %}
  double* memory = block;
  
  double* lQi                = memory; memory+=sizeLQi;
  double* lFi                = memory; memory+=sizeLFi;
  double* gradQ              = memory; memory+=sizeGradQ;
  double* PSi                = memory; memory+=sizePSi;
  double* PSderivatives      = memory; memory+=sizePSderivatives;
  double* tmp_PSderivatives  = memory; memory+=sizeTmp_PSderivatives;
  
  double* lQhi               = memory; memory+=sizeLQhi;
  double* lFhi               = memory; memory+=sizeLFhi;

  const int picardIterations = 1;

{%   if usePointSources %}
  std::vector<int>* pointSources= kernels::aderdg::generic::c::getPointSources<{{solver}}>(*static_cast<{{solver}}*>(this),cellCentre,cellSize);
   
  if(pointSources != nullptr) {
    kernels::aderdg::generic::c::deltaDistribution<{{solver}}>(*static_cast<{{solver}}*>(this), luh, t, dt, cellCentre, cellSize, pointSources, PSi);
    kernels::aderdg::generic::c::spaceTimePredictorLinear<true , {{useSource_s}}, {{useFlux_s}}, {{useNCP_s}}, {{useMaterialParameters_s}}, {{solver}}>(*static_cast<{{solver}}*>(this),lQhbnd,lFhbnd,lQi,lFi,gradQ,PSi,PSderivatives,tmp_PSderivatives,lQhi,lFhi,luh,cellCentre, tarch::la::invertEntries(cellSize), t, dt);
  }else{
    kernels::aderdg::generic::c::spaceTimePredictorLinear<false, {{useSource_s}}, {{useFlux_s}}, {{useNCP_s}}, {{useMaterialParameters_s}}, {{solver}}>(*static_cast<{{solver}}*>(this),lQhbnd,lFhbnd,lQi,lFi,gradQ,PSi,PSderivatives,tmp_PSderivatives,lQhi,lFhi,luh,cellCentre,tarch::la::invertEntries(cellSize),t, dt);
  }
{% else %}
  kernels::aderdg::generic::c::spaceTimePredictorLinear<{{usePointSources_s}}, {{useSource_s}}, {{useFlux_s}}, {{useNCP_s}}, {{useMaterialParameters_s}}, {{solver}}>(*static_cast<{{solver}}*>(this),lQhbnd,lFhbnd,lQi,lFi,gradQ,PSi,PSderivatives,tmp_PSderivatives,lQhi,lFhi,luh,cellCentre,tarch::la::invertEntries(cellSize),t, dt);
{%   endif %}
  if ( addVolumeIntegralResultToUpdate ) {
    kernels::aderdg::generic::c::volumeIntegralLinear<{{solver}}, {{useSource_s}}, {{useFlux_s}}, NumberOfVariables, Order+1>(lduh,lFhi,cellSize);
  } else { // directly add the result to the solution
    double tempUpdate[NumberOfVariables*spaceBasisSize] = {0.0};
    kernels::aderdg::generic::c::volumeIntegralLinear<{{solver}}, {{useSource_s}}, {{useFlux_s}}, NumberOfVariables, Order+1>(tempUpdate,lFhi,cellSize);
    addUpdateToSolution(luh,luh,tempUpdate,dt);
  }

{% else %}
  constexpr int sizeLQi   = (NumberOfVariables+NumberOfParameters)*spaceTimeBasisSize;
  constexpr int sizeRhs   = sizeLQi;
  constexpr int sizeLFi   = (DIMENSIONS + 1)*NumberOfVariables*spaceTimeBasisSize;
  constexpr int sizeGradQ = DIMENSIONS*NumberOfVariables*spaceBasisSize;
  
  constexpr int sizeLQhi = (NumberOfVariables+NumberOfParameters)*spaceBasisSize;
  constexpr int sizeLFhi = (DIMENSIONS + 1)*NumberOfVariables*spaceBasisSize;

{%   if noTimeAveraging %}
  constexpr int totalSize = sizeLQi + sizeRhs + sizeLFi + sizeGradQ;
{%   else %}  
  constexpr int totalSize = sizeLQi + sizeRhs + sizeLFi + sizeGradQ +
                            sizeLQhi + sizeLFhi;
{%   endif %}

{%   if tempVarsOnStack %}
  double block[totalSize];
{%   else %}  
  double* block = new double[totalSize];
{%   endif %}
  double* memory = block;
      
  double* lQi   = memory; memory+=sizeLQi;
  double* rhs   = memory; memory+=sizeRhs;
  double* lFi   = memory; memory+=sizeLFi;
  double* gradQ = memory; memory+=sizeGradQ;
  
{%   if noTimeAveraging %}
  double* lQhi = lQi;
  double* lFhi = lFi;
{%   else %}
  double* lQhi = memory; memory+=sizeLQhi;
  double* lFhi = memory; memory+=sizeLFhi;
{%   endif %}
  const int picardIterations = kernels::aderdg::generic::c::spaceTimePredictorNonlinear<{{useSource_s}}, {{useFlux_s}}, {{useViscousFlux_s}}, {{useNCP_s}}, {{noTimeAveraging_s}}, {{solver}}>(*static_cast<{{solver}}*>(this), lQhbnd, lGradQhbnd, lFhbnd, lQi, rhs, lFi, gradQ, lQhi, lFhi, luh, cellCentre, tarch::la::invertEntries(cellSize), t, dt);
 
  if ( addVolumeIntegralResultToUpdate ) {
    kernels::aderdg::generic::c::volumeIntegralNonlinear<{{solver}}, {{ 'true' if (useSource or useNCP) else 'false' }}, {{useFlux_s}}, {{noTimeAveraging_s}}, NumberOfVariables, Order+1>(lduh,lFhi,cellSize); 
  } else { // directly add the result to the solution
    double tempUpdate[NumberOfVariables*spaceBasisSize] = {0.0};
    kernels::aderdg::generic::c::volumeIntegralNonlinear<{{solver}}, {{ 'true' if (useSource or useNCP) else 'false' }}, {{useFlux_s}}, {{noTimeAveraging_s}}, NumberOfVariables, Order+1>(tempUpdate,lFhi,cellSize);
    addUpdateToSolution(luh,luh,tempUpdate,dt);
  }
  
{% if transformRiemannData %}
  constexpr int faceBasisSize = spaceBasisSize / (Order+1);
  // pre-processing done here as predictor is done cell-wisely
  for ( int direction=0; direction<DIMENSIONS; direction++ ) {
    for ( int orientation=0; orientation<1; orientation++ ) {
      const int faceIndex = 2*direction + orientation;
      static_cast<{{solver}}*>(this)->preProcessRiemannSolverInputs(
          lQhbnd     + faceIndex*sizeLQhi/(Order+1),
          lGradQhbnd + faceIndex*sizeGradQ/(Order+1),
          lFhbnd     + faceIndex*sizeLFhi/(Order+1),
          direction,faceIndex);
    }
  }
{% endif %}

{% endif %}
{%if tempVarsOnStack==False %}
  delete[] block;
{% endif %}
{% if enableProfiler %}
  _profiler->stop("fusedSpaceTimePredictorVolumeIntegral");
{% endif %}
  return picardIterations;
}

void {{project}}::{{abstractSolver}}::addUpdateToSolution(double* const luh,const double* const luhOld,const double* const lduh,const double dt) {
{% if enableProfiler %}
  _profiler->start("solutionUpdate");
{% endif %}
  kernels::aderdg::generic::{{language}}::solutionUpdate<{{solver}}>(*static_cast<{{solver}}*>(this),luh,luhOld,lduh,dt);
{% if enableProfiler %}
  _profiler->stop("solutionUpdate");
{% endif %}
}

void {{project}}::{{abstractSolver}}::faceIntegral(double* const out/*may be solution or update vector*/,double* const lFhbnd,const int direction, const int orientation,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex,const int levelDelta,const tarch::la::Vector<DIMENSIONS, double>& cellSize,const double dt,const bool addToUpdate) {
{% if enableProfiler %}
  _profiler->start("faceIntegral");
{% endif %}
{% if dimensions==3 %}
  constexpr int basisSize2 = (Order+1)*(Order+1);
{% else %}    
  constexpr int basisSize2 = (Order+1);
{% endif %}
  constexpr int basisSize3 = basisSize2*(Order+1);
  constexpr int sizeUpdate = NumberOfVariables*basisSize3;

{% if transformRiemannData %}
  // post-processing done here as face integral is done cell-wisely
  const int fineGridFaceIndex = 2*direction + orientation;
  static_cast<{{solver}}*>(this)->postProcessRiemannSolution(lFhbnd,direction,fineGridFaceIndex);
{% endif %}
  
  if ( levelDelta > 0 ) {
    constexpr int sizeFlux = NumberOfVariables*basisSize2;
    double lFhbndCoarse[sizeFlux];
    kernels::aderdg::generic::{{language}}::faceUnknownsRestriction<{{solver}},NumberOfVariables,Order+1>(lFhbndCoarse,lFhbnd,subfaceIndex,levelDelta);
    tarch::la::Vector<DIMENSIONS,double> coarseGridCellSize = tarch::la::aPowI(levelDelta,3) * 1.0 * cellSize;
    
    kernels::aderdg::generic::{{language}}::faceIntegral{{linearOrNonlinear}}<{{solver}},NumberOfVariables,Order+1>(out,lFhbndCoarse,direction,orientation,coarseGridCellSize);
  } else {
    if ( addToUpdate ) {
      kernels::aderdg::generic::{{language}}::faceIntegral{{linearOrNonlinear}}<{{solver}},NumberOfVariables,Order+1>(out,lFhbnd,direction,orientation,cellSize);
    } else { // solution is only available in real cells, i.e. only here we can directly add the face integral result to the solution
      double lduh[sizeUpdate] = {0.0};                   // initialise with zeros
      kernels::aderdg::generic::{{language}}::faceIntegral{{linearOrNonlinear}}<{{solver}},NumberOfVariables,Order+1>(lduh,lFhbnd,direction,orientation,cellSize);
      addUpdateToSolution(out,out,lduh,dt);
    }
  }
  
{% if enableProfiler %}
  _profiler->stop("faceIntegral");
{% endif %}
}

void {{project}}::{{abstractSolver}}::riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double t,const double dt, const tarch::la::Vector<DIMENSIONS, double>& cellSize, const int direction, bool isBoundaryFace, int faceIndex) {
  assertion2(direction>=0,dt,direction);
  assertion2(direction<DIMENSIONS,dt,direction);
{% if enableProfiler %}
  _profiler->start("riemannSolver");
{% endif %}
{% if isFortran %}
  kernels::aderdg::generic::fortran::riemannSolver{{linearOrNonlinear}}<{{solver}}>(*static_cast<{{solver}}*>(this),FL,FR,QL,QR,t,dt,direction);
{% else %}
  {% if isLinear %}
    kernels::aderdg::generic::c::riemannSolverLinear<{{useFlux_s}},{{useNCP_s}},{{useMaterialParameters_s}},{{solver}}>(*static_cast<{{solver}}*>(this),FL,FR,QL,QR,t,dt,direction);
  {% else %}
kernels::aderdg::generic::c::riemannSolverNonlinear<{{useNCP_s}},{{useViscousFlux_s}},{{solver}}>(*static_cast<{{solver}}*>(this),FL,FR,QL,QR,t,dt,cellSize,direction);
  {% endif %}
{% endif %}
{% if enableProfiler %}
  _profiler->stop("riemannSolver");
{% endif %}
}

void {{project}}::{{abstractSolver}}::boundaryConditions(double* const fluxIn,const double* const stateIn,const double* const gradStateIn, const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int direction,const int orientation) {
{% if enableProfiler %}
  _profiler->start("boundaryConditions");
{% endif %}
{% if dimensions==3 %}
  constexpr int basisSize     = (Order+1)*(Order+1);
{% else %}
  constexpr int basisSize     = (Order+1);
{% endif %}
  constexpr int sizeStateOut = (NumberOfVariables+NumberOfParameters)*basisSize;
  constexpr int sizeFluxOut  = NumberOfVariables*basisSize;
  
  constexpr int totalSize = sizeStateOut + sizeFluxOut;
{% if tempVarsOnStack %}
  double block[totalSize];
{% else %}  
  double* block = new double[totalSize];
{% endif %}
  double* memory = block;

  double* stateOut = memory; memory+=sizeStateOut;
  double* fluxOut  = memory; memory+=sizeFluxOut;

  const int faceIndex = 2*direction+orientation;
    kernels::aderdg::generic::c::boundaryConditions<{{useViscousFlux_s}},{{solver}}>(*static_cast<{{solver}}*>(this),fluxOut,stateOut,fluxIn,stateIn,gradStateIn,cellCentre,cellSize,t,dt,faceIndex,direction);
  if ( orientation==0 ) {
    double* FL = fluxOut; const double* const QL = stateOut;
    double* FR = fluxIn;  const double* const QR = stateIn;
  
    riemannSolver(FL,FR,QL,QR,t,dt,cellSize,direction,true,faceIndex);
  }
  else {
    double* FL = fluxIn;  const double* const QL = stateIn;
    double* FR = fluxOut; const double* const QR = stateOut;

    riemannSolver(FL,FR,QL,QR,t,dt,cellSize,direction,true,faceIndex);
  }
{%if tempVarsOnStack==False %}
  delete[] block;
{% endif %}
{% if enableProfiler %}
  _profiler->stop("boundaryConditions");
{% endif %}
}

double {{project}}::{{abstractSolver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
{% if enableProfiler %}
  _profiler->start("stableTimeStepSize");
{% endif %}
  double d = kernels::aderdg::generic::{{language}}::stableTimeStepSize<{{solver}},{{useViscousFlux_s}}>(*static_cast<{{solver}}*>(this),luh,cellSize);
{% if enableProfiler %}
  _profiler->stop("stableTimeStepSize");
{% endif %}
  return d;
}
{%if patchwiseAdjust==False %}
void {{project}}::{{abstractSolver}}::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,double dt) {
{% if enableProfiler %}
  _profiler->start("solutionAdjustment");
{% endif %}
  kernels::aderdg::generic::{{language}}::solutionAdjustment<{{solver}}>(*static_cast<{{solver}}*>(this),luh,cellCentre,cellSize,t,dt);
{% if enableProfiler %}
  _profiler->stop("solutionAdjustment");
{% endif %}
}
{% endif %}

void {{project}}::{{abstractSolver}}::faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{% if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
{% endif %}
  kernels::aderdg::generic::c::faceUnknownsProlongation<{{solver}},NumberOfVariables,NumberOfParameters,Order+1>(lQhbndFine,lFhbndFine,lQhbndCoarse,lFhbndCoarse,coarseGridLevel,fineGridLevel,subfaceIndex);
{% if enableProfiler %}
  _profiler->start("false");
{% endif %}
}

void {{project}}::{{abstractSolver}}::volumeUnknownsProlongation(double* const luhFine,const double* const luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{% if enableProfiler %}
  _profiler->start("volumeUnknownsProlongation");
{% endif %}
  kernels::aderdg::generic::c::volumeUnknownsProlongation<{{solver}},NumberOfVariables,NumberOfParameters,Order+1>(luhFine,luhCoarse,coarseGridLevel,fineGridLevel,subcellIndex);
{% if enableProfiler %}
  _profiler->stop("volumeUnknownsProlongation");
{% endif %}
}

void {{project}}::{{abstractSolver}}::volumeUnknownsRestriction(double* const luhCoarse,const double* const luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{% if enableProfiler %}
  _profiler->start("volumeUnknownsRestriction");
{% endif %}
  kernels::aderdg::generic::c::volumeUnknownsRestriction<{{solver}},NumberOfVariables,NumberOfParameters,Order+1>(luhCoarse,luhFine,coarseGridLevel,fineGridLevel,subcellIndex);
{% if enableProfiler %}
  _profiler->stop("volumeUnknownsRestriction");
{% endif %}
}

//--------

{% if numberOfGlobalObservables > 0 %}
{{project}}::{{abstractSolver}}::ReadOnlyGlobalObservables {{project}}::{{abstractSolver}}::getGlobalObservables() const {
  return ReadOnlyGlobalObservables(_globalObservables.data());
}
{% endif %}

void {{project}}::{{abstractSolver}}::resetGlobalObservables(double* const globalObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables wrappedGlobalObservables(globalObservables);
  static_cast<{{solver}}*>(this)->resetGlobalObservables(wrappedGlobalObservables);
{% endif %}
}

void {{project}}::{{abstractSolver}}::updateGlobalObservables(
    double* const                               globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize,
    const double t,
    const double dt) {
{% if numberOfGlobalObservables > 0 %}
  double mappedObservables[NumberOfGlobalObservables];
  GlobalObservables wrappedMappedObservables(mappedObservables);
  static_cast<{{solver}}*>(this)->resetGlobalObservables(wrappedMappedObservables);
  static_cast<{{solver}}*>(this)->mapGlobalObservables(wrappedMappedObservables,luh,cellCentre,cellSize,t,dt);
  // reduce
  GlobalObservables         wrappedGlobalObservables(globalObservables);
  ReadOnlyGlobalObservables wrappedOtherObservables(mappedObservables);
  tarch::multicore::Lock lock(_reductionSemaphore);
  static_cast<{{solver}}*>(this)->mergeGlobalObservables(wrappedGlobalObservables,wrappedOtherObservables);
  lock.free();
{% endif %}
}

void {{project}}::{{abstractSolver}}::mergeGlobalObservables(double* const globalObservables,const double* const otherObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables         wrappedGlobalObservables(globalObservables);
  ReadOnlyGlobalObservables wrappedOtherObservables(otherObservables);
  static_cast<{{solver}}*>(this)->mergeGlobalObservables(wrappedGlobalObservables,wrappedOtherObservables);
{% endif %}
}

void {{project}}::{{abstractSolver}}::wrapUpGlobalObservables(double* const globalObservables) {
{% if numberOfGlobalObservables > 0 %}
  GlobalObservables wrappedGlobalObservables(globalObservables);
  static_cast<{{solver}}*>(this)->wrapUpGlobalObservables(wrappedGlobalObservables);
{% endif %}
}

//--------

void {{project}}::{{abstractSolver}}::flux(const double* const Q,double** const F) {
      abortWithMsg("flux: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::viscousFlux(const double* const Q,const double* const gradQ, double** const F) {
      abortWithMsg("viscous flux: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::viscousEigenvalues(const double* const Q,const int direction,double* const lambda) {
      abortWithMsg("viscous eigenvalues: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::algebraicSource(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, double *S) {
      abortWithMsg("algebraicSource: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

{% if isLinear %}
    void {{project}}::{{abstractSolver}}::nonConservativeProduct(const double* const Q,const double* const * const gradQ,double** const BgradQ) {
{% else %}
    void {{project}}::{{abstractSolver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
{% endif %}
      abortWithMsg("nonConservativeProduct: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::multiplyMaterialParameterMatrix(const double* const Q, double** const rhs) {
      abortWithMsg("multiplyMaterialParameterMatrix: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector,int n) {
      abortWithMsg("pointSource: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::resetGlobalObservables(GlobalObservables& globalObservables) const {
  abortWithMsg("If this operation is entered (resetGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::mapGlobalObservables(
    GlobalObservables&                          globalObservables,
    const double* const                         luh,
    const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
    const tarch::la::Vector<DIMENSIONS,double>& cellSize,
    const double t,
    const double dt) const {
  abortWithMsg("If this operation is entered (mapGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::mergeGlobalObservables(
    GlobalObservables&         globalObservables,
    ReadOnlyGlobalObservables& otherObservables) const {
  abortWithMsg("If this operation is entered (mergeGlobalObservables), you have specified global observables. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::wrapUpGlobalObservables(GlobalObservables& globalObservables) const {
  // Please re-implement if required.
}

{% if transformRiemannData %}
void {{project}}::{{abstractSolver}}::preProcessRiemannSolverInputs(double* const lQhbnd,double* const lGradQhbnd,double* const lFhbnd,const int direction,const int faceIndex) const {
  abortWithMsg("If this operation is entered (preProcessRiemannSolverInputs), you have specified Riemann solver input and output transformations. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::postProcessRiemannSolution(double* const lFhbnd,const int direction,const int fineGridFaceIndex) const {
  abortWithMsg("If this operation is entered (postProcessRiemannSolution), you have specified Riemann solver input and output transformations. Then you have to re-implement this routine, too." );
}
{% endif %}

/**
 * Fallback implementations of joined functions. Users can either safely ignore this
 * or overwrite with their own implementations.
 **/
#include "kernels/fusedMethods.cpph"
