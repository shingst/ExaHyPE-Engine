#ifndef __{{abstractSolver}}_CLASS_HEADER__
#define __{{abstractSolver}}_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <ostream>
#include <algorithm>
{% if countFlops %}
#include <atomic>
#include <iostream>
{% endif %}

#include "exahype/solvers/ADERDGSolver.h"
#include "exahype/solvers/UserSolverInterface.h"
{% if enableProfiler %}
#include "exahype/profilers/Profiler.h"
{% endif %}
#include "{{optKernelPath}}/Kernels.h"

/**
 * We include Peano's assertion collection here.
 */
#include "tarch/Assertions.h"
#include "tarch/la/Vector.h"

namespace {{project}}{
  class {{solver}};
  class {{abstractSolver}};
}

class {{project}}::{{abstractSolver}}: public exahype::solvers::ADERDGSolver, public exahype::solvers::UserADERDGSolverInterface {
  public:
    static constexpr int NumberOfVariables         = {{optNamespace}}::getNumberOfVariable();
    static constexpr int NumberOfParameters        = {{optNamespace}}::getNumberOfParameter();
    static constexpr int Order                     = {{optNamespace}}::getBasisSize() -1;
    static constexpr int Dimensions                = {{optNamespace}}::getDimension();

    static constexpr int NumberOfGlobalObservables = {{numberOfGlobalObservables}};
    static constexpr int NumberOfDMPObservables    = {{numberOfDMPObservables}}; // only of interest if this ADERDGSolver is a component of a LimitingADERDSolver 
    static constexpr int MaxPicardIterations       = {{maxPicardIterations}};
    static constexpr bool UseMaxPicardIterations   = {{"true" if useMaxPicardIterations else "false"}};
    static constexpr double CFL                    = 0.9;
    {% if usePointSources %}
    static constexpr int NumberOfPointSources      = {{numberOfPointSources}};
    double pointSourceLocation[NumberOfPointSources][DIMENSIONS];
    {% endif %}
    
    // virtual getters for the constexpr's
    int constexpr_getNumberOfVariables()  const override { return NumberOfVariables; };
    int constexpr_getNumberOfParameters() const override { return NumberOfParameters; };
    int constexpr_getOrder()              const override { return Order; };
    double constexpr_getCFLNumber()       const override { return CFL; };
  
    class VariableMetrics;
    class Variables;
    class ReadOnlyVariables;
    class Fluxes;
    class VariableShortcuts;
    class VariableMultiplicities;
    class VariableNames;
    {% for className in namingSchemes %}
    class {{className}};
    {% endfor %}
    
    {{abstractSolver}}(
      const double maximumMeshSize,
      const int maximumMeshDepth,
      const int haloCells,
      const int regularisedFineGridLevels,
      const exahype::solvers::Solver::TimeStepping timeStepping,
      const int limiterHelperLayers,
      const int DMPObservables
      {% if enableProfiler %},std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}
    );
    
{% if countFlops %}
    // Change to the correct values
    static constexpr unsigned long fluxPDEFlops = 0;
    static constexpr unsigned long ncpPDEFlops = 0;
    static constexpr unsigned long sourcesPDEFlops = 0;
    static constexpr unsigned long matparamPDEFlops = 0;
    static constexpr unsigned long pointsourcesFlops = 0;
    static constexpr unsigned long eigenvaluesFlops = 0;
    static constexpr unsigned long boundaryValuesFlops = 0;

    static std::atomic_ulong total_flops;
    static std::atomic_ulong total_time;
    
    static std::atomic_ulong overhead_t;
    static std::atomic_ulong overhead_c;
    
    static std::atomic_ulong fusedSTPVI_f;
    static std::atomic_ulong fusedSTPVI_t;
    static std::atomic_ulong fusedSTPVI_c;
    static std::atomic_ulong fusedSTPVI_picard;
    
    static std::atomic_ulong surfaceIntegral_f;
    static std::atomic_ulong surfaceIntegral_t;
    static std::atomic_ulong surfaceIntegral_c;  
    
    static std::atomic_ulong faceIntegral_f;
    static std::atomic_ulong faceIntegral_t;
    static std::atomic_ulong faceIntegral_c;
    
    static std::atomic_ulong solutionUpdate_f;
    static std::atomic_ulong solutionUpdate_t;
    static std::atomic_ulong solutionUpdate_c;
    
    static std::atomic_ulong riemannSolver_f;
    static std::atomic_ulong riemannSolver_t;
    static std::atomic_ulong riemannSolver_c;
    
    static std::atomic_ulong boundaryConditions_f;
    static std::atomic_ulong boundaryConditions_t;
    static std::atomic_ulong boundaryConditions_c;

    static std::atomic_ulong stableTimeStepSize_f;
    static std::atomic_ulong stableTimeStepSize_t;
    static std::atomic_ulong stableTimeStepSize_c;

    static std::atomic_ulong adjustSolution_f;
    static std::atomic_ulong adjustSolution_t;
    static std::atomic_ulong adjustSolution_c;

    static std::atomic_ulong faceUnknownsProlongation_f;
    static std::atomic_ulong faceUnknownsProlongation_t;
    static std::atomic_ulong faceUnknownsProlongation_c;

    static std::atomic_ulong faceUnknownsRestriction_f;
    static std::atomic_ulong faceUnknownsRestriction_t;
    static std::atomic_ulong faceUnknownsRestriction_c;

    static std::atomic_ulong volumeUnknownsProlongation_f;
    static std::atomic_ulong volumeUnknownsProlongation_t;
    static std::atomic_ulong volumeUnknownsProlongation_c;

    static std::atomic_ulong volumeUnknownsRestriction_f;
    static std::atomic_ulong volumeUnknownsRestriction_t;
    static std::atomic_ulong volumeUnknownsRestriction_c;

    virtual ~{{abstractSolver}}(){
      std::cout << "Performances, {{abstractSolver}}" << std::endl << "------------------------------------" << std::endl << std::endl;
      
      std::cout << "Overhead: " << ((double)overhead_t.load()) / 1000000000.0 << std::endl << "overhead calls: " << overhead_c.load()  << std::endl << std::endl;
      
      std::cout << "Total flops: " << total_flops.load() << std::endl << "Total time: " << ((double)total_time.load()) / 1000000000.0 << std::endl << "Total GFlops: " <<  ((double) total_flops.load()) / ((double) total_time.load()) << std::endl << std::endl;
      
      std::cout << "fusedSTPVI flops: " << fusedSTPVI_f.load() << std::endl << "fusedSTPVI time: " << ((double)fusedSTPVI_t.load()) / 1000000000.0 << std::endl << "fusedSTPVI GFlops: " <<  ((double) fusedSTPVI_f.load()) / ((double) fusedSTPVI_t.load()) << std::endl << "fusedSTPVI calls: " << fusedSTPVI_c.load() << std::endl << "Total picard iterations:" << fusedSTPVI_picard.load() << std::endl << std::endl;
      
      //std::cout << "surfaceIntegral flops: " << surfaceIntegral_f.load() << std::endl << "surfaceIntegral time: " << ((double)surfaceIntegral_t.load()) / 1000000000.0 << std::endl << "surfaceIntegral GFlops: " <<  ((double) surfaceIntegral_f.load()) / ((double) surfaceIntegral_t.load()) << std::endl << "surfaceIntegral calls: " << surfaceIntegral_c.load() << std::endl << std::endl;

      std::cout << "faceIntegral flops: " << faceIntegral_f.load() << std::endl << "faceIntegral time: " << ((double)faceIntegral_t.load()) / 1000000000.0 << std::endl << "faceIntegral GFlops: " <<  ((double) faceIntegral_f.load()) / ((double) faceIntegral_t.load()) << std::endl << "faceIntegral calls: " << faceIntegral_c.load() << std::endl << std::endl;
      
      std::cout << "solutionUpdate flops: " << solutionUpdate_f.load() << std::endl << "solutionUpdate time: " << ((double)solutionUpdate_t.load()) / 1000000000.0 << std::endl << "solutionUpdate GFlops: " <<  ((double) solutionUpdate_f.load()) / ((double) solutionUpdate_t.load()) << std::endl << "solutionUpdate calls: " << solutionUpdate_c.load() << std::endl << std::endl;
      
      std::cout << "riemannSolver flops: " << riemannSolver_f.load() << std::endl << "riemannSolver time: " << ((double)riemannSolver_t.load()) / 1000000000.0 << std::endl << "riemannSolver GFlops: " <<  ((double) riemannSolver_f.load()) / ((double) riemannSolver_t.load()) << std::endl << "riemannSolver calls: " << riemannSolver_c.load() << std::endl << std::endl;
      
      std::cout << "boundaryConditions flops: " << boundaryConditions_f.load() << std::endl << "boundaryConditions time: " << ((double)boundaryConditions_t.load()) / 1000000000.0 << std::endl << "boundaryConditions GFlops: " <<  ((double) boundaryConditions_f.load()) / ((double) boundaryConditions_t.load()) << std::endl << "boundaryConditions calls: " << boundaryConditions_c.load() << std::endl << std::endl;
      
      std::cout << "stableTimeStepSize flops: " << stableTimeStepSize_f.load() << std::endl << "stableTimeStepSize time: " << ((double)stableTimeStepSize_t.load()) / 1000000000.0 << std::endl << "stableTimeStepSize GFlops: " <<  ((double) stableTimeStepSize_f.load()) / ((double) stableTimeStepSize_t.load()) << std::endl << "stableTimeStepSize calls: " << stableTimeStepSize_c.load() << std::endl << std::endl;
      
      std::cout << "adjustSolution flops: " << adjustSolution_f.load() << std::endl << "adjustSolution time: " << ((double)adjustSolution_t.load()) / 1000000000.0 << std::endl << "adjustSolution GFlops: " <<  ((double) adjustSolution_f.load()) / ((double) adjustSolution_t.load()) << std::endl << "adjustSolution calls: " << adjustSolution_c.load() << std::endl << std::endl;
      
      std::cout << "faceUnknownsProlongation flops: " << faceUnknownsProlongation_f.load() << std::endl << "faceUnknownsProlongation time: " << ((double)faceUnknownsProlongation_t.load()) / 1000000000.0 << std::endl << "faceUnknownsProlongation GFlops: " <<  ((double) faceUnknownsProlongation_f.load()) / ((double) faceUnknownsProlongation_t.load()) << std::endl << "faceUnknownsProlongation calls: " << faceUnknownsProlongation_c.load() << std::endl << std::endl;
      
      std::cout << "faceUnknownsRestriction flops: " << faceUnknownsRestriction_f.load() << std::endl << "faceUnknownsRestriction time: " << ((double)faceUnknownsRestriction_t.load()) / 1000000000.0 << std::endl << "faceUnknownsRestriction GFlops: " <<  ((double) faceUnknownsRestriction_f.load()) / ((double) faceUnknownsRestriction_t.load()) << std::endl << "faceUnknownsRestriction calls: " << faceUnknownsRestriction_c.load() << std::endl << std::endl;
      
      std::cout << "volumeUnknownsProlongation flops: " << volumeUnknownsProlongation_f.load() << std::endl << "volumeUnknownsProlongation time: " << ((double)volumeUnknownsProlongation_t.load()) / 1000000000.0 << std::endl << "volumeUnknownsProlongation GFlops: " <<  ((double) volumeUnknownsProlongation_f.load()) / ((double) volumeUnknownsProlongation_t.load()) << std::endl << "volumeUnknownsProlongation calls: " << volumeUnknownsProlongation_c.load() << std::endl << std::endl;
      
      std::cout << "volumeUnknownsRestriction flops: " << volumeUnknownsRestriction_f.load() << std::endl << "volumeUnknownsRestriction time: " << ((double)volumeUnknownsRestriction_t.load()) / 1000000000.0 << std::endl << "volumeUnknownsRestriction GFlops: " <<  ((double) volumeUnknownsRestriction_f.load()) / ((double) volumeUnknownsRestriction_t.load()) << std::endl << "volumeUnknownsRestriction calls: " << volumeUnknownsRestriction_c.load() << std::endl << std::endl;
    }
{% endif %}

    /**
     * This operation should be overwritten in your application-specific 
     * solver. Alternatively, make your own subclass useConservativeFlux()
     * return false.
     */
    void flux(const double* const Q,double** F) override;
    
    /**
     * This operation should be overwritten in your application-specific 
     * solver. Alternatively, make your own subclass useConservativeFlux()
     * return false.
     */
    void viscousFlux(const double* const Q,const double* const gradQ,double** F) override;
    
    /**
     * This operation should be overwritten in your application-specific 
     * solver. Alternatively, make your own subclass useConservativeFlux()
     * return false.
     */
    void viscousEigenvalues(const double* const Q,const int d,double* lambda) override;
    
    /**
     * Default implementation. Has to be be overwritten by user's solver if you 
     * make the corresponding use operation activate the feature.
     *
     * See superclass for function's semantics.
     */
    void algebraicSource(const double* const Q,double* S) override;
    
    /**
     * Default implementation. Has to be be overwritten by user's solver if you 
     * make the corresponding use operation activate the feature.
     *
     * See superclass for function's semantics.
     */
    void nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) override;
        
    /**
     * Default implementation. Has to be be overwritten by user's solver if you 
     * make the corresponding use operation activate the feature.
     *
     * See superclass for function's semantics.
     */
    void pointSource(const double* const Q,const double* const x,const double t,const double dt, double* forceVector,int n) override;

    /**
     * Default implementation. Please overwrite.
     *
     * See superclass for function's semantics.
     */
    bool isPhysicallyAdmissible(
      const double* const solution,
      const double* const observablesMin,const double* const observablesMax,
      const bool wasTroubledInPreviousTimeStep,
      const tarch::la::Vector<DIMENSIONS,double>& center,
      const tarch::la::Vector<DIMENSIONS,double>& dx,
      const double t, const double dt) const override { return true; }

    /**
     * Default implementation. Please overwrite.
     *
	 * See superclass for function's semantics.
	 */
    void mapDiscreteMaximumPrincipleObservables(double* observables,const int numberOfObservables,const double* const Q) const override {
      if (numberOfObservables>0) {
      	std::copy_n(Q,numberOfObservables,observables);
      }
  	}
    
    // old: void fusedSpaceTimePredictorVolumeIntegral(double* lduh, double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt, double** tempPointForceSources) override; 
    int fusedSpaceTimePredictorVolumeIntegral(double* lduh, double* lQhbnd, double* lFhbnd, const double* const luh, const tarch::la::Vector<DIMENSIONS, double>& center, const tarch::la::Vector<DIMENSIONS, double>& dx, const double t, const double dt) override; 
    void solutionUpdate(double* luh,const double* const lduh,const double dt) override;
    void surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& dx); //override; //TODO JMG make override again when enabled back
    void faceIntegral(double* const lduh, const double* const lFhbnd, const int direction, const int orientation,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex, const int levelDelta, const tarch::la::Vector<DIMENSIONS, double>& cellSize) override;    
    void riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,const double dt,const int normalNonZeroIndex, bool isBoundaryFace, int faceIndex) override;
    // old: void boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) override;
    // old: void boundaryConditions(double* fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int direction) override;
    void boundaryConditions(double* const fluxIn,const double* const stateIn,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int direction,const int orientation) override;
    double stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    {% if patchwiseAdjust %}
    // adjustSolution is implemented by the user solver as patchwise adjust option was used 
    {% else %}
    void adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) override; 
    {% endif %}
    void faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) override;
    //old: void faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) override;
    void volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) override;
    void volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) override;

    static void constantsToString(std::ostream& os);
    static void abortWithMsg(const char* const msg);
    
    //padded array size, override default ADERDGSolver values
    int getTempSpaceTimeUnknownsSize()      const {return {{optNamespace}}::getlQiSize();          }
    int getTempSpaceTimeFluxUnknowns0Size() const {return {{optNamespace}}::getlFiSize();          }
    int getTempSpaceTimeFluxUnknowns1Size() const {return {{optNamespace}}::getgradQSize();        }
    int getTempUnknownsSize()               const {return {{optNamespace}}::getlQhiSize();         }
    int getTempFluxUnknownsSize()           const {return {{optNamespace}}::getlFhiSize();         }
    int getTempPointForceSourcesSize()      const {return {{optNamespace}}::getPSiSize();          }
    int getBndFaceSize()                    const {return {{optNamespace}}::getBndFaceSize();      }
    int getBndTotalSize()                   const {return {{optNamespace}}::getBndFaceTotalSize(); }
    int getBndFluxSize()                    const {return {{optNamespace}}::getBndFluxSize();      }
    int getBndFluxTotalSize()               const {return {{optNamespace}}::getBndFluxTotalSize(); }
    int getUpdateSize()                     const {return {{optNamespace}}::getUpdateSize(); }
    
    bool alignTempArray()                  const {return true;}
    
    bool usePaddedData_nVar() const {return true;}
    bool usePaddedData_nDoF() const {return true;}
    
    //not used PDE
    {% if not useMaterialParameters %}
    void multiplyMaterialParameterMatrix(const double* const Q, double* rhs) final {}
    {% endif %}
    {% if patchwiseAdjust %}
    void adjustPointSolution(const double* const x,const double t,const double dt,double* Q) final {};
    {% endif %}
    
    //helper function
    inline double* allocateArray(const int size) {return ((double *) _mm_malloc(sizeof(double)*size, ALIGNMENT));}
    inline void freeArray(double*& array) {_mm_free(array);}
      
};

#endif // __{{abstractSolver}}_CLASS_HEADER__
