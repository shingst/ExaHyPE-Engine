#ifndef __{{abstractSolver}}_CLASS_HEADER__
#define __{{abstractSolver}}_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <ostream>
#include <algorithm>
{% if countFlops %}
#include <atomic>
#include <iostream>
{% endif %}

#include "exahype/solvers/ADERDGSolver.h"
{% if enableProfiler %}
#include "exahype/profilers/Profiler.h"
{% endif %}
#include "{{optKernelPath}}/Kernels.h"

/**
 * We include Peano's assertion collection here.
 */
#include "tarch/Assertions.h"
#include "tarch/la/Vector.h"

#include "kernels/KernelUtils.h"

namespace {{project}}{
  class {{solver}};
  class {{abstractSolver}};
}

class {{project}}::{{abstractSolver}}: public exahype::solvers::ADERDGSolver {
public:
  static constexpr int NumberOfVariables         = {{optNamespace}}::getNumberOfVariable();
  static constexpr int NumberOfParameters        = {{optNamespace}}::getNumberOfParameter();
  static constexpr int Order                     = {{optNamespace}}::getBasisSize() -1;
  static constexpr int Dimensions                = {{optNamespace}}::getDimension();

  static constexpr int NumberOfGlobalObservables = {{numberOfGlobalObservables}};
  static constexpr int NumberOfDMPObservables    = {{numberOfDMPObservables}}; // only of interest if this ADERDGSolver is a component of a LimitingADERDSolver 
  static constexpr int MaxPicardIterations       = Order+1;
  static constexpr bool UseMaxPicardIterations   = {{"true" if useMaxPicardIterations else "false"}};
  static constexpr double CFL                    = {{CFL}};
  static constexpr double PNPM                   = {{PNPM}};
  
  // [order][node i]
  static kernels::UnivariateFunction** basisFunction;
  static kernels::UnivariateFunction** basisFunctionFirstDerivative;
  static kernels::UnivariateFunction** basisFunctionSecondDerivative;
  
  {% if usePointSources %}
  static constexpr int NumberOfPointSources      = {{numberOfPointSources}};
  double pointSourceLocation[NumberOfPointSources][DIMENSIONS];
  {% endif %}

  // virtual getters for the constexpr's ; TODO(Dominic): Who needs those callbacks?
  int constexpr_getNumberOfVariables()  const { return NumberOfVariables; };
  int constexpr_getNumberOfParameters() const { return NumberOfParameters; };
  int constexpr_getOrder()              const { return Order; };
  double constexpr_getCFLNumber()       const { return CFL; };

  bool isLinear() const override { return {{isLinear_s}}; }
  bool isUseViscousFlux() const override { return {{useViscousFlux_s}}; }

  // Access Objects
  class VariableMetrics;
  class Variables;
  class ReadOnlyVariables;
  class Fluxes;
  class VariableShortcuts;
  class VariableMultiplicities;
  class VariableNames;
  {% for className in namingSchemes %}
  class {{className}};
  {% endfor %}
  class GlobalObservables;
  class ReadOnlyGlobalObservables;

  {{abstractSolver}}(
      const double maximumMeshSize,
      const int maximumMeshDepth,
      const int haloCells,
      const int haloBufferCells,
      const int limiterBufferCells,
      const int regularisedFineGridLevels,
      const exahype::solvers::Solver::TimeStepping timeStepping,
      const int DMPObservables
      {% if enableProfiler %},std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}
  );

  {% if countFlops %}
  // Change to the correct values
  static constexpr unsigned long fluxPDEFlops = 0;
  static constexpr unsigned long ncpPDEFlops = 0;
  static constexpr unsigned long sourcesPDEFlops = 0;
  static constexpr unsigned long matparamPDEFlops = 0;
  static constexpr unsigned long pointsourcesFlops = 0;
  static constexpr unsigned long eigenvaluesFlops = 0;
  static constexpr unsigned long boundaryValuesFlops = 0;

  static std::atomic_ulong total_flops;
  static std::atomic_ulong total_time;

  static std::atomic_ulong overhead_t;
  static std::atomic_ulong overhead_c;

  static std::atomic_ulong fusedSTPVI_f;
  static std::atomic_ulong fusedSTPVI_t;
  static std::atomic_ulong fusedSTPVI_c;
  static std::atomic_ulong fusedSTPVI_picard;

  static std::atomic_ulong surfaceIntegral_f;
  static std::atomic_ulong surfaceIntegral_t;
  static std::atomic_ulong surfaceIntegral_c;  

  static std::atomic_ulong faceIntegral_f;
  static std::atomic_ulong faceIntegral_t;
  static std::atomic_ulong faceIntegral_c;

  static std::atomic_ulong solutionUpdate_f;
  static std::atomic_ulong solutionUpdate_t;
  static std::atomic_ulong solutionUpdate_c;

  static std::atomic_ulong riemannSolver_f;
  static std::atomic_ulong riemannSolver_t;
  static std::atomic_ulong riemannSolver_c;

  static std::atomic_ulong boundaryConditions_f;
  static std::atomic_ulong boundaryConditions_t;
  static std::atomic_ulong boundaryConditions_c;

  static std::atomic_ulong stableTimeStepSize_f;
  static std::atomic_ulong stableTimeStepSize_t;
  static std::atomic_ulong stableTimeStepSize_c;

  static std::atomic_ulong adjustSolution_f;
  static std::atomic_ulong adjustSolution_t;
  static std::atomic_ulong adjustSolution_c;

  static std::atomic_ulong faceUnknownsProlongation_f;
  static std::atomic_ulong faceUnknownsProlongation_t;
  static std::atomic_ulong faceUnknownsProlongation_c;

  static std::atomic_ulong faceUnknownsRestriction_f;
  static std::atomic_ulong faceUnknownsRestriction_t;
  static std::atomic_ulong faceUnknownsRestriction_c;

  static std::atomic_ulong volumeUnknownsProlongation_f;
  static std::atomic_ulong volumeUnknownsProlongation_t;
  static std::atomic_ulong volumeUnknownsProlongation_c;

  static std::atomic_ulong volumeUnknownsRestriction_f;
  static std::atomic_ulong volumeUnknownsRestriction_t;
  static std::atomic_ulong volumeUnknownsRestriction_c;

  virtual ~{{abstractSolver}}(){
    std::cout << "Performances, {{abstractSolver}}" << std::endl << "------------------------------------" << std::endl << std::endl;

    std::cout << "Overhead: " << ((double)overhead_t.load()) / 1000000000.0 << std::endl << "overhead calls: " << overhead_c.load()  << std::endl << std::endl;

    std::cout << "Total flops: " << total_flops.load() << std::endl << "Total time: " << ((double)total_time.load()) / 1000000000.0 << std::endl << "Total GFlops: " <<  ((double) total_flops.load()) / ((double) total_time.load()) << std::endl << std::endl;

    std::cout << "fusedSTPVI flops: " << fusedSTPVI_f.load() << std::endl << "fusedSTPVI time: " << ((double)fusedSTPVI_t.load()) / 1000000000.0 << std::endl << "fusedSTPVI GFlops: " <<  ((double) fusedSTPVI_f.load()) / ((double) fusedSTPVI_t.load()) << std::endl << "fusedSTPVI calls: " << fusedSTPVI_c.load() << std::endl << "Total picard iterations:" << fusedSTPVI_picard.load() << std::endl << std::endl;

    //std::cout << "surfaceIntegral flops: " << surfaceIntegral_f.load() << std::endl << "surfaceIntegral time: " << ((double)surfaceIntegral_t.load()) / 1000000000.0 << std::endl << "surfaceIntegral GFlops: " <<  ((double) surfaceIntegral_f.load()) / ((double) surfaceIntegral_t.load()) << std::endl << "surfaceIntegral calls: " << surfaceIntegral_c.load() << std::endl << std::endl;

    std::cout << "faceIntegral flops: " << faceIntegral_f.load() << std::endl << "faceIntegral time: " << ((double)faceIntegral_t.load()) / 1000000000.0 << std::endl << "faceIntegral GFlops: " <<  ((double) faceIntegral_f.load()) / ((double) faceIntegral_t.load()) << std::endl << "faceIntegral calls: " << faceIntegral_c.load() << std::endl << std::endl;

    std::cout << "solutionUpdate flops: " << solutionUpdate_f.load() << std::endl << "solutionUpdate time: " << ((double)solutionUpdate_t.load()) / 1000000000.0 << std::endl << "solutionUpdate GFlops: " <<  ((double) solutionUpdate_f.load()) / ((double) solutionUpdate_t.load()) << std::endl << "solutionUpdate calls: " << solutionUpdate_c.load() << std::endl << std::endl;

    std::cout << "riemannSolver flops: " << riemannSolver_f.load() << std::endl << "riemannSolver time: " << ((double)riemannSolver_t.load()) / 1000000000.0 << std::endl << "riemannSolver GFlops: " <<  ((double) riemannSolver_f.load()) / ((double) riemannSolver_t.load()) << std::endl << "riemannSolver calls: " << riemannSolver_c.load() << std::endl << std::endl;

    std::cout << "boundaryConditions flops: " << boundaryConditions_f.load() << std::endl << "boundaryConditions time: " << ((double)boundaryConditions_t.load()) / 1000000000.0 << std::endl << "boundaryConditions GFlops: " <<  ((double) boundaryConditions_f.load()) / ((double) boundaryConditions_t.load()) << std::endl << "boundaryConditions calls: " << boundaryConditions_c.load() << std::endl << std::endl;

    std::cout << "stableTimeStepSize flops: " << stableTimeStepSize_f.load() << std::endl << "stableTimeStepSize time: " << ((double)stableTimeStepSize_t.load()) / 1000000000.0 << std::endl << "stableTimeStepSize GFlops: " <<  ((double) stableTimeStepSize_f.load()) / ((double) stableTimeStepSize_t.load()) << std::endl << "stableTimeStepSize calls: " << stableTimeStepSize_c.load() << std::endl << std::endl;

    std::cout << "adjustSolution flops: " << adjustSolution_f.load() << std::endl << "adjustSolution time: " << ((double)adjustSolution_t.load()) / 1000000000.0 << std::endl << "adjustSolution GFlops: " <<  ((double) adjustSolution_f.load()) / ((double) adjustSolution_t.load()) << std::endl << "adjustSolution calls: " << adjustSolution_c.load() << std::endl << std::endl;

    std::cout << "faceUnknownsProlongation flops: " << faceUnknownsProlongation_f.load() << std::endl << "faceUnknownsProlongation time: " << ((double)faceUnknownsProlongation_t.load()) / 1000000000.0 << std::endl << "faceUnknownsProlongation GFlops: " <<  ((double) faceUnknownsProlongation_f.load()) / ((double) faceUnknownsProlongation_t.load()) << std::endl << "faceUnknownsProlongation calls: " << faceUnknownsProlongation_c.load() << std::endl << std::endl;

    std::cout << "faceUnknownsRestriction flops: " << faceUnknownsRestriction_f.load() << std::endl << "faceUnknownsRestriction time: " << ((double)faceUnknownsRestriction_t.load()) / 1000000000.0 << std::endl << "faceUnknownsRestriction GFlops: " <<  ((double) faceUnknownsRestriction_f.load()) / ((double) faceUnknownsRestriction_t.load()) << std::endl << "faceUnknownsRestriction calls: " << faceUnknownsRestriction_c.load() << std::endl << std::endl;

    std::cout << "volumeUnknownsProlongation flops: " << volumeUnknownsProlongation_f.load() << std::endl << "volumeUnknownsProlongation time: " << ((double)volumeUnknownsProlongation_t.load()) / 1000000000.0 << std::endl << "volumeUnknownsProlongation GFlops: " <<  ((double) volumeUnknownsProlongation_f.load()) / ((double) volumeUnknownsProlongation_t.load()) << std::endl << "volumeUnknownsProlongation calls: " << volumeUnknownsProlongation_c.load() << std::endl << std::endl;

    std::cout << "volumeUnknownsRestriction flops: " << volumeUnknownsRestriction_f.load() << std::endl << "volumeUnknownsRestriction time: " << ((double)volumeUnknownsRestriction_t.load()) / 1000000000.0 << std::endl << "volumeUnknownsRestriction GFlops: " <<  ((double) volumeUnknownsRestriction_f.load()) / ((double) volumeUnknownsRestriction_t.load()) << std::endl << "volumeUnknownsRestriction calls: " << volumeUnknownsRestriction_c.load() << std::endl << std::endl;
  }
  {% endif %}

  /**
   * Default implementation. Please overwrite.
   *
   * See superclass for function's semantics.
   */
  bool isPhysicallyAdmissible(
      const double* const                         solution,
      const double* const                         localDMPObservablesMin,
      const double* const                         localDMPObservablesMax,
      const bool                                  wasTroubledInPreviousTimeStep,
      const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS,double>& cellSize,
      const double                                timeStamp) const override { return true; }

  /**
   * Default implementation. Please overwrite.
   *
   * See superclass for function's semantics.
   */
  bool vetoDiscreteMaximumPrincipleDecision(
      const double* const                         solution,
      const double* const                         localDMPObservablesMin,
      const double* const                         localDMPObservablesMax,
      const bool                                  wasTroubledInPreviousTimeStep,
      const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS,double>& cellSize,
      const double                                timeStamp) const override { return false; /* do not veto DMP*/ } 

  /**
   * Default implementation. Please overwrite.
   *
   * See superclass for function's semantics.
   */
  void mapDiscreteMaximumPrincipleObservables(double* const observables, const double* const Q) const override {
    if (NumberOfDMPObservables>0) {
      std::copy_n(Q,NumberOfDMPObservables,observables);
    }
  }

  /**
   * Default implementation. Please overwrite.
   *
   * See superclass for function's semantics.
   */
  double getDiscreteMaximumPrincipleRelaxationParameter(
      const double& specifiedRelaxationParameter,
      const int&    observable,
      const double& localMin,
      const double& localMax,
      const double& boundaryMinPerObservable,
      const double& previousMax) const override {
    return specifiedRelaxationParameter;
  }

  /**
   * Default implementation. Please overwrite.
   *
   * See superclass exahype::solvers::Solver for function's semantics.
   */
  int getGeometricLoadBalancingWeight(
      const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS,double>& cellSize) override {
    return 1;
  }

  int fusedSpaceTimePredictorVolumeIntegral(double* const lduh,double* const lQhbnd, double* lGradQhbnd, double* const lFhbnd,double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const bool addVolumeIntegralResultToUpdate) override;
  void addUpdateToSolution(double* const luh,const double* const luhOld,const double* const lduh,const double dt) override;
  void surfaceIntegral(double* const lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& cellSize); //override; //TODO JMG make override again when enabled back
  void faceIntegral(double* const out,double* const lFhbnd,const int direction, const int orientation,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex,const int levelDelta,const tarch::la::Vector<DIMENSIONS, double>& cellSize,const double dt,const bool addToUpdate) override;    
  void riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double t,const double dt, const tarch::la::Vector<DIMENSIONS, double>& cellSize,const int direction, bool isBoundaryFace, int faceIndex) override;
  // old: void boundaryConditions(double* const fluxOut,double* const stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int direction) override;
  // old: void boundaryConditions(double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int direction) override;
  void boundaryConditions(double* const fluxIn,const double* const stateIn,const double* const gradStateIn, const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int direction,const int orientation) override;
  double stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellSize) override;
  {% if patchwiseAdjust %}
  // adjustSolution is implemented by the user solver as patchwise adjust option was used 
  {% else %}
  void adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt) override; 
  {% endif %}
  void faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) override;
  //old: void faceUnknownsRestriction(double* const lQhbndCoarse,double* const lFhbndCoarse,const double* const lQhbndFine,const double* const lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) override;
  void volumeUnknownsProlongation(double* const luhFine,const double* const luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) override;
  void volumeUnknownsRestriction(double* const luhCoarse,const double* const luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) override;
  {% if numberOfGlobalObservables > 0 %}
  /**
   * @return the global observables computed in the last time step.
   */
  ReadOnlyGlobalObservables getGlobalObservables() const;
  {% endif %}
  void resetGlobalObservables(double* const globalObservables) final override;
  void updateGlobalObservables(
      double* const                               globalObservables,
      const double* const                         luh,
      const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS,double>& cellSize,
      const double t,
      const double dt) final override;
  void mergeGlobalObservables(double* const globalObservables,const double* const otherObservables) final override;
  void wrapUpGlobalObservables(double* const globalObservables) final override;

  static void constantsToString(std::ostream& os);
  static void abortWithMsg(const char* const msg);

  //padded array size, override default ADERDGSolver values
  int getTempSpaceTimeUnknownsSize()      const {return {{optNamespace}}::getlQiSize();          }
  int getTempSpaceTimeFluxUnknowns0Size() const {return {{optNamespace}}::getlFiSize();          }
  int getTempSpaceTimeFluxUnknowns1Size() const {return {{optNamespace}}::getgradQSize();        }
  int getTempUnknownsSize()               const {return {{optNamespace}}::getlQhiSize();         }
  int getTempFluxUnknownsSize()           const {return {{optNamespace}}::getlFhiSize();         }
  int getTempPointForceSourcesSize()      const {return {{optNamespace}}::getPSiSize();          }
  int getBndFaceSize()                    const {return {{optNamespace}}::getBndFaceSize();      }
  int getBndTotalSize()                   const {return {{optNamespace}}::getBndFaceTotalSize(); }
  int getBndGradQSize()                   const {return {{optNamespace}}::getBndGradQSize();     }
  int getBndFluxSize()                    const {return {{optNamespace}}::getBndFluxSize();      }
  int getBndFluxTotalSize()               const {return {{optNamespace}}::getBndFluxTotalSize(); }
  int getUpdateSize()                     const {return {{optNamespace}}::getUpdateSize(); }

  bool alignTempArray()                  const {return true;}

  bool usePaddedData_nVar() const {return true;}
  bool usePaddedData_nDoF() const {return true;}

  /**
   * @defgroup User PDE kernels
   */
  ///@{
  /**
   * Compute the eigenvalues of the flux tensor per coordinate direction \p d.
   *
   * \param[in] Q  the conserved variables associated with a quadrature node
   *               as C array (already allocated).
   * \param[in] d  the column of the flux vector (d=0,1,...,DIMENSIONS).
   * \param[inout] lambda the eigenvalues as C array (already allocated).
   */
  virtual void eigenvalues(const double* const Q,const int direction,double* const lambda) = 0;

  /**
   * Impose boundary conditions at a point on a boundary face
   * within the time interval [t,t+dt].
   *
   * \param[in]    x         the physical coordinate on the face.
   * \param[in]    t         the start of the time interval.
   * \param[in]    dt        the width of the time interval.
   * \param[in]    faceIndex indexing of the face (0 -- {x[0]=xmin}, 1 -- {x[1]=xmax}, 2 -- {x[1]=ymin}, 3 -- {x[2]=ymax}, and so on,
   *                         where xmin,xmax,ymin,ymax are the bounds of the cell containing point x.
   * \param[in]    d         the coordinate direction the face normal is pointing to.
   * \param[in]    QIn       the conserved variables at point x from inside of the domain
   *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
   * \param[in]    FIn       the normal fluxes at point x from inside of the domain
   *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
   * \param[inout] QOut      the conserved variables at point x from outside of the domain
   *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
   * \param[inout] FOut      the normal fluxes at point x from outside of the domain
   *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
   */
  virtual void boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int direction,const double * const fluxIn,const double* const stateIn,const double* const gradStateIn, double *fluxOut,double* stateOut) = 0;

  /**
   * Adjust the conserved variables and parameters (together: Q) at a given time t at the (quadrature) point x.
   *
   * \note Use this function and ::useAdjustSolution to set initial conditions.
   *
   * \param[in]    x         the physical coordinate on the face.
   * \param[in]    t         the start of the time interval.
   * \param[in]    dt        the width of the time interval.
   * \param[inout] Q         the conserved variables (and parameters) associated with a quadrature point
   *                         as C array (already allocated).
   */
  virtual void adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {}

  /**
   * @TODO LR : document
   */
  virtual void multiplyMaterialParameterMatrix(const double* const Q, double** const rhs);

  /**
   * Compute a pointSource contribution.
   * 
   * @TODO(Leo): Please document
   */
  virtual void pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector,int n);

  /**
   * Compute the Algebraic Sourceterms.
   * 
   * You may want to overwrite this with your PDE Source (algebraic RHS contributions).
   * However, in all schemes we have so far, the source-type contributions are
   * collected with non-conservative contributions into a fusedSource, see the
   * fusedSource method. From the kernels given with ExaHyPE, only the fusedSource
   * is called and there is a default implementation for the fusedSource calling
   * again seperately the nonConservativeProduct function and the algebraicSource
   * function.
   *
   * \param[in]    x         the physical coordinate
   * \param[in]    t         the start of the time interval.
   * \param[in]    Q the conserved variables (and parameters) associated with a quadrature point
   *                 as C array (already allocated).
   * \param[inout] S the source point as C array (already allocated).
   */
  virtual void algebraicSource(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, double *S);


  /**
   * Compute the nonconservative term $B(Q) \nabla Q$.
   * 
   * This function shall return a vector BgradQ which holds the result
   * of the full term. To do so, it gets the vector Q and the matrix
   * gradQ which holds the derivative of Q in each spatial direction.
   * Currently, the gradQ is a continous storage and users can use the
   * kernels::icellSize2 class in order to compute the positions inside gradQ.
   *
   * @TODO: Check if the following is still right:
   * 
   * !!! Warning: BgradQ is a vector of size NumberOfVariables if you
   * use the ADER-DG kernels for nonlinear PDEs. If you use
   * the kernels for linear PDEs, it is a tensor with dimensions
   * Dim x NumberOfVariables.
   * 
   * \param[in]   Q   the vector of unknowns at the given position
   * \param[in]   gradQ   the gradients of the vector of unknowns,
   *                  stored in a linearized array.
   * \param[inout]  The vector BgradQ (extends nVar), already allocated. 
   *
   */

  {% if isLinear %}
  virtual void nonConservativeProduct(const double* const Q,const double* const * const gradQ,double** const BgradQ);
  {% else %}
  virtual void nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ);
  {% endif %}

  /**
   * Compute the conserved flux.
   * 
   * \param[in]  Q the conserved variabels (and parameters) associated with a
   *               quadrature point as C array.
   * \param[inout] F a C array with shape [nDim][nVars]. That is, this is an C list
   *               holding pointers to actual lists. Thus, the storage may be noncontinous.
   *               In any case, the storage has already been allocated.
   */
  virtual void flux(const double* const Q,double** const F);

  /**
   * Compute the flux with diffusive component.
   * 
   * \param[in]  Q the conserved variabels (and parameters) associated with a
   *               quadrature point as C array.
   *             gradQ the gradient of the conserved variabels (and parameters) associated
   *                   with a quadrature point as C array.
   * \param[inout] F a C array with shape [nDim][nVars]. That is, this is an C list
   *               holding pointers to actual lists. Thus, the storage may be noncontinous.
   *               In any case, the storage has already been allocated.
   */
  virtual void viscousFlux(const double* const Q, const double* const gradQ, double** const F);
  virtual void viscousEigenvalues(const double* const Q,const int direction,double* const lambda);
  
  /**
   * Resets the vector of global observables to some suitable initial value, e.g.
   * the smallest possible double if one wants to compute the maximum.
   *
   *\param[inout] globalObservables The global observables that we want to reset.
   */
  virtual void resetGlobalObservables(GlobalObservables& globalObservables) const;

  /**
   * Computes observables from a cell's solution values.
   * The result will be merged with the global observables.
   *
   *\param[inout] globalObservables The mapped observables.
   *\param[in]    luh               The solution array.
   *\param[in]    cellSize          The size of a cell.
   */
  virtual void mapGlobalObservables(
      GlobalObservables&                          globalObservables,
      const double* const                         luh,
      const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS,double>& cellSize,
      const double t,
      const double dt) const;

  /**
   * This method merges two vectors of (global) observables.
   *
   * For example, if one wants to compute the maximum of global variable i,
   * one should set
   *
   * observables[i] = std::max( globalObservables[i], otherObservables[i])
   *
   * and so on.
   *
   *\param[inout] globalObservables  The (merged) observables.
   *\param[in]    otherObservables   other observables that we want to merge with the first argument.
   */
  virtual void mergeGlobalObservables(
      GlobalObservables&         globalObservables,
      ReadOnlyGlobalObservables& otherObservables) const;

  /**
   * Wrap up the global observables, e.g. finalise an L^2 integral
   * by applying a square root.
   *
   * @note This routine is only called on the global master, after
   * the reduction has completed.
   *
   *\param[inout] observables  The global observables.
   */
  virtual void wrapUpGlobalObservables(GlobalObservables& globalObservables) const;

  
  {% if transformRiemannData %}
  /**
   * Pre-process extrapolated predictor, gradient and volume flux degrees of freedom (DOFs)
   * for the face with index @p faceIndex before
   * they are piped into the Riemann solver.
   * 
   * This function is used to move physical-space-to-reference-space rotations
   * out of the face-wise Riemann solver and behind the space-time predictor.
   * 
   * @note All DoFs per face are passed to this function, not just pointwise values.   
   * 
   * @param[inout] lQbhnd     the predictor DOFs extrapolated to the face.
   * @param[inout] lGradQhbnd the DoF of the predictor's gradient extrapolated to the face.
   * @param[inout] lFhbnd     the volume flux DOFs extrapolated to the face.
   * @param[in]    direction  direction of the face
   * @param[in]    faceIndex  index of the face: 2*direction+orientation, where orientation is 1 if the normal vector of the face points
   *                          in positive direction. Otherwise, orientation is zero.
   */
  virtual void preProcessRiemannSolverInputs(double* const lQhbnd,double* const lGradQhbnd,double* const lFhbnd,const int direction,const int faceIndex) const;

  /**
   * Post-process the Riemann solution before performing the face integral,
   * which is part of the corrector step.
   * 
   * This function is used to move reference-space-to-physical-space rotations
   * out of the face-wise Riemann solver and before the face integral.
   * 
   * @note All DoFs per face are passed to this function, not just pointwise values.   
   * 
   * @param[inout] lFhbnd     the Riemann solution (in reference space_
   * @param[in]    direction  direction of the face
   * @param[in]    faceIndex  index of the face: 2*direction+orientation, where orientation is 1 if the normal vector of the face points
   *                          in positive direction. Otherwise, orientation is zero.
   */
  virtual void postProcessRiemannSolution(double* const lFhbnd,const int direction,const int fineGridFaceIndex) const;
  {% endif %}
  
  /**
   * Signals a user solver that ExaHyPE just started a new time step.
   *
   * @param[in] minTimeStamp the minimum time stamp (over all cells)
   *
   * @note This function is invoked before the first predictor computation
   * when the non fused time stepping is run. Otherwise, it is invoked after
   * the first predictor computation. It will always be called before
   * "adjustSolution" is invoked.
   *
   * @note [MPI] For convenient reductions consider to specify "global_observables" in
   * the specification file.
   * 
   * @param isFirstTimeStepOfBatchOrNoBatch  if this is the first time step of a batch or no batch is run.
   */
  virtual void beginTimeStep(const double minTimeStamp,const bool isFirstTimeStepOfBatchOrNoBatch) {}

  /**
   * Signals a user solver that ExaHyPE just finished a time step.
   *
   * @param[in] minTimeStamp the minimum time stamp (over all cells)
   *
   * @note This function is invoked after the solution was updated in all
   * cells.
   *
   * @note [MPI] For convenient reductions consider to specify "global_observables" in
   * the specification file. 
   *
   * @param isFirstTimeStepOfBatchOrNoBatch  if this is the first time step of a batch or no batch is run.
   * @param isLastTimeStepOfBatchOrNoBatch   if this is the last time step of a batch or if no batch is run.
   */
  virtual void endTimeStep(const double minTimeStamp,const bool isLastTimeStepOfBatchOrNoBatch)   {}
  ///@}

  //helper function
  inline double* allocateArray(const int size) {return ((double* ) _mm_malloc(sizeof(double)*size, ALIGNMENT));}
  inline void freeArray(double*& array) {_mm_free(array);}

};

#endif // __{{abstractSolver}}_CLASS_HEADER__
