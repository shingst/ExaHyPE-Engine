// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{solver}}.h"

#include "{{aderdgContext.optKernelPath}}/Kernels.h"

{% if aderdgContext.countFlops  %}
#include <chrono>
#include <ratio>
{% endif %}

{% if aderdgContext.countFlops  %}
std::atomic_ulong {{project}}::{{solver}}::total_flops = 0;
std::atomic_ulong {{project}}::{{solver}}::total_time = 0;

std::atomic_ulong {{project}}::{{solver}}::projectOnFVLimiterSpace_f = 0;
std::atomic_ulong {{project}}::{{solver}}::projectOnFVLimiterSpace_t = 0;
std::atomic_ulong {{project}}::{{solver}}::projectOnFVLimiterSpace_c = 0;
  
std::atomic_ulong {{project}}::{{solver}}::projectOnDGSpace_f = 0;
std::atomic_ulong {{project}}::{{solver}}::projectOnDGSpace_t = 0;
std::atomic_ulong {{project}}::{{solver}}::projectOnDGSpace_c = 0;
    
std::atomic_ulong {{project}}::{{solver}}::discreteMaximumPrincipleAndMinAndMaxSearch_f = 0;
std::atomic_ulong {{project}}::{{solver}}::discreteMaximumPrincipleAndMinAndMaxSearch_t = 0;
std::atomic_ulong {{project}}::{{solver}}::discreteMaximumPrincipleAndMinAndMaxSearch_c = 0;
    
std::atomic_ulong {{project}}::{{solver}}::findCellLocalMinAndMax_f = 0;
std::atomic_ulong {{project}}::{{solver}}::findCellLocalMinAndMax_t = 0;
std::atomic_ulong {{project}}::{{solver}}::findCellLocalMinAndMax_c = 0;
    
std::atomic_ulong {{project}}::{{solver}}::findCellLocalLimiterMinAndMax_f = 0;
std::atomic_ulong {{project}}::{{solver}}::findCellLocalLimiterMinAndMax_t = 0;
std::atomic_ulong {{project}}::{{solver}}::findCellLocalLimiterMinAndMax_c = 0;
{% endif %}

// Just call parent constructor
{{project}}::{{solver}}::{{solver}}(
        const double maximumMeshSize,
        const int maximumMeshDepth,
        const int haloCells,
        const int regularisedFineGridLevels,
        const exahype::solvers::Solver::TimeStepping timeStepping,
        const int DMPObservables,
        const double DMPRelaxationParameter,
        const double DMPDifferenceScaling
        {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}) :
  exahype::solvers::LimitingADERDGSolver::LimitingADERDGSolver(
      "{{solver}}",
    new {{project}}::{{ADERDGSolver}}(
      maximumMeshSize,maximumMeshDepth,haloCells,regularisedFineGridLevels,timeStepping,DMPObservables),
    new {{project}}::{{FVSolver}}(
      maximumMeshSize, timeStepping),
    DMPRelaxationParameter,
    DMPDifferenceScaling) {}

void {{project}}::{{solver}}::projectOnFVLimiterSpace(const double* const luh, double* const lim) const {
{% if aderdgContext.countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{aderdgContext.optNamespace}}::projectOnFVLimiterSpace(luh, lim);

{% if aderdgContext.countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{aderdgContext.optNamespace}}::projectOnFVLimiterSpace_flops;
  total_flops += f;
  total_time += time_ul;
  projectOnFVLimiterSpace_f += f;
  projectOnFVLimiterSpace_t += time_ul;
  projectOnFVLimiterSpace_c += 1;
{% endif %} 
}

void {{project}}::{{solver}}::projectOnDGSpace(const double* const lim, double* const luh) const {
{% if aderdgContext.countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{aderdgContext.optNamespace}}::projectOnDGSpace(lim, luh);

{% if aderdgContext.countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{aderdgContext.optNamespace}}::projectOnDGSpace_flops;
  total_flops += f;
  total_time += time_ul;
  projectOnDGSpace_f += f;
  projectOnDGSpace_t += time_ul;
  projectOnDGSpace_c += 1;
{% endif %} 
}

bool {{project}}::{{solver}}::discreteMaximumPrincipleAndMinAndMaxSearch(const double* const luh, double* const boundaryMinPerVariables, double* const boundaryMaxPerVariables) {
{% if aderdgContext.countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  const bool r =  {{aderdgContext.optNamespace}}::discreteMaximumPrincipleAndMinAndMaxSearch(luh, _solver.get(), _DMPMaximumRelaxationParameter, _DMPDifferenceScaling, boundaryMinPerVariables, boundaryMaxPerVariables);

{% if aderdgContext.countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{aderdgContext.optNamespace}}::discreteMaximumPrincipleAndMinAndMaxSearch_flops;
  total_flops += f;
  total_time += time_ul;
  discreteMaximumPrincipleAndMinAndMaxSearch_f += f;
  discreteMaximumPrincipleAndMinAndMaxSearch_t += time_ul;
  discreteMaximumPrincipleAndMinAndMaxSearch_c += 1;
{% endif %}

  return r;
}

void {{project}}::{{solver}}::findCellLocalMinAndMax(const double* const luh, double* const localMinPerVariables, double* const localMaxPerVariable) {
{% if aderdgContext.countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{aderdgContext.optNamespace}}::findCellLocalMinAndMax(luh, _solver.get(), localMinPerVariables, localMaxPerVariable);

{% if aderdgContext.countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{aderdgContext.optNamespace}}::findCellLocalMinAndMax_flops;
  total_flops += f;
  total_time += time_ul;
  findCellLocalMinAndMax_f += f;
  findCellLocalMinAndMax_t += time_ul;
  findCellLocalMinAndMax_c += 1;
{% endif %} 
}

void {{project}}::{{solver}}::findCellLocalLimiterMinAndMax(const double* const lim, double* const localMinPerObservable, double* const localMaxPerObservable) {
{% if aderdgContext.countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{aderdgContext.optNamespace}}::findCellLocalLimiterMinAndMax(lim, _solver.get(), localMinPerObservable,localMaxPerObservable);

{% if aderdgContext.countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{aderdgContext.optNamespace}}::findCellLocalLimiterMinAndMax_flops;
  total_flops += f;
  total_time += time_ul;
  findCellLocalLimiterMinAndMax_f += f;
  findCellLocalLimiterMinAndMax_t += time_ul;
  findCellLocalLimiterMinAndMax_c += 1;
{% endif %} 
}
