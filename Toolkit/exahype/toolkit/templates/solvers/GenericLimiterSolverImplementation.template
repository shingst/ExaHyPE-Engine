// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// ==============================================
#include "{{solver}}.h"

#include "kernels/limiter/generic/Limiter.h"
#include "kernels/LimiterProjectionMatrices.h"

{{project}}::{{solver}}::{{solver}}(
        const double maximumMeshSize,
        const int maximumMeshDepth,
        const int haloCells,
        const int haloBufferCells,
        const int limiterBufferCells,
        const int regularisedFineGridLevels,
        const exahype::solvers::Solver::TimeStepping timeStepping,
        const int DMPObservables,
        const double DMPRelaxationParameter,
        const double DMPDifferenceScaling
        {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}) :
  exahype::solvers::LimitingADERDGSolver::LimitingADERDGSolver(
      "{{solver}}",
    new {{project}}::{{ADERDGSolver}}(
      maximumMeshSize,maximumMeshDepth,haloCells,haloBufferCells,limiterBufferCells,regularisedFineGridLevels,timeStepping,DMPObservables),
    new {{project}}::{{FVSolver}}(
      maximumMeshSize, timeStepping),
    DMPRelaxationParameter,
    DMPDifferenceScaling) {
  kernels::computeDG2FVProjector<Order,PatchSize>(dg2fv);    
  kernels::computeFV2DGProjector<Order,PatchSize>(fv2dg,dg2fv);
  kernels::computeLegendre2LobattoProjector<Order>(leg2lob);  
}

void {{project}}::{{solver}}::projectOnFVLimiterSpace(const double* const luh, double* const lim) const {
  kernels::limiter::generic::c::projectOnFVLimiterSpace<NumberOfVariables+NumberOfParameters, Order+1, PatchSize, GhostLayerWidth>(luh, dg2fv, lim);
}

void {{project}}::{{solver}}::projectOnDGSpace(const double* const lim, double* const luh) const {
  kernels::limiter::generic::c::projectOnDGSpace<NumberOfVariables+NumberOfParameters, Order+1, PatchSize, GhostLayerWidth>(lim, fv2dg, luh);
}

bool {{project}}::{{solver}}::discreteMaximumPrincipleAndMinAndMaxSearch(const double* const luh, double* const boundaryMinPerVariables, double* const boundaryMaxPerVariables) {
  return kernels::limiter::generic::c::discreteMaximumPrincipleAndMinAndMaxSearch<{{ADERDGAbstractSolver}}, NumberOfDMPObservables, Order+1, PatchSize, GhostLayerWidth>(
    luh, *static_cast<{{ADERDGAbstractSolver}}*>(_solver.get()), dg2fv, fv2dg, leg2lob, _DMPMaximumRelaxationParameter, _DMPDifferenceScaling, boundaryMinPerVariables, boundaryMaxPerVariables);
}

void {{project}}::{{solver}}::findCellLocalMinAndMax(const double* const luh, double* const localMinPerVariables, double* const localMaxPerVariable) {
  kernels::limiter::generic::c::findCellLocalMinAndMax<{{ADERDGAbstractSolver}}, NumberOfDMPObservables, Order+1, PatchSize>(
    luh, *static_cast<{{ADERDGAbstractSolver}}*>(_solver.get()), dg2fv, fv2dg, leg2lob, localMinPerVariables, localMaxPerVariable);
}

void {{project}}::{{solver}}::findCellLocalLimiterMinAndMax(const double* const lim, double* const localMinPerObservable, double* const localMaxPerObservable) {
  kernels::limiter::generic::c::findCellLocalLimiterMinAndMax<{{ADERDGAbstractSolver}}, NumberOfDMPObservables, Order+1, PatchSize, GhostLayerWidth>(
    lim, *static_cast<{{ADERDGAbstractSolver}}*>(_solver.get()), localMinPerObservable, localMaxPerObservable);
}