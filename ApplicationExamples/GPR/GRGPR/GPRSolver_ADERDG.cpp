// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "GPRSolver_ADERDG.h"

#include "GPRSolver_ADERDG_Variables.h"
// User defined calls
#include "PDE.h"
#include "InitialData.h"
#include "C2P-GRGPR.h"

#include <cstring> // memset
#include "kernels/KernelUtils.h" // matrix indexing
#include "kernels/GaussLegendreBasis.h"

tarch::logging::Log GRGPR::GPRSolver_ADERDG::_log( "GRGPR::GPRSolver_ADERDG" );


void GRGPR::GPRSolver_ADERDG::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  // @todo Please implement/augment if required
  const int order = GRGPR::AbstractGPRSolver_ADERDG::Order;
  inittecplot_(&order,&order);
}

void GRGPR::GPRSolver_ADERDG::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
  // Dimensions                        = 2
  // Number of variables + parameters  = 30 + 0
  // @todo Please implement/augment if required
  if (tarch::la::equals(t,0.0)) {
    initialdata_(x, &t, Q);
  }
}

void GRGPR::GPRSolver_ADERDG::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {
  // Internal parameters
  const int nVar = GRGPR::AbstractGPRSolver_ADERDG::NumberOfVariables;
  const int order = GRGPR::AbstractGPRSolver_ADERDG::Order;
  const int basisSize = order + 1;
  const int nDim = DIMENSIONS;

  double Qgp[nVar],*F[nDim], Fs[nDim][nVar];

  std::memset(stateOut, 0, nVar * sizeof(double));
  std::memset(fluxOut, 0, nVar * sizeof(double));
  
  for(int dd=0; dd<nDim; dd++) F[dd] = Fs[dd];
  
  for(int i=0; i < basisSize; i++)  { // i == time
     const double weight = kernels::legendre::weights[order][i];
     const double xi = kernels::legendre::nodes[order][i];
     double ti = t + xi * dt;

     initialdata_(x, &ti, Qgp);
	flux(Qgp, F);
     for(int m=0; m < nVar; m++) {
        stateOut[m] += weight * Qgp[m];
        fluxOut[m] += weight * Fs[normalNonZero][m];
     }
  }
  /*
	for(int m=0; m < nVar; m++) {
	stateOut[m] = stateIn[m];
	fluxOut[m] = fluxIn[m];
	}
	*/
}

exahype::solvers::Solver::RefinementControl GRGPR::GPRSolver_ADERDG::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) {
  // @todo Please implement/augment if required
  const int nVar = GRGPR::AbstractGPRSolver_ADERDG::NumberOfVariables;
  const int order = GRGPR::AbstractGPRSolver_ADERDG::Order;
  const int basisSize = order + 1;
  int refine_flag;
  double max_luh[nVar];
  double min_luh[nVar];
  
  //return exahype::solvers::Solver::RefinementControl::Keep;
 
  for(int m = 0; m <nVar ; m++){
	max_luh[m]=-1.e+14;
	min_luh[m]=1.e+14;
  }
  
#if DIMENSIONS==3
	kernels::idx4 id_xyz_dof(basisSize,basisSize,basisSize,nVar);
#else
	kernels::idx3 id_xy_dof(basisSize,basisSize,nVar);
#endif
  
  for(int i = 0; i < basisSize; i++){
		for(int j = 0; j <basisSize ; j++){
#if DIMENSIONS==3	
			for(int k = 0; k <basisSize ; k++){
#endif
#if DIMENSIONS==3
				for(int m = 0; m <nVar ; m++){
					if(luh[id_xyz_dof(i,j,k,m)]<min_luh[m]){
						min_luh[m]=luh[id_xyz_dof(i,j,k,m)];
					}
					if(luh[id_xyz_dof(i,j,k,m)]>max_luh[m]){
						max_luh[m]=luh[id_xyz_dof(i,j,k,m)];
					}
				}
#else
				for(int m = 0; m <nVar ; m++){
					if(luh[id_xy_dof(i,j,m)]<min_luh[m]){
						min_luh[m]=luh[id_xy_dof(i,j,m)];
					}
					if(luh[id_xy_dof(i,j,m)]>max_luh[m]){
						max_luh[m]=luh[id_xy_dof(i,j,m)];
					}
				}	
#endif
		

#if DIMENSIONS==3				
			}
#endif			
		}
	}		  
  pderefinecriteria_(&refine_flag,&max_luh[0],&min_luh[0]);
  if(refine_flag>1){
	  return exahype::solvers::Solver::RefinementControl::Refine;
  }else{
		if(refine_flag>0){
			return exahype::solvers::Solver::RefinementControl::Keep;
		}else{
			//return exahype::solvers::Solver::RefinementControl::Recoarse;
			return exahype::solvers::Solver::RefinementControl::Keep;
		};
  }
  
  //return exahype::solvers::Solver::RefinementControl::Refine;
  
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void GRGPR::GPRSolver_ADERDG::eigenvalues(const double* const Q,const int d,double* const lambda) {
  // Dimensions                        = 2
  // Number of variables + parameters  = 30 + 0
  
  // @todo Please implement/augment if required
  double nv[3] = {0.};
  nv[d] = 1;
  pdeeigenvalues_(lambda, Q, nv);
}


void GRGPR::GPRSolver_ADERDG::flux(const double* const Q,double** const F) {
	const int nVar = GRGPR::AbstractGPRSolver_ADERDG::NumberOfVariables;
  // Dimensions                        = 3
  // Number of variables + parameters  = 30 + 0
  
  // @todo Please implement/augment if required
  // pdeflux_(F[0], F[1], (DIMENSIONS==3)?F[2]:nullptr, Q);
    if(DIMENSIONS == 2){
		double F_3[nVar];
		pdeflux_(F[0], F[1],F_3, Q);
	}else{
		pdeflux_(F[0], F[1],F[2], Q);
	}
}


//You can either implement this method or modify fusedSource
void GRGPR::GPRSolver_ADERDG::algebraicSource(const double* const Q,double* const S) {
  // @todo Please implement/augment if required
  pdesource_(S, Q);
}

void  GRGPR::GPRSolver_ADERDG::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  // @todo Please implement/augment if required
  pdencp_(BgradQ, Q, gradQ);
}

void GRGPR::GPRSolver_ADERDG::mapDiscreteMaximumPrincipleObservables(double* const observables, const double* const Q) const {
  assertion(NumberOfDMPObservables==1);
  ReadOnlyVariables vars(Q);

  pdedefineobservables_(&NumberOfDMPObservables,observables,Q);
}

bool GRGPR::GPRSolver_ADERDG::isPhysicallyAdmissible(
      const double* const solution,
      const double* const observablesMin,const double* const observablesMax,
      const bool wasTroubledInPreviousTimeStep,
      const tarch::la::Vector<DIMENSIONS,double>& center,
      const tarch::la::Vector<DIMENSIONS,double>& dx,
      const double t) const {
  int limvalue;
  return true;
  pdelimitervalue_(&limvalue,&center[0],&NumberOfDMPObservables, observablesMin, observablesMax);
  if(limvalue>0){
	  return false;
  }else{
	  return true;
  };
}
