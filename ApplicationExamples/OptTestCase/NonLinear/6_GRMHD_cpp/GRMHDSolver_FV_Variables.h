// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __GRMHDSolver_FV_Variables_CLASS_HEADER__
#define __GRMHDSolver_FV_Variables_CLASS_HEADER__

#include "AbstractGRMHDSolver_FV.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct GRMHD::AbstractGRMHDSolver_FV::VariableMetrics {
  static constexpr int numDistinctVariables = 10;
  static constexpr int SizeVariables = 23; 
  static constexpr int SizeParameters = 0;
  static constexpr int Size           = 23+0;
  static constexpr int Dimensions    = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class GRMHD::AbstractGRMHDSolver_FV::VariableShortcuts : public GRMHD::AbstractGRMHDSolver_FV::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { 0, 1, 4, 5, 8, 9, 10, 13, 19, 22, -1 };

  const int         rho = 0;
  const int         vel = 1;
  const int           E = 4;
  const int           B = 5;
  const int         psi = 8;
  const int       lapse = 9;
  const int       shift = 10;
  const int         gij = 13;
  const int coordinates = 19;
  const int       check = 22;


  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class GRMHD::AbstractGRMHDSolver_FV::VariableMultiplicities : public GRMHD::AbstractGRMHDSolver_FV::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { 1, 3, 1, 3, 1, 1, 3, 6, 3, 1, -1 };

  const int         rho = 1;
  const int         vel = 3;
  const int           E = 1;
  const int           B = 3;
  const int         psi = 1;
  const int       lapse = 1;
  const int       shift = 3;
  const int         gij = 6;
  const int coordinates = 3;
  const int       check = 1;


  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class GRMHD::AbstractGRMHDSolver_FV::VariableNames : public GRMHD::AbstractGRMHDSolver_FV::VariableMetrics {
public:
  char const *_Q[numDistinctVariables + 1] = { "rho", "vel", "E", "B", "psi", "lapse", "shift", "gij", "coordinates", "check", nullptr };

  const char*         rho = "rho";
  const char*         vel = "vel";
  const char*           E = "E";
  const char*           B = "B";
  const char*         psi = "psi";
  const char*       lapse = "lapse";
  const char*       shift = "shift";
  const char*         gij = "gij";
  const char* coordinates = "coordinates";
  const char*       check = "check";


  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace GRMHD::GRMHDSolver_FV_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       GRMHD::AbstractGRMHDSolver_FV::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace GRMHD {
	namespace GRMHDSolver_FV_Variables {
		namespace shortcuts {
			  constexpr int         rho = 0;
  constexpr int         vel = 1;
  constexpr int           E = 4;
  constexpr int           B = 5;
  constexpr int         psi = 8;
  constexpr int       lapse = 9;
  constexpr int       shift = 10;
  constexpr int         gij = 13;
  constexpr int coordinates = 19;
  constexpr int       check = 22;

		} // namespace shortcuts
		namespace names {
			  constexpr char         rho[] = "rho";
  constexpr char         vel[] = "vel";
  constexpr char           E[] = "E";
  constexpr char           B[] = "B";
  constexpr char         psi[] = "psi";
  constexpr char       lapse[] = "lapse";
  constexpr char       shift[] = "shift";
  constexpr char         gij[] = "gij";
  constexpr char coordinates[] = "coordinates";
  constexpr char       check[] = "check";

		} // namespace names
	} // end of namespace GRMHD::GRMHDSolver_FV_Variables 
} // end of namespace GRMHD

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double* const Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class GRMHD::AbstractGRMHDSolver_FV::ReadOnlyVariables : public GRMHD::AbstractGRMHDSolver_FV::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

    double rho() const { return _Q[0]; }

    double vel(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[1+index];
    }

    tarch::la::Vector<3,double> vel() const {
      tarch::la::Vector<3,double> values;
      values=_Q[1],_Q[2],_Q[3];
      return values;
    }

    double E() const { return _Q[4]; }

    double B(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[5+index];
    }

    tarch::la::Vector<3,double> B() const {
      tarch::la::Vector<3,double> values;
      values=_Q[5],_Q[6],_Q[7];
      return values;
    }

    double psi() const { return _Q[8]; }

    double lapse() const { return _Q[9]; }

    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[10+index];
    }

    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[10],_Q[11],_Q[12];
      return values;
    }

    double gij(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[13+index];
    }

    tarch::la::Vector<6,double> gij() const {
      tarch::la::Vector<6,double> values;
      values=_Q[13],_Q[14],_Q[15],_Q[16],_Q[17],_Q[18];
      return values;
    }

    double coordinates(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[19+index];
    }

    tarch::la::Vector<3,double> coordinates() const {
      tarch::la::Vector<3,double> values;
      values=_Q[19],_Q[20],_Q[21];
      return values;
    }

    double check() const { return _Q[22]; }


}; // end of ReadOnlyVariables


class GRMHD::AbstractGRMHDSolver_FV::Variables : public GRMHD::AbstractGRMHDSolver_FV::VariableMetrics{
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = 23;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 23+0;
  
    Variables(double* const Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

    double rho() const { return _Q[0]; }

    double vel(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[1+index];
    }

    tarch::la::Vector<3,double> vel() const {
      tarch::la::Vector<3,double> values;
      values=_Q[1],_Q[2],_Q[3];
      return values;
    }

    double E() const { return _Q[4]; }

    double B(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[5+index];
    }

    tarch::la::Vector<3,double> B() const {
      tarch::la::Vector<3,double> values;
      values=_Q[5],_Q[6],_Q[7];
      return values;
    }

    double psi() const { return _Q[8]; }

    double lapse() const { return _Q[9]; }

    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[10+index];
    }

    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[10],_Q[11],_Q[12];
      return values;
    }

    double gij(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[13+index];
    }

    tarch::la::Vector<6,double> gij() const {
      tarch::la::Vector<6,double> values;
      values=_Q[13],_Q[14],_Q[15],_Q[16],_Q[17],_Q[18];
      return values;
    }

    double coordinates(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[19+index];
    }

    tarch::la::Vector<3,double> coordinates() const {
      tarch::la::Vector<3,double> values;
      values=_Q[19],_Q[20],_Q[21];
      return values;
    }

    double check() const { return _Q[22]; }



    // Java-generated code for VariablesSetters:

    double& rho() { return _Q[0]; }

    double& vel(int index) { return _Q[1+index]; }

    void vel(const tarch::la::Vector<3,double>& values) {
      *(_Q+1)=values[0];
      *(_Q+2)=values[1];
      *(_Q+3)=values[2];
    }

    void vel(double vel0,double vel1,double vel2) {
      *(_Q+1)=vel0;
      *(_Q+2)=vel1;
      *(_Q+3)=vel2;
    }

    double& E() { return _Q[4]; }

    double& B(int index) { return _Q[5+index]; }

    void B(const tarch::la::Vector<3,double>& values) {
      *(_Q+5)=values[0];
      *(_Q+6)=values[1];
      *(_Q+7)=values[2];
    }

    void B(double B0,double B1,double B2) {
      *(_Q+5)=B0;
      *(_Q+6)=B1;
      *(_Q+7)=B2;
    }

    double& psi() { return _Q[8]; }

    double& lapse() { return _Q[9]; }

    double& shift(int index) { return _Q[10+index]; }

    void shift(const tarch::la::Vector<3,double>& values) {
      *(_Q+10)=values[0];
      *(_Q+11)=values[1];
      *(_Q+12)=values[2];
    }

    void shift(double shift0,double shift1,double shift2) {
      *(_Q+10)=shift0;
      *(_Q+11)=shift1;
      *(_Q+12)=shift2;
    }

    double& gij(int index) { return _Q[13+index]; }

    void gij(const tarch::la::Vector<6,double>& values) {
      *(_Q+13)=values[0];
      *(_Q+14)=values[1];
      *(_Q+15)=values[2];
      *(_Q+16)=values[3];
      *(_Q+17)=values[4];
      *(_Q+18)=values[5];
    }

    void gij(double gij0,double gij1,double gij2,double gij3,double gij4,double gij5) {
      *(_Q+13)=gij0;
      *(_Q+14)=gij1;
      *(_Q+15)=gij2;
      *(_Q+16)=gij3;
      *(_Q+17)=gij4;
      *(_Q+18)=gij5;
    }

    double& coordinates(int index) { return _Q[19+index]; }

    void coordinates(const tarch::la::Vector<3,double>& values) {
      *(_Q+19)=values[0];
      *(_Q+20)=values[1];
      *(_Q+21)=values[2];
    }

    void coordinates(double coordinates0,double coordinates1,double coordinates2) {
      *(_Q+19)=coordinates0;
      *(_Q+20)=coordinates1;
      *(_Q+21)=coordinates2;
    }

    double& check() { return _Q[22]; }


}; // end of Variables


class GRMHD::AbstractGRMHDSolver_FV::Fluxes : public GRMHD::AbstractGRMHDSolver_FV::VariableMetrics {
  private:
    double** _F;
  public:
    Fluxes(double** const F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


    // Java-generated code for FluxGetters:

    double rho(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }

    tarch::la::Vector<DIMENSIONS,double> rho() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0],_F[2][0]);
      #endif
      return values;
    }

    double vel(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1+row];
    }

    tarch::la::Vector<DIMENSIONS,double> vel(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1+row],_F[1][1+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1+row],_F[1][1+row],_F[2][1+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> vel() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3];
      #elif DIMENSIONS==3
      values = _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3];
      #endif
      return values;
    }

    double E(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][4];
    }

    tarch::la::Vector<DIMENSIONS,double> E() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][4],_F[1][4]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][4],_F[1][4],_F[2][4]);
      #endif
      return values;
    }

    double B(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][5+row];
    }

    tarch::la::Vector<DIMENSIONS,double> B(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][5+row],_F[1][5+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][5+row],_F[1][5+row],_F[2][5+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> B() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][5],_F[1][5],
               _F[0][6],_F[1][6],
               _F[0][7],_F[1][7];
      #elif DIMENSIONS==3
      values = _F[0][5],_F[1][5],
               _F[0][6],_F[1][6],
               _F[0][7],_F[1][7];
      #endif
      return values;
    }

    double psi(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][8];
    }

    tarch::la::Vector<DIMENSIONS,double> psi() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][8],_F[1][8]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][8],_F[1][8],_F[2][8]);
      #endif
      return values;
    }

    double lapse(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][9];
    }

    tarch::la::Vector<DIMENSIONS,double> lapse() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][9],_F[1][9]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][9],_F[1][9],_F[2][9]);
      #endif
      return values;
    }

    double shift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][10+row];
    }

    tarch::la::Vector<DIMENSIONS,double> shift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][10+row],_F[1][10+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][10+row],_F[1][10+row],_F[2][10+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> shift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][10],_F[1][10],
               _F[0][11],_F[1][11],
               _F[0][12],_F[1][12];
      #elif DIMENSIONS==3
      values = _F[0][10],_F[1][10],
               _F[0][11],_F[1][11],
               _F[0][12],_F[1][12];
      #endif
      return values;
    }

    double gij(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }

    tarch::la::Vector<DIMENSIONS,double> gij(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row],_F[2][13+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> gij() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][13],_F[1][13],
               _F[0][14],_F[1][14],
               _F[0][15],_F[1][15],
               _F[0][16],_F[1][16],
               _F[0][17],_F[1][17],
               _F[0][18],_F[1][18];
      #elif DIMENSIONS==3
      values = _F[0][13],_F[1][13],
               _F[0][14],_F[1][14],
               _F[0][15],_F[1][15],
               _F[0][16],_F[1][16],
               _F[0][17],_F[1][17],
               _F[0][18],_F[1][18];
      #endif
      return values;
    }

    double coordinates(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][19+row];
    }

    tarch::la::Vector<DIMENSIONS,double> coordinates(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][19+row],_F[1][19+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][19+row],_F[1][19+row],_F[2][19+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> coordinates() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][19],_F[1][19],
               _F[0][20],_F[1][20],
               _F[0][21],_F[1][21];
      #elif DIMENSIONS==3
      values = _F[0][19],_F[1][19],
               _F[0][20],_F[1][20],
               _F[0][21],_F[1][21];
      #endif
      return values;
    }

    double check(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][22];
    }

    tarch::la::Vector<DIMENSIONS,double> check() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][22],_F[1][22]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][22],_F[1][22],_F[2][22]);
      #endif
      return values;
    }



    // Java-generated code for FluxSetters:

    double& rho(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }

    void rho(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][0]=values[0];
      _F[1][0]=values[1];
      #if DIMENSIONS==3
      _F[2][0]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void rho(const tarch::la::Vector<3,double>& values) {
      _F[0][0]=values[0];
      _F[1][0]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void rho(double v0,double v1,double v2) {
      _F[0][0]=v0;
      _F[1][0]=v1;
      #if DIMENSIONS==3
      _F[2][0]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void rho(double v0,double v1) {
      _F[0][0]=v0;
      _F[1][0]=v1;
    }
    #endif

    double& vel(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1+row];
    }

    void vel(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=values[0];
      _F[1][1+row]=values[1];
      #if DIMENSIONS==2
      _F[2][1+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void vel(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=values[0];
      _F[1][1+row]=values[1];
    }
    #endif

    void vel(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][1]=values(0,0);
      _F[0][2]=values(1,0);
      _F[0][3]=values(2,0);
      _F[1][1]=values(0,1);
      _F[1][2]=values(1,1);
      _F[1][3]=values(2,1);
      #if DIMENSIONS==3
      _F[2][1]=values(0,2);
      _F[2][2]=values(1,2);
      _F[2][3]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void vel(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][1]=values(0,0);
      _F[0][2]=values(1,0);
      _F[0][3]=values(2,0);
      _F[1][1]=values(0,1);
      _F[1][2]=values(1,1);
      _F[1][3]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void vel(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=v0;
      _F[1][1+row]=v1;
      #if DIMENSIONS==3
      _F[2][1+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void vel(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=v0;
      _F[1][1+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void vel(double v00, double v01, double v02,
             double v10, double v11, double v12,
             double v20, double v21, double v22) {
      _F[0][1]=v00;
      _F[0][2]=v10;
      _F[0][3]=v20;
      _F[1][1]=v01;
      _F[1][2]=v11;
      _F[1][3]=v21;
      #if DIMENSIONS==3
      _F[2][1]=v02;
      _F[2][2]=v12;
      _F[2][3]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void vel(double v00, double v01,
             double v10, double v11,
             double v20, double v21) {
      _F[0][1]=v00;
      _F[0][2]=v10;
      _F[0][3]=v20;
      _F[1][1]=v01;
      _F[1][2]=v11;
      _F[1][3]=v21;
    }
    #endif

    double& E(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][4];
    }

    void E(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][4]=values[0];
      _F[1][4]=values[1];
      #if DIMENSIONS==3
      _F[2][4]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void E(const tarch::la::Vector<3,double>& values) {
      _F[0][4]=values[0];
      _F[1][4]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void E(double v0,double v1,double v2) {
      _F[0][4]=v0;
      _F[1][4]=v1;
      #if DIMENSIONS==3
      _F[2][4]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void E(double v0,double v1) {
      _F[0][4]=v0;
      _F[1][4]=v1;
    }
    #endif

    double& B(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][5+row];
    }

    void B(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=values[0];
      _F[1][5+row]=values[1];
      #if DIMENSIONS==2
      _F[2][5+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void B(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=values[0];
      _F[1][5+row]=values[1];
    }
    #endif

    void B(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][5]=values(0,0);
      _F[0][6]=values(1,0);
      _F[0][7]=values(2,0);
      _F[1][5]=values(0,1);
      _F[1][6]=values(1,1);
      _F[1][7]=values(2,1);
      #if DIMENSIONS==3
      _F[2][5]=values(0,2);
      _F[2][6]=values(1,2);
      _F[2][7]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void B(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][5]=values(0,0);
      _F[0][6]=values(1,0);
      _F[0][7]=values(2,0);
      _F[1][5]=values(0,1);
      _F[1][6]=values(1,1);
      _F[1][7]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void B(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=v0;
      _F[1][5+row]=v1;
      #if DIMENSIONS==3
      _F[2][5+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void B(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=v0;
      _F[1][5+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void B(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22) {
      _F[0][5]=v00;
      _F[0][6]=v10;
      _F[0][7]=v20;
      _F[1][5]=v01;
      _F[1][6]=v11;
      _F[1][7]=v21;
      #if DIMENSIONS==3
      _F[2][5]=v02;
      _F[2][6]=v12;
      _F[2][7]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void B(double v00, double v01,
           double v10, double v11,
           double v20, double v21) {
      _F[0][5]=v00;
      _F[0][6]=v10;
      _F[0][7]=v20;
      _F[1][5]=v01;
      _F[1][6]=v11;
      _F[1][7]=v21;
    }
    #endif

    double& psi(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][8];
    }

    void psi(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][8]=values[0];
      _F[1][8]=values[1];
      #if DIMENSIONS==3
      _F[2][8]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void psi(const tarch::la::Vector<3,double>& values) {
      _F[0][8]=values[0];
      _F[1][8]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void psi(double v0,double v1,double v2) {
      _F[0][8]=v0;
      _F[1][8]=v1;
      #if DIMENSIONS==3
      _F[2][8]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void psi(double v0,double v1) {
      _F[0][8]=v0;
      _F[1][8]=v1;
    }
    #endif

    double& lapse(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][9];
    }

    void lapse(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][9]=values[0];
      _F[1][9]=values[1];
      #if DIMENSIONS==3
      _F[2][9]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void lapse(const tarch::la::Vector<3,double>& values) {
      _F[0][9]=values[0];
      _F[1][9]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void lapse(double v0,double v1,double v2) {
      _F[0][9]=v0;
      _F[1][9]=v1;
      #if DIMENSIONS==3
      _F[2][9]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void lapse(double v0,double v1) {
      _F[0][9]=v0;
      _F[1][9]=v1;
    }
    #endif

    double& shift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][10+row];
    }

    void shift(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=values[0];
      _F[1][10+row]=values[1];
      #if DIMENSIONS==2
      _F[2][10+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void shift(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=values[0];
      _F[1][10+row]=values[1];
    }
    #endif

    void shift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][10]=values(0,0);
      _F[0][11]=values(1,0);
      _F[0][12]=values(2,0);
      _F[1][10]=values(0,1);
      _F[1][11]=values(1,1);
      _F[1][12]=values(2,1);
      #if DIMENSIONS==3
      _F[2][10]=values(0,2);
      _F[2][11]=values(1,2);
      _F[2][12]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void shift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][10]=values(0,0);
      _F[0][11]=values(1,0);
      _F[0][12]=values(2,0);
      _F[1][10]=values(0,1);
      _F[1][11]=values(1,1);
      _F[1][12]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void shift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=v0;
      _F[1][10+row]=v1;
      #if DIMENSIONS==3
      _F[2][10+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void shift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=v0;
      _F[1][10+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void shift(double v00, double v01, double v02,
               double v10, double v11, double v12,
               double v20, double v21, double v22) {
      _F[0][10]=v00;
      _F[0][11]=v10;
      _F[0][12]=v20;
      _F[1][10]=v01;
      _F[1][11]=v11;
      _F[1][12]=v21;
      #if DIMENSIONS==3
      _F[2][10]=v02;
      _F[2][11]=v12;
      _F[2][12]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void shift(double v00, double v01,
               double v10, double v11,
               double v20, double v21) {
      _F[0][10]=v00;
      _F[0][11]=v10;
      _F[0][12]=v20;
      _F[1][10]=v01;
      _F[1][11]=v11;
      _F[1][12]=v21;
    }
    #endif

    double& gij(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }

    void gij(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=values[0];
      _F[1][13+row]=values[1];
      #if DIMENSIONS==2
      _F[2][13+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void gij(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=values[0];
      _F[1][13+row]=values[1];
    }
    #endif

    void gij(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][13]=values(0,0);
      _F[0][14]=values(1,0);
      _F[0][15]=values(2,0);
      _F[0][16]=values(3,0);
      _F[0][17]=values(4,0);
      _F[0][18]=values(5,0);
      _F[1][13]=values(0,1);
      _F[1][14]=values(1,1);
      _F[1][15]=values(2,1);
      _F[1][16]=values(3,1);
      _F[1][17]=values(4,1);
      _F[1][18]=values(5,1);
      #if DIMENSIONS==3
      _F[2][13]=values(0,2);
      _F[2][14]=values(1,2);
      _F[2][15]=values(2,2);
      _F[2][16]=values(3,2);
      _F[2][17]=values(4,2);
      _F[2][18]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void gij(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][13]=values(0,0);
      _F[0][14]=values(1,0);
      _F[0][15]=values(2,0);
      _F[0][16]=values(3,0);
      _F[0][17]=values(4,0);
      _F[0][18]=values(5,0);
      _F[1][13]=values(0,1);
      _F[1][14]=values(1,1);
      _F[1][15]=values(2,1);
      _F[1][16]=values(3,1);
      _F[1][17]=values(4,1);
      _F[1][18]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void gij(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=v0;
      _F[1][13+row]=v1;
      #if DIMENSIONS==3
      _F[2][13+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void gij(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=v0;
      _F[1][13+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void gij(double v00, double v01, double v02,
             double v10, double v11, double v12,
             double v20, double v21, double v22,
             double v30, double v31, double v32,
             double v40, double v41, double v42,
             double v50, double v51, double v52) {
      _F[0][13]=v00;
      _F[0][14]=v10;
      _F[0][15]=v20;
      _F[0][16]=v30;
      _F[0][17]=v40;
      _F[0][18]=v50;
      _F[1][13]=v01;
      _F[1][14]=v11;
      _F[1][15]=v21;
      _F[1][16]=v31;
      _F[1][17]=v41;
      _F[1][18]=v51;
      #if DIMENSIONS==3
      _F[2][13]=v02;
      _F[2][14]=v12;
      _F[2][15]=v22;
      _F[2][16]=v32;
      _F[2][17]=v42;
      _F[2][18]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void gij(double v00, double v01,
             double v10, double v11,
             double v20, double v21,
             double v30, double v31,
             double v40, double v41,
             double v50, double v51) {
      _F[0][13]=v00;
      _F[0][14]=v10;
      _F[0][15]=v20;
      _F[0][16]=v30;
      _F[0][17]=v40;
      _F[0][18]=v50;
      _F[1][13]=v01;
      _F[1][14]=v11;
      _F[1][15]=v21;
      _F[1][16]=v31;
      _F[1][17]=v41;
      _F[1][18]=v51;
    }
    #endif

    double& coordinates(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][19+row];
    }

    void coordinates(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][19+row]=values[0];
      _F[1][19+row]=values[1];
      #if DIMENSIONS==2
      _F[2][19+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void coordinates(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][19+row]=values[0];
      _F[1][19+row]=values[1];
    }
    #endif

    void coordinates(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][19]=values(0,0);
      _F[0][20]=values(1,0);
      _F[0][21]=values(2,0);
      _F[1][19]=values(0,1);
      _F[1][20]=values(1,1);
      _F[1][21]=values(2,1);
      #if DIMENSIONS==3
      _F[2][19]=values(0,2);
      _F[2][20]=values(1,2);
      _F[2][21]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void coordinates(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][19]=values(0,0);
      _F[0][20]=values(1,0);
      _F[0][21]=values(2,0);
      _F[1][19]=values(0,1);
      _F[1][20]=values(1,1);
      _F[1][21]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void coordinates(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][19+row]=v0;
      _F[1][19+row]=v1;
      #if DIMENSIONS==3
      _F[2][19+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void coordinates(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][19+row]=v0;
      _F[1][19+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void coordinates(double v00, double v01, double v02,
                     double v10, double v11, double v12,
                     double v20, double v21, double v22) {
      _F[0][19]=v00;
      _F[0][20]=v10;
      _F[0][21]=v20;
      _F[1][19]=v01;
      _F[1][20]=v11;
      _F[1][21]=v21;
      #if DIMENSIONS==3
      _F[2][19]=v02;
      _F[2][20]=v12;
      _F[2][21]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void coordinates(double v00, double v01,
                     double v10, double v11,
                     double v20, double v21) {
      _F[0][19]=v00;
      _F[0][20]=v10;
      _F[0][21]=v20;
      _F[1][19]=v01;
      _F[1][20]=v11;
      _F[1][21]=v21;
    }
    #endif

    double& check(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][22];
    }

    void check(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][22]=values[0];
      _F[1][22]=values[1];
      #if DIMENSIONS==3
      _F[2][22]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void check(const tarch::la::Vector<3,double>& values) {
      _F[0][22]=values[0];
      _F[1][22]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void check(double v0,double v1,double v2) {
      _F[0][22]=v0;
      _F[1][22]=v1;
      #if DIMENSIONS==3
      _F[2][22]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void check(double v0,double v1) {
      _F[0][22]=v0;
      _F[1][22]=v1;
    }
    #endif


}; // end of Fluxes

// NamingSchemes:


#endif
