// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __CCZ4Solver_ADERDG_Variables_CLASS_HEADER__
#define __CCZ4Solver_ADERDG_Variables_CLASS_HEADER__

#include "AbstractCCZ4Solver_ADERDG.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
  static constexpr int numDistinctVariables = 18;
  static constexpr int SizeVariables = 59; 
  static constexpr int SizeParameters = 0;
  static constexpr int Size           = 59+0;
  static constexpr int Dimensions    = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class CCZ4::AbstractCCZ4Solver_ADERDG::VariableShortcuts : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { 0, 6, 12, 13, 16, 17, 20, 23, 26, 29, 32, 35, 41, 47, 53, 54, 55, 58, -1 };

  const int       G = 0;
  const int       K = 6;
  const int   theta = 12;
  const int       Z = 13;
  const int   lapse = 16;
  const int   shift = 17;
  const int       b = 20;
  const int  dLapse = 23;
  const int dxShift = 26;
  const int dyShift = 29;
  const int dzShift = 32;
  const int     dxG = 35;
  const int     dyG = 41;
  const int     dzG = 47;
  const int  traceK = 53;
  const int     phi = 54;
  const int       P = 55;
  const int      K0 = 58;


  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class CCZ4::AbstractCCZ4Solver_ADERDG::VariableMultiplicities : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { 6, 6, 1, 3, 1, 3, 3, 3, 3, 3, 3, 6, 6, 6, 1, 1, 3, 1, -1 };

  const int       G = 6;
  const int       K = 6;
  const int   theta = 1;
  const int       Z = 3;
  const int   lapse = 1;
  const int   shift = 3;
  const int       b = 3;
  const int  dLapse = 3;
  const int dxShift = 3;
  const int dyShift = 3;
  const int dzShift = 3;
  const int     dxG = 6;
  const int     dyG = 6;
  const int     dzG = 6;
  const int  traceK = 1;
  const int     phi = 1;
  const int       P = 3;
  const int      K0 = 1;


  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class CCZ4::AbstractCCZ4Solver_ADERDG::VariableNames : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
public:
  char const *_Q[numDistinctVariables + 1] = { "G", "K", "theta", "Z", "lapse", "shift", "b", "dLapse", "dxShift", "dyShift", "dzShift", "dxG", "dyG", "dzG", "traceK", "phi", "P", "K0", nullptr };

  const char*       G = "G";
  const char*       K = "K";
  const char*   theta = "theta";
  const char*       Z = "Z";
  const char*   lapse = "lapse";
  const char*   shift = "shift";
  const char*       b = "b";
  const char*  dLapse = "dLapse";
  const char* dxShift = "dxShift";
  const char* dyShift = "dyShift";
  const char* dzShift = "dzShift";
  const char*     dxG = "dxG";
  const char*     dyG = "dyG";
  const char*     dzG = "dzG";
  const char*  traceK = "traceK";
  const char*     phi = "phi";
  const char*       P = "P";
  const char*      K0 = "K0";


  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace CCZ4::CCZ4Solver_ADERDG_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       CCZ4::AbstractCCZ4Solver_ADERDG::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace CCZ4 {
	namespace CCZ4Solver_ADERDG_Variables {
		namespace shortcuts {
			  constexpr int       G = 0;
  constexpr int       K = 6;
  constexpr int   theta = 12;
  constexpr int       Z = 13;
  constexpr int   lapse = 16;
  constexpr int   shift = 17;
  constexpr int       b = 20;
  constexpr int  dLapse = 23;
  constexpr int dxShift = 26;
  constexpr int dyShift = 29;
  constexpr int dzShift = 32;
  constexpr int     dxG = 35;
  constexpr int     dyG = 41;
  constexpr int     dzG = 47;
  constexpr int  traceK = 53;
  constexpr int     phi = 54;
  constexpr int       P = 55;
  constexpr int      K0 = 58;

		} // namespace shortcuts
		namespace names {
			  constexpr char       G[] = "G";
  constexpr char       K[] = "K";
  constexpr char   theta[] = "theta";
  constexpr char       Z[] = "Z";
  constexpr char   lapse[] = "lapse";
  constexpr char   shift[] = "shift";
  constexpr char       b[] = "b";
  constexpr char  dLapse[] = "dLapse";
  constexpr char dxShift[] = "dxShift";
  constexpr char dyShift[] = "dyShift";
  constexpr char dzShift[] = "dzShift";
  constexpr char     dxG[] = "dxG";
  constexpr char     dyG[] = "dyG";
  constexpr char     dzG[] = "dzG";
  constexpr char  traceK[] = "traceK";
  constexpr char     phi[] = "phi";
  constexpr char       P[] = "P";
  constexpr char      K0[] = "K0";

		} // namespace names
	} // end of namespace CCZ4::CCZ4Solver_ADERDG_Variables 
} // end of namespace CCZ4

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double*Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class CCZ4::AbstractCCZ4Solver_ADERDG::ReadOnlyVariables : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

    double G(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[0+index];
    }

    tarch::la::Vector<6,double> G() const {
      tarch::la::Vector<6,double> values;
      values=_Q[0],_Q[1],_Q[2],_Q[3],_Q[4],_Q[5];
      return values;
    }

    double K(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[6+index];
    }

    tarch::la::Vector<6,double> K() const {
      tarch::la::Vector<6,double> values;
      values=_Q[6],_Q[7],_Q[8],_Q[9],_Q[10],_Q[11];
      return values;
    }

    double theta() const { return _Q[12]; }

    double Z(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[13+index];
    }

    tarch::la::Vector<3,double> Z() const {
      tarch::la::Vector<3,double> values;
      values=_Q[13],_Q[14],_Q[15];
      return values;
    }

    double lapse() const { return _Q[16]; }

    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[17+index];
    }

    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[17],_Q[18],_Q[19];
      return values;
    }

    double b(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[20+index];
    }

    tarch::la::Vector<3,double> b() const {
      tarch::la::Vector<3,double> values;
      values=_Q[20],_Q[21],_Q[22];
      return values;
    }

    double dLapse(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[23+index];
    }

    tarch::la::Vector<3,double> dLapse() const {
      tarch::la::Vector<3,double> values;
      values=_Q[23],_Q[24],_Q[25];
      return values;
    }

    double dxShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[26+index];
    }

    tarch::la::Vector<3,double> dxShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[26],_Q[27],_Q[28];
      return values;
    }

    double dyShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[29+index];
    }

    tarch::la::Vector<3,double> dyShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[29],_Q[30],_Q[31];
      return values;
    }

    double dzShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[32+index];
    }

    tarch::la::Vector<3,double> dzShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[32],_Q[33],_Q[34];
      return values;
    }

    double dxG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[35+index];
    }

    tarch::la::Vector<6,double> dxG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[35],_Q[36],_Q[37],_Q[38],_Q[39],_Q[40];
      return values;
    }

    double dyG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[41+index];
    }

    tarch::la::Vector<6,double> dyG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[41],_Q[42],_Q[43],_Q[44],_Q[45],_Q[46];
      return values;
    }

    double dzG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[47+index];
    }

    tarch::la::Vector<6,double> dzG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[47],_Q[48],_Q[49],_Q[50],_Q[51],_Q[52];
      return values;
    }

    double traceK() const { return _Q[53]; }

    double phi() const { return _Q[54]; }

    double P(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[55+index];
    }

    tarch::la::Vector<3,double> P() const {
      tarch::la::Vector<3,double> values;
      values=_Q[55],_Q[56],_Q[57];
      return values;
    }

    double K0() const { return _Q[58]; }


}; // end of ReadOnlyVariables


class CCZ4::AbstractCCZ4Solver_ADERDG::Variables : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics{
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = 59;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 59+0;
  
    Variables(double* Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

    double G(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[0+index];
    }

    tarch::la::Vector<6,double> G() const {
      tarch::la::Vector<6,double> values;
      values=_Q[0],_Q[1],_Q[2],_Q[3],_Q[4],_Q[5];
      return values;
    }

    double K(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[6+index];
    }

    tarch::la::Vector<6,double> K() const {
      tarch::la::Vector<6,double> values;
      values=_Q[6],_Q[7],_Q[8],_Q[9],_Q[10],_Q[11];
      return values;
    }

    double theta() const { return _Q[12]; }

    double Z(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[13+index];
    }

    tarch::la::Vector<3,double> Z() const {
      tarch::la::Vector<3,double> values;
      values=_Q[13],_Q[14],_Q[15];
      return values;
    }

    double lapse() const { return _Q[16]; }

    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[17+index];
    }

    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[17],_Q[18],_Q[19];
      return values;
    }

    double b(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[20+index];
    }

    tarch::la::Vector<3,double> b() const {
      tarch::la::Vector<3,double> values;
      values=_Q[20],_Q[21],_Q[22];
      return values;
    }

    double dLapse(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[23+index];
    }

    tarch::la::Vector<3,double> dLapse() const {
      tarch::la::Vector<3,double> values;
      values=_Q[23],_Q[24],_Q[25];
      return values;
    }

    double dxShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[26+index];
    }

    tarch::la::Vector<3,double> dxShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[26],_Q[27],_Q[28];
      return values;
    }

    double dyShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[29+index];
    }

    tarch::la::Vector<3,double> dyShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[29],_Q[30],_Q[31];
      return values;
    }

    double dzShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[32+index];
    }

    tarch::la::Vector<3,double> dzShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[32],_Q[33],_Q[34];
      return values;
    }

    double dxG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[35+index];
    }

    tarch::la::Vector<6,double> dxG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[35],_Q[36],_Q[37],_Q[38],_Q[39],_Q[40];
      return values;
    }

    double dyG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[41+index];
    }

    tarch::la::Vector<6,double> dyG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[41],_Q[42],_Q[43],_Q[44],_Q[45],_Q[46];
      return values;
    }

    double dzG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[47+index];
    }

    tarch::la::Vector<6,double> dzG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[47],_Q[48],_Q[49],_Q[50],_Q[51],_Q[52];
      return values;
    }

    double traceK() const { return _Q[53]; }

    double phi() const { return _Q[54]; }

    double P(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[55+index];
    }

    tarch::la::Vector<3,double> P() const {
      tarch::la::Vector<3,double> values;
      values=_Q[55],_Q[56],_Q[57];
      return values;
    }

    double K0() const { return _Q[58]; }



    // Java-generated code for VariablesSetters:

    double& G(int index) { return _Q[0+index]; }

    void G(const tarch::la::Vector<6,double>& values) {
      *(_Q+0)=values[0];
      *(_Q+1)=values[1];
      *(_Q+2)=values[2];
      *(_Q+3)=values[3];
      *(_Q+4)=values[4];
      *(_Q+5)=values[5];
    }

    void G(double G0,double G1,double G2,double G3,double G4,double G5) {
      *(_Q+0)=G0;
      *(_Q+1)=G1;
      *(_Q+2)=G2;
      *(_Q+3)=G3;
      *(_Q+4)=G4;
      *(_Q+5)=G5;
    }

    double& K(int index) { return _Q[6+index]; }

    void K(const tarch::la::Vector<6,double>& values) {
      *(_Q+6)=values[0];
      *(_Q+7)=values[1];
      *(_Q+8)=values[2];
      *(_Q+9)=values[3];
      *(_Q+10)=values[4];
      *(_Q+11)=values[5];
    }

    void K(double K0,double K1,double K2,double K3,double K4,double K5) {
      *(_Q+6)=K0;
      *(_Q+7)=K1;
      *(_Q+8)=K2;
      *(_Q+9)=K3;
      *(_Q+10)=K4;
      *(_Q+11)=K5;
    }

    double& theta() { return _Q[12]; }

    double& Z(int index) { return _Q[13+index]; }

    void Z(const tarch::la::Vector<3,double>& values) {
      *(_Q+13)=values[0];
      *(_Q+14)=values[1];
      *(_Q+15)=values[2];
    }

    void Z(double Z0,double Z1,double Z2) {
      *(_Q+13)=Z0;
      *(_Q+14)=Z1;
      *(_Q+15)=Z2;
    }

    double& lapse() { return _Q[16]; }

    double& shift(int index) { return _Q[17+index]; }

    void shift(const tarch::la::Vector<3,double>& values) {
      *(_Q+17)=values[0];
      *(_Q+18)=values[1];
      *(_Q+19)=values[2];
    }

    void shift(double shift0,double shift1,double shift2) {
      *(_Q+17)=shift0;
      *(_Q+18)=shift1;
      *(_Q+19)=shift2;
    }

    double& b(int index) { return _Q[20+index]; }

    void b(const tarch::la::Vector<3,double>& values) {
      *(_Q+20)=values[0];
      *(_Q+21)=values[1];
      *(_Q+22)=values[2];
    }

    void b(double b0,double b1,double b2) {
      *(_Q+20)=b0;
      *(_Q+21)=b1;
      *(_Q+22)=b2;
    }

    double& dLapse(int index) { return _Q[23+index]; }

    void dLapse(const tarch::la::Vector<3,double>& values) {
      *(_Q+23)=values[0];
      *(_Q+24)=values[1];
      *(_Q+25)=values[2];
    }

    void dLapse(double dLapse0,double dLapse1,double dLapse2) {
      *(_Q+23)=dLapse0;
      *(_Q+24)=dLapse1;
      *(_Q+25)=dLapse2;
    }

    double& dxShift(int index) { return _Q[26+index]; }

    void dxShift(const tarch::la::Vector<3,double>& values) {
      *(_Q+26)=values[0];
      *(_Q+27)=values[1];
      *(_Q+28)=values[2];
    }

    void dxShift(double dxShift0,double dxShift1,double dxShift2) {
      *(_Q+26)=dxShift0;
      *(_Q+27)=dxShift1;
      *(_Q+28)=dxShift2;
    }

    double& dyShift(int index) { return _Q[29+index]; }

    void dyShift(const tarch::la::Vector<3,double>& values) {
      *(_Q+29)=values[0];
      *(_Q+30)=values[1];
      *(_Q+31)=values[2];
    }

    void dyShift(double dyShift0,double dyShift1,double dyShift2) {
      *(_Q+29)=dyShift0;
      *(_Q+30)=dyShift1;
      *(_Q+31)=dyShift2;
    }

    double& dzShift(int index) { return _Q[32+index]; }

    void dzShift(const tarch::la::Vector<3,double>& values) {
      *(_Q+32)=values[0];
      *(_Q+33)=values[1];
      *(_Q+34)=values[2];
    }

    void dzShift(double dzShift0,double dzShift1,double dzShift2) {
      *(_Q+32)=dzShift0;
      *(_Q+33)=dzShift1;
      *(_Q+34)=dzShift2;
    }

    double& dxG(int index) { return _Q[35+index]; }

    void dxG(const tarch::la::Vector<6,double>& values) {
      *(_Q+35)=values[0];
      *(_Q+36)=values[1];
      *(_Q+37)=values[2];
      *(_Q+38)=values[3];
      *(_Q+39)=values[4];
      *(_Q+40)=values[5];
    }

    void dxG(double dxG0,double dxG1,double dxG2,double dxG3,double dxG4,double dxG5) {
      *(_Q+35)=dxG0;
      *(_Q+36)=dxG1;
      *(_Q+37)=dxG2;
      *(_Q+38)=dxG3;
      *(_Q+39)=dxG4;
      *(_Q+40)=dxG5;
    }

    double& dyG(int index) { return _Q[41+index]; }

    void dyG(const tarch::la::Vector<6,double>& values) {
      *(_Q+41)=values[0];
      *(_Q+42)=values[1];
      *(_Q+43)=values[2];
      *(_Q+44)=values[3];
      *(_Q+45)=values[4];
      *(_Q+46)=values[5];
    }

    void dyG(double dyG0,double dyG1,double dyG2,double dyG3,double dyG4,double dyG5) {
      *(_Q+41)=dyG0;
      *(_Q+42)=dyG1;
      *(_Q+43)=dyG2;
      *(_Q+44)=dyG3;
      *(_Q+45)=dyG4;
      *(_Q+46)=dyG5;
    }

    double& dzG(int index) { return _Q[47+index]; }

    void dzG(const tarch::la::Vector<6,double>& values) {
      *(_Q+47)=values[0];
      *(_Q+48)=values[1];
      *(_Q+49)=values[2];
      *(_Q+50)=values[3];
      *(_Q+51)=values[4];
      *(_Q+52)=values[5];
    }

    void dzG(double dzG0,double dzG1,double dzG2,double dzG3,double dzG4,double dzG5) {
      *(_Q+47)=dzG0;
      *(_Q+48)=dzG1;
      *(_Q+49)=dzG2;
      *(_Q+50)=dzG3;
      *(_Q+51)=dzG4;
      *(_Q+52)=dzG5;
    }

    double& traceK() { return _Q[53]; }

    double& phi() { return _Q[54]; }

    double& P(int index) { return _Q[55+index]; }

    void P(const tarch::la::Vector<3,double>& values) {
      *(_Q+55)=values[0];
      *(_Q+56)=values[1];
      *(_Q+57)=values[2];
    }

    void P(double P0,double P1,double P2) {
      *(_Q+55)=P0;
      *(_Q+56)=P1;
      *(_Q+57)=P2;
    }

    double& K0() { return _Q[58]; }


}; // end of Variables


class CCZ4::AbstractCCZ4Solver_ADERDG::Fluxes : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
  private:
    double** _F;
  public:
    Fluxes(double** F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


    // Java-generated code for FluxGetters:

    double G(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }

    tarch::la::Vector<DIMENSIONS,double> G(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row],_F[2][0+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> G() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][0],_F[1][0],
               _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3],
               _F[0][4],_F[1][4],
               _F[0][5],_F[1][5];
      #elif DIMENSIONS==3
      values = _F[0][0],_F[1][0],
               _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3],
               _F[0][4],_F[1][4],
               _F[0][5],_F[1][5];
      #endif
      return values;
    }

    double K(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][6+row];
    }

    tarch::la::Vector<DIMENSIONS,double> K(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][6+row],_F[1][6+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][6+row],_F[1][6+row],_F[2][6+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> K() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][6],_F[1][6],
               _F[0][7],_F[1][7],
               _F[0][8],_F[1][8],
               _F[0][9],_F[1][9],
               _F[0][10],_F[1][10],
               _F[0][11],_F[1][11];
      #elif DIMENSIONS==3
      values = _F[0][6],_F[1][6],
               _F[0][7],_F[1][7],
               _F[0][8],_F[1][8],
               _F[0][9],_F[1][9],
               _F[0][10],_F[1][10],
               _F[0][11],_F[1][11];
      #endif
      return values;
    }

    double theta(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][12];
    }

    tarch::la::Vector<DIMENSIONS,double> theta() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][12],_F[1][12]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][12],_F[1][12],_F[2][12]);
      #endif
      return values;
    }

    double Z(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }

    tarch::la::Vector<DIMENSIONS,double> Z(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row],_F[2][13+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> Z() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][13],_F[1][13],
               _F[0][14],_F[1][14],
               _F[0][15],_F[1][15];
      #elif DIMENSIONS==3
      values = _F[0][13],_F[1][13],
               _F[0][14],_F[1][14],
               _F[0][15],_F[1][15];
      #endif
      return values;
    }

    double lapse(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][16];
    }

    tarch::la::Vector<DIMENSIONS,double> lapse() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][16],_F[1][16]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][16],_F[1][16],_F[2][16]);
      #endif
      return values;
    }

    double shift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][17+row];
    }

    tarch::la::Vector<DIMENSIONS,double> shift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][17+row],_F[1][17+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][17+row],_F[1][17+row],_F[2][17+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> shift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][17],_F[1][17],
               _F[0][18],_F[1][18],
               _F[0][19],_F[1][19];
      #elif DIMENSIONS==3
      values = _F[0][17],_F[1][17],
               _F[0][18],_F[1][18],
               _F[0][19],_F[1][19];
      #endif
      return values;
    }

    double b(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][20+row];
    }

    tarch::la::Vector<DIMENSIONS,double> b(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][20+row],_F[1][20+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][20+row],_F[1][20+row],_F[2][20+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> b() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][20],_F[1][20],
               _F[0][21],_F[1][21],
               _F[0][22],_F[1][22];
      #elif DIMENSIONS==3
      values = _F[0][20],_F[1][20],
               _F[0][21],_F[1][21],
               _F[0][22],_F[1][22];
      #endif
      return values;
    }

    double dLapse(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][23+row];
    }

    tarch::la::Vector<DIMENSIONS,double> dLapse(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][23+row],_F[1][23+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][23+row],_F[1][23+row],_F[2][23+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> dLapse() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][23],_F[1][23],
               _F[0][24],_F[1][24],
               _F[0][25],_F[1][25];
      #elif DIMENSIONS==3
      values = _F[0][23],_F[1][23],
               _F[0][24],_F[1][24],
               _F[0][25],_F[1][25];
      #endif
      return values;
    }

    double dxShift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][26+row];
    }

    tarch::la::Vector<DIMENSIONS,double> dxShift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][26+row],_F[1][26+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][26+row],_F[1][26+row],_F[2][26+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> dxShift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][26],_F[1][26],
               _F[0][27],_F[1][27],
               _F[0][28],_F[1][28];
      #elif DIMENSIONS==3
      values = _F[0][26],_F[1][26],
               _F[0][27],_F[1][27],
               _F[0][28],_F[1][28];
      #endif
      return values;
    }

    double dyShift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][29+row];
    }

    tarch::la::Vector<DIMENSIONS,double> dyShift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][29+row],_F[1][29+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][29+row],_F[1][29+row],_F[2][29+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> dyShift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][29],_F[1][29],
               _F[0][30],_F[1][30],
               _F[0][31],_F[1][31];
      #elif DIMENSIONS==3
      values = _F[0][29],_F[1][29],
               _F[0][30],_F[1][30],
               _F[0][31],_F[1][31];
      #endif
      return values;
    }

    double dzShift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][32+row];
    }

    tarch::la::Vector<DIMENSIONS,double> dzShift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][32+row],_F[1][32+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][32+row],_F[1][32+row],_F[2][32+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> dzShift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][32],_F[1][32],
               _F[0][33],_F[1][33],
               _F[0][34],_F[1][34];
      #elif DIMENSIONS==3
      values = _F[0][32],_F[1][32],
               _F[0][33],_F[1][33],
               _F[0][34],_F[1][34];
      #endif
      return values;
    }

    double dxG(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][35+row];
    }

    tarch::la::Vector<DIMENSIONS,double> dxG(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][35+row],_F[1][35+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][35+row],_F[1][35+row],_F[2][35+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> dxG() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][35],_F[1][35],
               _F[0][36],_F[1][36],
               _F[0][37],_F[1][37],
               _F[0][38],_F[1][38],
               _F[0][39],_F[1][39],
               _F[0][40],_F[1][40];
      #elif DIMENSIONS==3
      values = _F[0][35],_F[1][35],
               _F[0][36],_F[1][36],
               _F[0][37],_F[1][37],
               _F[0][38],_F[1][38],
               _F[0][39],_F[1][39],
               _F[0][40],_F[1][40];
      #endif
      return values;
    }

    double dyG(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][41+row];
    }

    tarch::la::Vector<DIMENSIONS,double> dyG(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][41+row],_F[1][41+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][41+row],_F[1][41+row],_F[2][41+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> dyG() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][41],_F[1][41],
               _F[0][42],_F[1][42],
               _F[0][43],_F[1][43],
               _F[0][44],_F[1][44],
               _F[0][45],_F[1][45],
               _F[0][46],_F[1][46];
      #elif DIMENSIONS==3
      values = _F[0][41],_F[1][41],
               _F[0][42],_F[1][42],
               _F[0][43],_F[1][43],
               _F[0][44],_F[1][44],
               _F[0][45],_F[1][45],
               _F[0][46],_F[1][46];
      #endif
      return values;
    }

    double dzG(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][47+row];
    }

    tarch::la::Vector<DIMENSIONS,double> dzG(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][47+row],_F[1][47+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][47+row],_F[1][47+row],_F[2][47+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> dzG() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][47],_F[1][47],
               _F[0][48],_F[1][48],
               _F[0][49],_F[1][49],
               _F[0][50],_F[1][50],
               _F[0][51],_F[1][51],
               _F[0][52],_F[1][52];
      #elif DIMENSIONS==3
      values = _F[0][47],_F[1][47],
               _F[0][48],_F[1][48],
               _F[0][49],_F[1][49],
               _F[0][50],_F[1][50],
               _F[0][51],_F[1][51],
               _F[0][52],_F[1][52];
      #endif
      return values;
    }

    double traceK(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][53];
    }

    tarch::la::Vector<DIMENSIONS,double> traceK() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][53],_F[1][53]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][53],_F[1][53],_F[2][53]);
      #endif
      return values;
    }

    double phi(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][54];
    }

    tarch::la::Vector<DIMENSIONS,double> phi() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][54],_F[1][54]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][54],_F[1][54],_F[2][54]);
      #endif
      return values;
    }

    double P(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][55+row];
    }

    tarch::la::Vector<DIMENSIONS,double> P(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][55+row],_F[1][55+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][55+row],_F[1][55+row],_F[2][55+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> P() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][55],_F[1][55],
               _F[0][56],_F[1][56],
               _F[0][57],_F[1][57];
      #elif DIMENSIONS==3
      values = _F[0][55],_F[1][55],
               _F[0][56],_F[1][56],
               _F[0][57],_F[1][57];
      #endif
      return values;
    }

    double K0(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][58];
    }

    tarch::la::Vector<DIMENSIONS,double> K0() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][58],_F[1][58]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][58],_F[1][58],_F[2][58]);
      #endif
      return values;
    }



    // Java-generated code for FluxSetters:

    double& G(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }

    void G(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][0+row]=values[0];
      _F[1][0+row]=values[1];
      #if DIMENSIONS==2
      _F[2][0+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void G(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][0+row]=values[0];
      _F[1][0+row]=values[1];
    }
    #endif

    void G(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][0]=values(0,0);
      _F[0][1]=values(1,0);
      _F[0][2]=values(2,0);
      _F[0][3]=values(3,0);
      _F[0][4]=values(4,0);
      _F[0][5]=values(5,0);
      _F[1][0]=values(0,1);
      _F[1][1]=values(1,1);
      _F[1][2]=values(2,1);
      _F[1][3]=values(3,1);
      _F[1][4]=values(4,1);
      _F[1][5]=values(5,1);
      #if DIMENSIONS==3
      _F[2][0]=values(0,2);
      _F[2][1]=values(1,2);
      _F[2][2]=values(2,2);
      _F[2][3]=values(3,2);
      _F[2][4]=values(4,2);
      _F[2][5]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void G(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][0]=values(0,0);
      _F[0][1]=values(1,0);
      _F[0][2]=values(2,0);
      _F[0][3]=values(3,0);
      _F[0][4]=values(4,0);
      _F[0][5]=values(5,0);
      _F[1][0]=values(0,1);
      _F[1][1]=values(1,1);
      _F[1][2]=values(2,1);
      _F[1][3]=values(3,1);
      _F[1][4]=values(4,1);
      _F[1][5]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void G(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][0+row]=v0;
      _F[1][0+row]=v1;
      #if DIMENSIONS==3
      _F[2][0+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void G(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][0+row]=v0;
      _F[1][0+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void G(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22,
           double v30, double v31, double v32,
           double v40, double v41, double v42,
           double v50, double v51, double v52) {
      _F[0][0]=v00;
      _F[0][1]=v10;
      _F[0][2]=v20;
      _F[0][3]=v30;
      _F[0][4]=v40;
      _F[0][5]=v50;
      _F[1][0]=v01;
      _F[1][1]=v11;
      _F[1][2]=v21;
      _F[1][3]=v31;
      _F[1][4]=v41;
      _F[1][5]=v51;
      #if DIMENSIONS==3
      _F[2][0]=v02;
      _F[2][1]=v12;
      _F[2][2]=v22;
      _F[2][3]=v32;
      _F[2][4]=v42;
      _F[2][5]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void G(double v00, double v01,
           double v10, double v11,
           double v20, double v21,
           double v30, double v31,
           double v40, double v41,
           double v50, double v51) {
      _F[0][0]=v00;
      _F[0][1]=v10;
      _F[0][2]=v20;
      _F[0][3]=v30;
      _F[0][4]=v40;
      _F[0][5]=v50;
      _F[1][0]=v01;
      _F[1][1]=v11;
      _F[1][2]=v21;
      _F[1][3]=v31;
      _F[1][4]=v41;
      _F[1][5]=v51;
    }
    #endif

    double& K(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][6+row];
    }

    void K(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][6+row]=values[0];
      _F[1][6+row]=values[1];
      #if DIMENSIONS==2
      _F[2][6+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void K(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][6+row]=values[0];
      _F[1][6+row]=values[1];
    }
    #endif

    void K(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][6]=values(0,0);
      _F[0][7]=values(1,0);
      _F[0][8]=values(2,0);
      _F[0][9]=values(3,0);
      _F[0][10]=values(4,0);
      _F[0][11]=values(5,0);
      _F[1][6]=values(0,1);
      _F[1][7]=values(1,1);
      _F[1][8]=values(2,1);
      _F[1][9]=values(3,1);
      _F[1][10]=values(4,1);
      _F[1][11]=values(5,1);
      #if DIMENSIONS==3
      _F[2][6]=values(0,2);
      _F[2][7]=values(1,2);
      _F[2][8]=values(2,2);
      _F[2][9]=values(3,2);
      _F[2][10]=values(4,2);
      _F[2][11]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void K(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][6]=values(0,0);
      _F[0][7]=values(1,0);
      _F[0][8]=values(2,0);
      _F[0][9]=values(3,0);
      _F[0][10]=values(4,0);
      _F[0][11]=values(5,0);
      _F[1][6]=values(0,1);
      _F[1][7]=values(1,1);
      _F[1][8]=values(2,1);
      _F[1][9]=values(3,1);
      _F[1][10]=values(4,1);
      _F[1][11]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void K(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][6+row]=v0;
      _F[1][6+row]=v1;
      #if DIMENSIONS==3
      _F[2][6+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void K(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][6+row]=v0;
      _F[1][6+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void K(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22,
           double v30, double v31, double v32,
           double v40, double v41, double v42,
           double v50, double v51, double v52) {
      _F[0][6]=v00;
      _F[0][7]=v10;
      _F[0][8]=v20;
      _F[0][9]=v30;
      _F[0][10]=v40;
      _F[0][11]=v50;
      _F[1][6]=v01;
      _F[1][7]=v11;
      _F[1][8]=v21;
      _F[1][9]=v31;
      _F[1][10]=v41;
      _F[1][11]=v51;
      #if DIMENSIONS==3
      _F[2][6]=v02;
      _F[2][7]=v12;
      _F[2][8]=v22;
      _F[2][9]=v32;
      _F[2][10]=v42;
      _F[2][11]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void K(double v00, double v01,
           double v10, double v11,
           double v20, double v21,
           double v30, double v31,
           double v40, double v41,
           double v50, double v51) {
      _F[0][6]=v00;
      _F[0][7]=v10;
      _F[0][8]=v20;
      _F[0][9]=v30;
      _F[0][10]=v40;
      _F[0][11]=v50;
      _F[1][6]=v01;
      _F[1][7]=v11;
      _F[1][8]=v21;
      _F[1][9]=v31;
      _F[1][10]=v41;
      _F[1][11]=v51;
    }
    #endif

    double& theta(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][12];
    }

    void theta(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][12]=values[0];
      _F[1][12]=values[1];
      #if DIMENSIONS==3
      _F[2][12]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void theta(const tarch::la::Vector<3,double>& values) {
      _F[0][12]=values[0];
      _F[1][12]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void theta(double v0,double v1,double v2) {
      _F[0][12]=v0;
      _F[1][12]=v1;
      #if DIMENSIONS==3
      _F[2][12]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void theta(double v0,double v1) {
      _F[0][12]=v0;
      _F[1][12]=v1;
    }
    #endif

    double& Z(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }

    void Z(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][13+row]=values[0];
      _F[1][13+row]=values[1];
      #if DIMENSIONS==2
      _F[2][13+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void Z(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][13+row]=values[0];
      _F[1][13+row]=values[1];
    }
    #endif

    void Z(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][13]=values(0,0);
      _F[0][14]=values(1,0);
      _F[0][15]=values(2,0);
      _F[1][13]=values(0,1);
      _F[1][14]=values(1,1);
      _F[1][15]=values(2,1);
      #if DIMENSIONS==3
      _F[2][13]=values(0,2);
      _F[2][14]=values(1,2);
      _F[2][15]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void Z(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][13]=values(0,0);
      _F[0][14]=values(1,0);
      _F[0][15]=values(2,0);
      _F[1][13]=values(0,1);
      _F[1][14]=values(1,1);
      _F[1][15]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void Z(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][13+row]=v0;
      _F[1][13+row]=v1;
      #if DIMENSIONS==3
      _F[2][13+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void Z(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][13+row]=v0;
      _F[1][13+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void Z(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22) {
      _F[0][13]=v00;
      _F[0][14]=v10;
      _F[0][15]=v20;
      _F[1][13]=v01;
      _F[1][14]=v11;
      _F[1][15]=v21;
      #if DIMENSIONS==3
      _F[2][13]=v02;
      _F[2][14]=v12;
      _F[2][15]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void Z(double v00, double v01,
           double v10, double v11,
           double v20, double v21) {
      _F[0][13]=v00;
      _F[0][14]=v10;
      _F[0][15]=v20;
      _F[1][13]=v01;
      _F[1][14]=v11;
      _F[1][15]=v21;
    }
    #endif

    double& lapse(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][16];
    }

    void lapse(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][16]=values[0];
      _F[1][16]=values[1];
      #if DIMENSIONS==3
      _F[2][16]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void lapse(const tarch::la::Vector<3,double>& values) {
      _F[0][16]=values[0];
      _F[1][16]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void lapse(double v0,double v1,double v2) {
      _F[0][16]=v0;
      _F[1][16]=v1;
      #if DIMENSIONS==3
      _F[2][16]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void lapse(double v0,double v1) {
      _F[0][16]=v0;
      _F[1][16]=v1;
    }
    #endif

    double& shift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][17+row];
    }

    void shift(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][17+row]=values[0];
      _F[1][17+row]=values[1];
      #if DIMENSIONS==2
      _F[2][17+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void shift(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][17+row]=values[0];
      _F[1][17+row]=values[1];
    }
    #endif

    void shift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][17]=values(0,0);
      _F[0][18]=values(1,0);
      _F[0][19]=values(2,0);
      _F[1][17]=values(0,1);
      _F[1][18]=values(1,1);
      _F[1][19]=values(2,1);
      #if DIMENSIONS==3
      _F[2][17]=values(0,2);
      _F[2][18]=values(1,2);
      _F[2][19]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void shift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][17]=values(0,0);
      _F[0][18]=values(1,0);
      _F[0][19]=values(2,0);
      _F[1][17]=values(0,1);
      _F[1][18]=values(1,1);
      _F[1][19]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void shift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][17+row]=v0;
      _F[1][17+row]=v1;
      #if DIMENSIONS==3
      _F[2][17+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void shift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][17+row]=v0;
      _F[1][17+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void shift(double v00, double v01, double v02,
               double v10, double v11, double v12,
               double v20, double v21, double v22) {
      _F[0][17]=v00;
      _F[0][18]=v10;
      _F[0][19]=v20;
      _F[1][17]=v01;
      _F[1][18]=v11;
      _F[1][19]=v21;
      #if DIMENSIONS==3
      _F[2][17]=v02;
      _F[2][18]=v12;
      _F[2][19]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void shift(double v00, double v01,
               double v10, double v11,
               double v20, double v21) {
      _F[0][17]=v00;
      _F[0][18]=v10;
      _F[0][19]=v20;
      _F[1][17]=v01;
      _F[1][18]=v11;
      _F[1][19]=v21;
    }
    #endif

    double& b(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][20+row];
    }

    void b(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][20+row]=values[0];
      _F[1][20+row]=values[1];
      #if DIMENSIONS==2
      _F[2][20+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void b(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][20+row]=values[0];
      _F[1][20+row]=values[1];
    }
    #endif

    void b(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][20]=values(0,0);
      _F[0][21]=values(1,0);
      _F[0][22]=values(2,0);
      _F[1][20]=values(0,1);
      _F[1][21]=values(1,1);
      _F[1][22]=values(2,1);
      #if DIMENSIONS==3
      _F[2][20]=values(0,2);
      _F[2][21]=values(1,2);
      _F[2][22]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void b(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][20]=values(0,0);
      _F[0][21]=values(1,0);
      _F[0][22]=values(2,0);
      _F[1][20]=values(0,1);
      _F[1][21]=values(1,1);
      _F[1][22]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void b(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][20+row]=v0;
      _F[1][20+row]=v1;
      #if DIMENSIONS==3
      _F[2][20+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void b(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][20+row]=v0;
      _F[1][20+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void b(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22) {
      _F[0][20]=v00;
      _F[0][21]=v10;
      _F[0][22]=v20;
      _F[1][20]=v01;
      _F[1][21]=v11;
      _F[1][22]=v21;
      #if DIMENSIONS==3
      _F[2][20]=v02;
      _F[2][21]=v12;
      _F[2][22]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void b(double v00, double v01,
           double v10, double v11,
           double v20, double v21) {
      _F[0][20]=v00;
      _F[0][21]=v10;
      _F[0][22]=v20;
      _F[1][20]=v01;
      _F[1][21]=v11;
      _F[1][22]=v21;
    }
    #endif

    double& dLapse(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][23+row];
    }

    void dLapse(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][23+row]=values[0];
      _F[1][23+row]=values[1];
      #if DIMENSIONS==2
      _F[2][23+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void dLapse(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][23+row]=values[0];
      _F[1][23+row]=values[1];
    }
    #endif

    void dLapse(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][23]=values(0,0);
      _F[0][24]=values(1,0);
      _F[0][25]=values(2,0);
      _F[1][23]=values(0,1);
      _F[1][24]=values(1,1);
      _F[1][25]=values(2,1);
      #if DIMENSIONS==3
      _F[2][23]=values(0,2);
      _F[2][24]=values(1,2);
      _F[2][25]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void dLapse(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][23]=values(0,0);
      _F[0][24]=values(1,0);
      _F[0][25]=values(2,0);
      _F[1][23]=values(0,1);
      _F[1][24]=values(1,1);
      _F[1][25]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void dLapse(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][23+row]=v0;
      _F[1][23+row]=v1;
      #if DIMENSIONS==3
      _F[2][23+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void dLapse(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][23+row]=v0;
      _F[1][23+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void dLapse(double v00, double v01, double v02,
                double v10, double v11, double v12,
                double v20, double v21, double v22) {
      _F[0][23]=v00;
      _F[0][24]=v10;
      _F[0][25]=v20;
      _F[1][23]=v01;
      _F[1][24]=v11;
      _F[1][25]=v21;
      #if DIMENSIONS==3
      _F[2][23]=v02;
      _F[2][24]=v12;
      _F[2][25]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void dLapse(double v00, double v01,
                double v10, double v11,
                double v20, double v21) {
      _F[0][23]=v00;
      _F[0][24]=v10;
      _F[0][25]=v20;
      _F[1][23]=v01;
      _F[1][24]=v11;
      _F[1][25]=v21;
    }
    #endif

    double& dxShift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][26+row];
    }

    void dxShift(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][26+row]=values[0];
      _F[1][26+row]=values[1];
      #if DIMENSIONS==2
      _F[2][26+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void dxShift(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][26+row]=values[0];
      _F[1][26+row]=values[1];
    }
    #endif

    void dxShift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][26]=values(0,0);
      _F[0][27]=values(1,0);
      _F[0][28]=values(2,0);
      _F[1][26]=values(0,1);
      _F[1][27]=values(1,1);
      _F[1][28]=values(2,1);
      #if DIMENSIONS==3
      _F[2][26]=values(0,2);
      _F[2][27]=values(1,2);
      _F[2][28]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void dxShift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][26]=values(0,0);
      _F[0][27]=values(1,0);
      _F[0][28]=values(2,0);
      _F[1][26]=values(0,1);
      _F[1][27]=values(1,1);
      _F[1][28]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void dxShift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][26+row]=v0;
      _F[1][26+row]=v1;
      #if DIMENSIONS==3
      _F[2][26+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void dxShift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][26+row]=v0;
      _F[1][26+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void dxShift(double v00, double v01, double v02,
                 double v10, double v11, double v12,
                 double v20, double v21, double v22) {
      _F[0][26]=v00;
      _F[0][27]=v10;
      _F[0][28]=v20;
      _F[1][26]=v01;
      _F[1][27]=v11;
      _F[1][28]=v21;
      #if DIMENSIONS==3
      _F[2][26]=v02;
      _F[2][27]=v12;
      _F[2][28]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void dxShift(double v00, double v01,
                 double v10, double v11,
                 double v20, double v21) {
      _F[0][26]=v00;
      _F[0][27]=v10;
      _F[0][28]=v20;
      _F[1][26]=v01;
      _F[1][27]=v11;
      _F[1][28]=v21;
    }
    #endif

    double& dyShift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][29+row];
    }

    void dyShift(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][29+row]=values[0];
      _F[1][29+row]=values[1];
      #if DIMENSIONS==2
      _F[2][29+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void dyShift(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][29+row]=values[0];
      _F[1][29+row]=values[1];
    }
    #endif

    void dyShift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][29]=values(0,0);
      _F[0][30]=values(1,0);
      _F[0][31]=values(2,0);
      _F[1][29]=values(0,1);
      _F[1][30]=values(1,1);
      _F[1][31]=values(2,1);
      #if DIMENSIONS==3
      _F[2][29]=values(0,2);
      _F[2][30]=values(1,2);
      _F[2][31]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void dyShift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][29]=values(0,0);
      _F[0][30]=values(1,0);
      _F[0][31]=values(2,0);
      _F[1][29]=values(0,1);
      _F[1][30]=values(1,1);
      _F[1][31]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void dyShift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][29+row]=v0;
      _F[1][29+row]=v1;
      #if DIMENSIONS==3
      _F[2][29+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void dyShift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][29+row]=v0;
      _F[1][29+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void dyShift(double v00, double v01, double v02,
                 double v10, double v11, double v12,
                 double v20, double v21, double v22) {
      _F[0][29]=v00;
      _F[0][30]=v10;
      _F[0][31]=v20;
      _F[1][29]=v01;
      _F[1][30]=v11;
      _F[1][31]=v21;
      #if DIMENSIONS==3
      _F[2][29]=v02;
      _F[2][30]=v12;
      _F[2][31]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void dyShift(double v00, double v01,
                 double v10, double v11,
                 double v20, double v21) {
      _F[0][29]=v00;
      _F[0][30]=v10;
      _F[0][31]=v20;
      _F[1][29]=v01;
      _F[1][30]=v11;
      _F[1][31]=v21;
    }
    #endif

    double& dzShift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][32+row];
    }

    void dzShift(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][32+row]=values[0];
      _F[1][32+row]=values[1];
      #if DIMENSIONS==2
      _F[2][32+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void dzShift(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][32+row]=values[0];
      _F[1][32+row]=values[1];
    }
    #endif

    void dzShift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][32]=values(0,0);
      _F[0][33]=values(1,0);
      _F[0][34]=values(2,0);
      _F[1][32]=values(0,1);
      _F[1][33]=values(1,1);
      _F[1][34]=values(2,1);
      #if DIMENSIONS==3
      _F[2][32]=values(0,2);
      _F[2][33]=values(1,2);
      _F[2][34]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void dzShift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][32]=values(0,0);
      _F[0][33]=values(1,0);
      _F[0][34]=values(2,0);
      _F[1][32]=values(0,1);
      _F[1][33]=values(1,1);
      _F[1][34]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void dzShift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][32+row]=v0;
      _F[1][32+row]=v1;
      #if DIMENSIONS==3
      _F[2][32+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void dzShift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][32+row]=v0;
      _F[1][32+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void dzShift(double v00, double v01, double v02,
                 double v10, double v11, double v12,
                 double v20, double v21, double v22) {
      _F[0][32]=v00;
      _F[0][33]=v10;
      _F[0][34]=v20;
      _F[1][32]=v01;
      _F[1][33]=v11;
      _F[1][34]=v21;
      #if DIMENSIONS==3
      _F[2][32]=v02;
      _F[2][33]=v12;
      _F[2][34]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void dzShift(double v00, double v01,
                 double v10, double v11,
                 double v20, double v21) {
      _F[0][32]=v00;
      _F[0][33]=v10;
      _F[0][34]=v20;
      _F[1][32]=v01;
      _F[1][33]=v11;
      _F[1][34]=v21;
    }
    #endif

    double& dxG(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][35+row];
    }

    void dxG(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][35+row]=values[0];
      _F[1][35+row]=values[1];
      #if DIMENSIONS==2
      _F[2][35+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void dxG(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][35+row]=values[0];
      _F[1][35+row]=values[1];
    }
    #endif

    void dxG(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][35]=values(0,0);
      _F[0][36]=values(1,0);
      _F[0][37]=values(2,0);
      _F[0][38]=values(3,0);
      _F[0][39]=values(4,0);
      _F[0][40]=values(5,0);
      _F[1][35]=values(0,1);
      _F[1][36]=values(1,1);
      _F[1][37]=values(2,1);
      _F[1][38]=values(3,1);
      _F[1][39]=values(4,1);
      _F[1][40]=values(5,1);
      #if DIMENSIONS==3
      _F[2][35]=values(0,2);
      _F[2][36]=values(1,2);
      _F[2][37]=values(2,2);
      _F[2][38]=values(3,2);
      _F[2][39]=values(4,2);
      _F[2][40]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void dxG(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][35]=values(0,0);
      _F[0][36]=values(1,0);
      _F[0][37]=values(2,0);
      _F[0][38]=values(3,0);
      _F[0][39]=values(4,0);
      _F[0][40]=values(5,0);
      _F[1][35]=values(0,1);
      _F[1][36]=values(1,1);
      _F[1][37]=values(2,1);
      _F[1][38]=values(3,1);
      _F[1][39]=values(4,1);
      _F[1][40]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void dxG(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][35+row]=v0;
      _F[1][35+row]=v1;
      #if DIMENSIONS==3
      _F[2][35+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void dxG(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][35+row]=v0;
      _F[1][35+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void dxG(double v00, double v01, double v02,
             double v10, double v11, double v12,
             double v20, double v21, double v22,
             double v30, double v31, double v32,
             double v40, double v41, double v42,
             double v50, double v51, double v52) {
      _F[0][35]=v00;
      _F[0][36]=v10;
      _F[0][37]=v20;
      _F[0][38]=v30;
      _F[0][39]=v40;
      _F[0][40]=v50;
      _F[1][35]=v01;
      _F[1][36]=v11;
      _F[1][37]=v21;
      _F[1][38]=v31;
      _F[1][39]=v41;
      _F[1][40]=v51;
      #if DIMENSIONS==3
      _F[2][35]=v02;
      _F[2][36]=v12;
      _F[2][37]=v22;
      _F[2][38]=v32;
      _F[2][39]=v42;
      _F[2][40]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void dxG(double v00, double v01,
             double v10, double v11,
             double v20, double v21,
             double v30, double v31,
             double v40, double v41,
             double v50, double v51) {
      _F[0][35]=v00;
      _F[0][36]=v10;
      _F[0][37]=v20;
      _F[0][38]=v30;
      _F[0][39]=v40;
      _F[0][40]=v50;
      _F[1][35]=v01;
      _F[1][36]=v11;
      _F[1][37]=v21;
      _F[1][38]=v31;
      _F[1][39]=v41;
      _F[1][40]=v51;
    }
    #endif

    double& dyG(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][41+row];
    }

    void dyG(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][41+row]=values[0];
      _F[1][41+row]=values[1];
      #if DIMENSIONS==2
      _F[2][41+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void dyG(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][41+row]=values[0];
      _F[1][41+row]=values[1];
    }
    #endif

    void dyG(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][41]=values(0,0);
      _F[0][42]=values(1,0);
      _F[0][43]=values(2,0);
      _F[0][44]=values(3,0);
      _F[0][45]=values(4,0);
      _F[0][46]=values(5,0);
      _F[1][41]=values(0,1);
      _F[1][42]=values(1,1);
      _F[1][43]=values(2,1);
      _F[1][44]=values(3,1);
      _F[1][45]=values(4,1);
      _F[1][46]=values(5,1);
      #if DIMENSIONS==3
      _F[2][41]=values(0,2);
      _F[2][42]=values(1,2);
      _F[2][43]=values(2,2);
      _F[2][44]=values(3,2);
      _F[2][45]=values(4,2);
      _F[2][46]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void dyG(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][41]=values(0,0);
      _F[0][42]=values(1,0);
      _F[0][43]=values(2,0);
      _F[0][44]=values(3,0);
      _F[0][45]=values(4,0);
      _F[0][46]=values(5,0);
      _F[1][41]=values(0,1);
      _F[1][42]=values(1,1);
      _F[1][43]=values(2,1);
      _F[1][44]=values(3,1);
      _F[1][45]=values(4,1);
      _F[1][46]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void dyG(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][41+row]=v0;
      _F[1][41+row]=v1;
      #if DIMENSIONS==3
      _F[2][41+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void dyG(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][41+row]=v0;
      _F[1][41+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void dyG(double v00, double v01, double v02,
             double v10, double v11, double v12,
             double v20, double v21, double v22,
             double v30, double v31, double v32,
             double v40, double v41, double v42,
             double v50, double v51, double v52) {
      _F[0][41]=v00;
      _F[0][42]=v10;
      _F[0][43]=v20;
      _F[0][44]=v30;
      _F[0][45]=v40;
      _F[0][46]=v50;
      _F[1][41]=v01;
      _F[1][42]=v11;
      _F[1][43]=v21;
      _F[1][44]=v31;
      _F[1][45]=v41;
      _F[1][46]=v51;
      #if DIMENSIONS==3
      _F[2][41]=v02;
      _F[2][42]=v12;
      _F[2][43]=v22;
      _F[2][44]=v32;
      _F[2][45]=v42;
      _F[2][46]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void dyG(double v00, double v01,
             double v10, double v11,
             double v20, double v21,
             double v30, double v31,
             double v40, double v41,
             double v50, double v51) {
      _F[0][41]=v00;
      _F[0][42]=v10;
      _F[0][43]=v20;
      _F[0][44]=v30;
      _F[0][45]=v40;
      _F[0][46]=v50;
      _F[1][41]=v01;
      _F[1][42]=v11;
      _F[1][43]=v21;
      _F[1][44]=v31;
      _F[1][45]=v41;
      _F[1][46]=v51;
    }
    #endif

    double& dzG(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][47+row];
    }

    void dzG(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][47+row]=values[0];
      _F[1][47+row]=values[1];
      #if DIMENSIONS==2
      _F[2][47+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void dzG(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][47+row]=values[0];
      _F[1][47+row]=values[1];
    }
    #endif

    void dzG(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][47]=values(0,0);
      _F[0][48]=values(1,0);
      _F[0][49]=values(2,0);
      _F[0][50]=values(3,0);
      _F[0][51]=values(4,0);
      _F[0][52]=values(5,0);
      _F[1][47]=values(0,1);
      _F[1][48]=values(1,1);
      _F[1][49]=values(2,1);
      _F[1][50]=values(3,1);
      _F[1][51]=values(4,1);
      _F[1][52]=values(5,1);
      #if DIMENSIONS==3
      _F[2][47]=values(0,2);
      _F[2][48]=values(1,2);
      _F[2][49]=values(2,2);
      _F[2][50]=values(3,2);
      _F[2][51]=values(4,2);
      _F[2][52]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void dzG(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][47]=values(0,0);
      _F[0][48]=values(1,0);
      _F[0][49]=values(2,0);
      _F[0][50]=values(3,0);
      _F[0][51]=values(4,0);
      _F[0][52]=values(5,0);
      _F[1][47]=values(0,1);
      _F[1][48]=values(1,1);
      _F[1][49]=values(2,1);
      _F[1][50]=values(3,1);
      _F[1][51]=values(4,1);
      _F[1][52]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void dzG(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][47+row]=v0;
      _F[1][47+row]=v1;
      #if DIMENSIONS==3
      _F[2][47+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void dzG(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][47+row]=v0;
      _F[1][47+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void dzG(double v00, double v01, double v02,
             double v10, double v11, double v12,
             double v20, double v21, double v22,
             double v30, double v31, double v32,
             double v40, double v41, double v42,
             double v50, double v51, double v52) {
      _F[0][47]=v00;
      _F[0][48]=v10;
      _F[0][49]=v20;
      _F[0][50]=v30;
      _F[0][51]=v40;
      _F[0][52]=v50;
      _F[1][47]=v01;
      _F[1][48]=v11;
      _F[1][49]=v21;
      _F[1][50]=v31;
      _F[1][51]=v41;
      _F[1][52]=v51;
      #if DIMENSIONS==3
      _F[2][47]=v02;
      _F[2][48]=v12;
      _F[2][49]=v22;
      _F[2][50]=v32;
      _F[2][51]=v42;
      _F[2][52]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void dzG(double v00, double v01,
             double v10, double v11,
             double v20, double v21,
             double v30, double v31,
             double v40, double v41,
             double v50, double v51) {
      _F[0][47]=v00;
      _F[0][48]=v10;
      _F[0][49]=v20;
      _F[0][50]=v30;
      _F[0][51]=v40;
      _F[0][52]=v50;
      _F[1][47]=v01;
      _F[1][48]=v11;
      _F[1][49]=v21;
      _F[1][50]=v31;
      _F[1][51]=v41;
      _F[1][52]=v51;
    }
    #endif

    double& traceK(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][53];
    }

    void traceK(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][53]=values[0];
      _F[1][53]=values[1];
      #if DIMENSIONS==3
      _F[2][53]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void traceK(const tarch::la::Vector<3,double>& values) {
      _F[0][53]=values[0];
      _F[1][53]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void traceK(double v0,double v1,double v2) {
      _F[0][53]=v0;
      _F[1][53]=v1;
      #if DIMENSIONS==3
      _F[2][53]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void traceK(double v0,double v1) {
      _F[0][53]=v0;
      _F[1][53]=v1;
    }
    #endif

    double& phi(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][54];
    }

    void phi(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][54]=values[0];
      _F[1][54]=values[1];
      #if DIMENSIONS==3
      _F[2][54]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void phi(const tarch::la::Vector<3,double>& values) {
      _F[0][54]=values[0];
      _F[1][54]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void phi(double v0,double v1,double v2) {
      _F[0][54]=v0;
      _F[1][54]=v1;
      #if DIMENSIONS==3
      _F[2][54]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void phi(double v0,double v1) {
      _F[0][54]=v0;
      _F[1][54]=v1;
    }
    #endif

    double& P(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][55+row];
    }

    void P(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][55+row]=values[0];
      _F[1][55+row]=values[1];
      #if DIMENSIONS==2
      _F[2][55+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void P(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][55+row]=values[0];
      _F[1][55+row]=values[1];
    }
    #endif

    void P(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][55]=values(0,0);
      _F[0][56]=values(1,0);
      _F[0][57]=values(2,0);
      _F[1][55]=values(0,1);
      _F[1][56]=values(1,1);
      _F[1][57]=values(2,1);
      #if DIMENSIONS==3
      _F[2][55]=values(0,2);
      _F[2][56]=values(1,2);
      _F[2][57]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void P(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][55]=values(0,0);
      _F[0][56]=values(1,0);
      _F[0][57]=values(2,0);
      _F[1][55]=values(0,1);
      _F[1][56]=values(1,1);
      _F[1][57]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void P(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][55+row]=v0;
      _F[1][55+row]=v1;
      #if DIMENSIONS==3
      _F[2][55+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void P(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][55+row]=v0;
      _F[1][55+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void P(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22) {
      _F[0][55]=v00;
      _F[0][56]=v10;
      _F[0][57]=v20;
      _F[1][55]=v01;
      _F[1][56]=v11;
      _F[1][57]=v21;
      #if DIMENSIONS==3
      _F[2][55]=v02;
      _F[2][56]=v12;
      _F[2][57]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void P(double v00, double v01,
           double v10, double v11,
           double v20, double v21) {
      _F[0][55]=v00;
      _F[0][56]=v10;
      _F[0][57]=v20;
      _F[1][55]=v01;
      _F[1][56]=v11;
      _F[1][57]=v21;
    }
    #endif

    double& K0(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][58];
    }

    void K0(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][58]=values[0];
      _F[1][58]=values[1];
      #if DIMENSIONS==3
      _F[2][58]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void K0(const tarch::la::Vector<3,double>& values) {
      _F[0][58]=values[0];
      _F[1][58]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void K0(double v0,double v1,double v2) {
      _F[0][58]=v0;
      _F[1][58]=v1;
      #if DIMENSIONS==3
      _F[2][58]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void K0(double v0,double v1) {
      _F[0][58]=v0;
      _F[1][58]=v1;
    }
    #endif


}; // end of Fluxes

// NamingSchemes:


#endif
