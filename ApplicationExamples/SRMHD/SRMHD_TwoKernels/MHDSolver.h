#ifndef __MHDSolver_CLASS_HEADER__
#define __MHDSolver_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "exahype/solvers/ADERDGSolver.h"


#include "exahype/parser/ParserView.h"

namespace MHDSolver{
  class MHDSolver;
}

class MHDSolver::MHDSolver: public exahype::solvers::ADERDGSolver {
  public:
  	// Sorry for being inconsistent here: While AderDGSolver offers the methods getNumberOfVariables() etc.,
    // in static context they cannot be accessed. Thus the toolkit offers you access to the variables here.
    // Thank you,Toolkit!
    static constexpr int nVar    = 9;
    static constexpr int nParams = 0;
    static constexpr int nDim    = 3;
    static constexpr int order   = 3;
    static constexpr int basisSize   = order+1;
  
    MHDSolver(const double maximumMeshSize,const int maximumMeshDepth,const int haloCells,const int regularisedFineGridLevels,const exahype::solvers::Solver::TimeStepping timeStepping,const int DMPObservables);

    void spaceTimePredictor(double* const lQhbnd,double* const lFhbnd,double** const tempSpaceTimeUnknowns,double** const tempSpaceTimeFluxUnknowns,double* const tempUnknowns,double* const tempFluxUnknowns,double* const tempStateSizedVectors,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt) override; 
    void solutionUpdate(double* const luh,const double* const lduh,const double dt) override;
    void volumeIntegral(double* const lduh,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    void surfaceIntegral(double* const lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    void riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,double* const tempFaceUnknownsArray,double** const tempStateSizedVectors,double** const tempStateSizedSquareMatrices,const double dt,const int normalNonZeroIndex) override;
    void boundaryConditions(double* const fluxOut,double* const stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) override;
    double stableTimeStepSize(const double* const luh,double* const tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    void solutionAdjustment(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) override;
    bool hasToAdjustSolution(const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) override;
    exahype::solvers::Solver::RefinementControl refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) override;
    void faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) override;
    void faceUnknownsRestriction(double* const lQhbndCoarse,double* const lFhbndCoarse,const double* const lQhbndFine,const double* const lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) override;
    void volumeUnknownsProlongation(double* const luhFine,const double* const luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) override;
    void volumeUnknownsRestriction(double* const luhCoarse,const double* const luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) override;

    void init(std::vector<std::string>& cmdlineargs, exahype::parser::ParserView constants) final override;
    void eigenvalues(const double* const Q,const int normalNonZeroIndex,double* const lambda);
    void flux(const double* const Q,double** const F);
    void source(const double* const Q,double* const S);
    void boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut);
    void adjustedSolutionValues(const double* const x,const double w,const double t,const double dt,double* const Q);
    void ncp(const double* const Q,const double* const gradQ,double* const BgradQ);
    void matrixb(const double* const Q,const int normalNonZero,double* const Bn);
};

#endif // __MHDSolver_CLASS_HEADER__