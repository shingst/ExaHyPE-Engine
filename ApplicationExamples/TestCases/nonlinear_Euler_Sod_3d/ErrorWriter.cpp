// This file was generated by the ExaHyPE toolkit.
// It will not be overwritten.
//
//
// ========================
//   www.exahype.eu
// ========================
#include "ErrorWriter.h"

#include "EulerSolver_FV.h"
#include "EulerSolver_ADERDG.h"

#include "kernels/GaussLegendreBasis.h"
#include "kernels/KernelUtils.h"

#include "peano/utils/Loop.h"

#include "tarch/la/VectorOperations.h"

#include <algorithm>

#include <iomanip>

Euler::ErrorWriter::ErrorWriter() : exahype::plotters::LimitingADERDG2UserDefined::LimitingADERDG2UserDefined(){
  // @TODO Please insert your code here.
}

void Euler::ErrorWriter::plotADERDGPatch(
    const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch,
    const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* u,
    double timeStamp) {
  constexpr int numberOfVariables = AbstractEulerSolver_ADERDG::NumberOfVariables;
  constexpr int basisSize         = AbstractEulerSolver_ADERDG::Order+1;
  constexpr int order             = basisSize-1;

  double x[DIMENSIONS];

  kernels::idx4 idx(basisSize,basisSize,basisSize,numberOfVariables);
  dfor(i,basisSize) {
     double w_dV = 1.0;
     for (int d=0; d<DIMENSIONS; d++) {
       x[d]  = offsetOfPatch[d] + sizeOfPatch[d] * kernels::legendre::nodes[order][i(d)];
       w_dV *= sizeOfPatch[d] * kernels::legendre::weights[order][i(d)];
     }

     double uAna[numberOfVariables];
     EulerSolver_ADERDG::referenceSolution(x,timeStamp,uAna);

     const double* uNum = u + idx ( (DIMENSIONS==3) ? i(2) : 0, i(1), i(0), 0);

     for (int v=0; v<numberOfVariables; v++) {
        const double uDiff = std::abs(uNum[v]-uAna[v]);
        errorL2[v]   += uDiff*uDiff * w_dV;
        errorL1[v]   += uDiff * w_dV;
        errorLInf[v]  = std::max( errorLInf[v], uDiff );

        normL1Ana[v]  += std::abs(uAna[v]) * w_dV;
        normL2Ana[v]  += uAna[v] * uAna[v] * w_dV;
        normLInfAna[v] = std::max( normLInfAna[v], std::abs(uAna[v]) );

        // DG Errors
        DGErrorL2[v]   += uDiff*uDiff * w_dV;
        DGErrorL1[v]   += uDiff * w_dV;
        DGErrorLInf[v]  = std::max( DGErrorLInf[v], uDiff );

        DGNormL1Ana[v]  += std::abs(uAna[v]) * w_dV;
        DGNormL2Ana[v]  += uAna[v] * uAna[v] * w_dV;
        DGNormLInfAna[v] = std::max( DGNormLInfAna[v], std::abs(uAna[v]) );
     }
  }
}

void Euler::ErrorWriter::plotFiniteVolumesPatch(
    const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch,
    const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* u,
    double timeStamp) {
  constexpr int numberOfVariables = AbstractEulerSolver_FV::NumberOfVariables;
  constexpr int basisSize         = AbstractEulerSolver_FV::PatchSize;
  constexpr int ghostLayerWidth   = AbstractEulerSolver_FV::GhostLayerWidth;

  double x[DIMENSIONS];

  kernels::idx4 idx(basisSize+2*ghostLayerWidth,basisSize+2*ghostLayerWidth,basisSize+2*ghostLayerWidth,numberOfVariables);
  dfor(i,basisSize) {
     double w_dV = 1.0;
     for (int d=0; d<DIMENSIONS; d++) {
       const double cellSize = sizeOfPatch[d] / basisSize;
       x[d]  = offsetOfPatch[d] + cellSize * (i(d)+0.5);
       w_dV *= cellSize;
     }

     double uAna[numberOfVariables];
     EulerSolver_FV::referenceSolution(x,timeStamp,uAna);

     const double* uNum = u +
         idx ( (DIMENSIONS==3) ? i(2)+ghostLayerWidth : 0, i(1)+ghostLayerWidth, i(0)+ghostLayerWidth, 0);

     for (int v=0; v<numberOfVariables; v++) {
        const double uDiff = std::abs(uNum[v]-uAna[v]);
        errorL2[v]   += uDiff*uDiff * w_dV;
        errorL1[v]   += uDiff * w_dV;
        errorLInf[v]  = std::max( errorLInf[v], uDiff );

        normL1Ana[v]  += std::abs(uAna[v]) * w_dV;
        normL2Ana[v]  += uAna[v] * uAna[v] * w_dV;
        normLInfAna[v] = std::max( normLInfAna[v], std::abs(uAna[v]) );
     }
  }
}

void Euler::ErrorWriter::startPlotting( double time) {
  _timeStamp = time;

  std::fill_n(errorL1,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(errorL2,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(errorLInf,AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  
  std::fill_n(normL1Ana,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(normL2Ana,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(normLInfAna,AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);

  // DG Errors
  std::fill_n(DGErrorL1,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(DGErrorL2,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(DGErrorLInf,AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);

  std::fill_n(DGNormL1Ana,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(DGNormL2Ana,  AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(DGNormLInfAna,AbstractEulerSolver_ADERDG::NumberOfVariables, 0.0);
}

void Euler::ErrorWriter::finishPlotting() {
  constexpr int numberOfVariables = AbstractEulerSolver_ADERDG::NumberOfVariables;

  for (int v=0; v<numberOfVariables; v++) {
    errorL2[v]   = sqrt(errorL2[v]);
    normL2Ana[v] = sqrt(normL2Ana[v]);

    DGErrorL2[v]   = sqrt(DGErrorL2[v]);
    DGNormL2Ana[v] = sqrt(DGNormL2Ana[v]);
  }

  std::cout << "**Errors for limiting ADER-DG solver with order="<<AbstractEulerSolver_ADERDG::Order<<"**" << std::endl;
  std::cout << "t_eval : "<<_timeStamp << std::endl;
  std::cout << "variable     : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << v << ", ";
  }
  std::cout << std::endl;

  std::cout << "absErrorL1   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL1[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "absErrorL2   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL2[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "absErrorLInf : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorLInf[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "relErrorL1   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL1[v]/normL1Ana[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "relErrorL2   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL2[v]/normL2Ana[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "relErrorLInf : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorLInf[v]/normLInfAna[v] << ", ";
  }
  std::cout << std::endl;

  // DG errors
  std::cout << "DGAbsErrorL1   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << DGErrorL1[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "DGAbsErrorL2   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << DGErrorL2[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "DGAbsErrorLInf : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << DGErrorLInf[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "DGRelErrorL1   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << DGErrorL1[v]/DGNormL1Ana[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "DGRelErrorL2   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << DGErrorL2[v]/DGNormL2Ana[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "DGRelErrorLInf : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << DGErrorLInf[v]/DGNormLInfAna[v] << ", ";
  }
  std::cout << std::endl;
}
