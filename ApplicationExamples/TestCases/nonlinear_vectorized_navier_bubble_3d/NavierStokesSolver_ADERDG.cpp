// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include <cmath>
#include <map>
#include <tuple>

#include "NavierStokesSolver_ADERDG.h"
#include "NavierStokesSolver_ADERDG_Variables.h"

//#include "AMR/Criterion.h"

#include "kernels/aderdg/generic/Kernels.h"
#include "kernels/KernelUtils.h"

#ifdef OPT_KERNELS
#include "kernels/NavierStokes_NavierStokesSolver_ADERDG/aderdg/Kernels.h"
#include "kernels/NavierStokes_NavierStokesSolver_ADERDG/aderdg/converter.h"

#endif

#include <iostream>

#include "Scenarios/Atmosphere.h"

#include "SetupHelper.h"

tarch::logging::Log NavierStokes::NavierStokesSolver_ADERDG::_log( "NavierStokes::NavierStokesSolver_ADERDG" );

void NavierStokes::NavierStokesSolver_ADERDG::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  auto parsedConfig = parseConfig(cmdlineargs, constants, NumberOfVariables, NumberOfParameters, NumberOfGlobalObservables);
  ns = std::move(parsedConfig.ns);
  scenarioName = std::move(parsedConfig.scenarioName);
  scenario = std::move(parsedConfig.scenario);
  //amrSettings = std::move(parsedConfig.amrSettings);
  
  std::cout << "q0: " << scenario->getQ0() << std::endl;
  std::cout << "gamma: " << scenario->getGamma() << std::endl;
  std::cout << "molecularDiffusionCoeff: " << scenario->getMolecularDiffusionCoeff() << std::endl;
  std::cout << "gasConstant: " << scenario->getGasConstant() << std::endl;
  std::cout << "useAdvection: " << (scenario->getUseAdvection() ? "Yes":"No") << std::endl;
  
  
}

void NavierStokes::NavierStokesSolver_ADERDG::adjustPointSolution(const double* const x,const double t,const double dt,double* Q) {
  if (tarch::la::equals(t, 0.0)) {
    ns.setHeight(Q, x[DIMENSIONS-1]);
    ns.setBackgroundState(Q, 0.0, 0.0);

    Variables vars(Q);
    scenario->initialValues(x, ns, vars);
    for (int i = 0; i < vars.variables(); ++i) {
      assertion2(std::isfinite(Q[i]), i, Q[i]);
    }
  }

}

void NavierStokes::NavierStokesSolver_ADERDG::algebraicSource(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, double *S) {
  // scenario->source(x, t, ns, Q, S);
  constexpr double gravitation = 9.81;
  
  std::fill_n(S, 5, 0.0);
  S[DIMENSIONS] = (Q[6]-Q[0]) * gravitation;
}

void NavierStokes::NavierStokesSolver_ADERDG::algebraicSource2(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, const double *const P, double *S) {
  // scenario->source(x, t, ns, Q, S);
  constexpr double gravitation = 9.81;
  
  std::fill_n(S, 5, 0.0);
  S[DIMENSIONS] = (P[1]-Q[0]) * gravitation;
}

void NavierStokes::NavierStokesSolver_ADERDG::algebraicSource_vect(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, const double *const P, double *S) {
  constexpr double gravitation = 9.81;
  
  std::fill_n(S, 5*VectStride, 0.0);
  #pragma omp simd
  #pragma vector aligned
  for(int i=0; i<VectLength; i++) {
    S[DIMENSIONS*VectStride+i] = (P[1*VectStride+i]-Q[0*VectStride+i]) * gravitation;
  }
}

void NavierStokes::NavierStokesSolver_ADERDG::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {
  constexpr auto basisSize = Order + 1;
  constexpr auto NumberOfData = NumberOfVariables + NumberOfParameters;

#ifdef OPT_KERNELS
  //constexpr auto NumberOfVariablesPadded = NavierStokes::NavierStokesSolver_ADERDG_kernels::aderdg::getNumberOfVariablePadded();
  //constexpr auto NumberOfDataPadded = NavierStokes::NavierStokesSolver_ADERDG_kernels::aderdg::getNumberOfDataPadded();
  constexpr auto NumberOfVariablesPadded = NumberOfVariables;
  constexpr auto NumberOfDataPadded = NumberOfData;
#else
  constexpr auto NumberOfVariablesPadded = NumberOfVariables;
  constexpr auto NumberOfDataPadded = NumberOfData;
#endif
  constexpr auto gradSize = NumberOfVariables * DIMENSIONS;
  auto gradStateOut = std::array<double, gradSize>{{0.0}};
  kernels::idx2 idxGradQ(DIMENSIONS,NumberOfVariables);

  std::fill_n(fluxOut, NumberOfVariablesPadded, 0.0);
  std::fill_n(stateOut, NumberOfDataPadded, 0.0);

  ns.setHeight(stateOut, x[DIMENSIONS-1]);
  ns.setBackgroundState(stateOut, 0.0, 0.0);
  // Need to reconstruct the background state in this case.
  // Extrapolating does not work!
  assert(!ns.useBackgroundState || scenario->getBoundaryType(faceIndex) ==
      BoundaryType::hydrostaticWall);

  double _F[DIMENSIONS][NumberOfVariables]={0.0};
#if DIMENSIONS == 2
  double* F[2] = {_F[0], _F[1]};
#elif DIMENSIONS == 3
  double* F[3] = {_F[0], _F[1], _F[2]};
#endif

  for (int i = 0; i < NumberOfVariables; i++) {
    assertion2(std::isfinite(stateIn[i]), stateIn[i], i);
  }

  if (scenario->getBoundaryType(faceIndex) == NavierStokes::BoundaryType::analytical) {
    // Integrate over time.
    auto curStateOut = std::array<double, NumberOfVariables>{0.0};
    Variables curVarsOut(curStateOut.data());
    for (int i = 0; i < basisSize; ++i) {
      // TODO(Lukas): Check if we need to reset this data here.
      std::fill(curStateOut.begin(), curStateOut.end(), 0.0);
      std::fill(gradStateOut.begin(), gradStateOut.end(), 0.0);

      const double weight = kernels::legendre::weights[Order][i];
      const double xi = kernels::legendre::nodes[Order][i];
      const double ti = t + xi * dt;

      scenario->analyticalSolution(x, ti, ns, curVarsOut, gradStateOut.data());

      ns.evaluateFlux(curStateOut.data(), gradStateOut.data(), F);

      for (int j = 0; j < NumberOfVariables; ++j) {
        stateOut[j] += weight * curStateOut[j];
        fluxOut[j] += weight * F[normalNonZero][j];
      }

    }
    return;
  }

  assertion(scenario->getBoundaryType(faceIndex) == BoundaryType::wall ||
                 scenario->getBoundaryType(faceIndex) == BoundaryType::hydrostaticWall ||
                 scenario->getBoundaryType(faceIndex) == BoundaryType::movingWall ||
                 scenario->getBoundaryType(faceIndex) == BoundaryType::freeSlipWall);

  // Set no slip wall boundary conditions.
  ReadOnlyVariables varsIn(stateIn);
  Variables varsOut(stateOut);

  // Rho/E extrapolated, velocity mirrored.
  std::copy_n(stateIn, NumberOfVariablesPadded, stateOut);
  // Extrapolate gradient.
  std::copy_n(gradStateIn, gradSize, gradStateOut.data());

  // TODO(Lukas) Are these gradients here correct?
  if (scenario->getBoundaryType(faceIndex) == BoundaryType::freeSlipWall ||
  scenario->getBoundaryType(faceIndex) == BoundaryType::hydrostaticWall) {
    // Normal velocity zero after Riemann.
    varsOut.j(normalNonZero) = -varsIn.j(normalNonZero);
    for (int i = 0; i < DIMENSIONS; ++i) {
      gradStateOut[idxGradQ(i, 1+normalNonZero)] = -gradStateIn[idxGradQ(i, 1+normalNonZero)];
    }
  } else {
    // No-slip
    // All velocities zero after Riemann.
    for (int i = 0; i < DIMENSIONS; ++i) {
      varsOut.j(i) = -varsIn.j(i);
      for (int j = 0; j < DIMENSIONS; ++j) {
        gradStateOut[idxGradQ(j, 1+i)] = -gradStateIn[idxGradQ(j, 1+i)];
      }
    }
  }

  if (scenario->getBoundaryType(faceIndex) == BoundaryType::movingWall) {
    // Wall speed after Riemann solve
    const auto wallSpeed = 1.0;
    varsOut.j(0) = 2 * wallSpeed - varsIn.j(0);
    // TODO(Lukas) Is this gradient correct?
    for (int i = 0; i < DIMENSIONS; ++i) {
      gradStateOut[idxGradQ(i, 0)] += 2 * wallSpeed;
    }
  }

  // We deal with heat conduction by computing the flux at the boundary without heat conduction,
  // To do this, we reconstruct the incoming flux using the extrapolated/time-averaged state/gradient.
  // Note that this incurs an error.
  // The incoming flux is reconstructed in boundaryConditions.

  // Then compute the outgoing flux.
  if (scenario->getBoundaryType(faceIndex) == BoundaryType::hydrostaticWall) {
    // TODO(Lukas): Add support for advection-coupling + hydrostatic flows?
    // We need to reconstruct the temperature gradient here.
    const auto posZ = x[DIMENSIONS-1];

    // In case of flow over a background state that is in hydrostatic equilibrium
    // it becomes necessary to reconstruct the temperature diffusion flux and
    // the energy. Otherwise a small temperature boundary layer forms.
    const double equilibriumTemperatureGradient = computeHydrostaticTemperatureGradient(ns, scenario->getGravity(),
            posZ, scenario->getBackgroundPotentialTemperature());

    // We also need to reconstruct the temperature at the border.
    // This corresponds to a heated wall.
    const auto pressure = computeHydrostaticPressure(ns, scenario->getGravity(),
            posZ, scenario->getBackgroundPotentialTemperature());
    const auto T = potentialTToT(ns, pressure, scenario->getBackgroundPotentialTemperature());
    varsOut.rho() = pressure / (ns.gasConstant * T);

    ns.setBackgroundState(stateOut, varsOut.rho(), pressure);
    if (ns.useGravity) {
      varsOut.E() = ns.evaluateEnergy(varsOut.rho(), pressure, varsOut.j(), ns.getZ(stateIn),
              x[DIMENSIONS-1]);
    } else {
      varsOut.E() = ns.evaluateEnergy(varsOut.rho(), pressure, varsOut.j(), ns.getZ(stateIn));
    }

    // Use no viscous effects and use equilibrium temperature gradient.
    ns.evaluateFlux(stateOut, gradStateOut.data(), F, false, true, equilibriumTemperatureGradient);
  } else {
    ns.evaluateFlux(stateOut, gradStateOut.data(), F);
  }

  std::copy_n(F[normalNonZero], NumberOfVariables, fluxOut);

}

bool NavierStokes::NavierStokesSolver_ADERDG::isPhysicallyAdmissible(
      const double* const solution,
      const double* const observablesMin,const double* const observablesMax,
      const bool wasTroubledInPreviousTimeStep,
      const tarch::la::Vector<DIMENSIONS,double>& center,
      const tarch::la::Vector<DIMENSIONS,double>& dx,
      const double t) const {
  return true;
    // We now need to do a pointwise check for the primitive variables
    // pressure and Z.
    // TODO(Lukas) At least refactor this. And 3D!
  // return false;
#if DIMENSIONS == 2
    constexpr auto basisSize = Order + 1;
    kernels::idx3 idx(basisSize,basisSize,NumberOfVariables);
    for (int i = 0; i < basisSize; ++i) {
      for (int j = 0; j < basisSize; ++j) {
        const double* const Q = solution + idx(i,j,0);
        auto vars = ReadOnlyVariables{Q};
        const auto Zrho = ns.getZ(Q);
        const auto Z = Zrho / vars.rho();
        const auto height = ns.getHeight(Q);
        const auto pressure = ns.evaluatePressure(vars.E(),
                vars.rho(),
                vars.j(),
                Zrho,
                height
                );
        bool isAdvectionTroubled = ns.useAdvection && (Z < 0.0);
        if (vars.rho() <= 0.0 || pressure < 0.0 || isAdvectionTroubled) {
          return false;
        }

        // Surprisingly, this is necessary.
        for (int v = 0; v < NumberOfVariables; v++) {
          if (!std::isfinite(solution[v])) {
            return false;
          }
        }
      }
    }
#else
    // TODO(Lukas) Limiting in 3D!
    std::abort();
#endif

  if (scenarioName != "two-bubbles" ||
    scenarioName != "cosine-bubble") {
    return true;
  }

  // Now also check if TV is too high!
  double data[NumberOfGlobalObservables];
  GlobalObservables curObs(data);
  mapGlobalObservables(curObs,solution,center,dx,t,0); // center/dt unused
  const auto *curObsRaw = curObs.data();
  
  const auto curTv = curObsRaw[0];

  auto gobs = ReadOnlyGlobalObservables(_globalObservables.data());
  const auto *gobsRaw = gobs.data();

  const auto countGlobal = gobsRaw[2];
  const auto meanGlobal  = gobsRaw[0];
  // Merging computes sample variance (Bessel's correction), we need population variance.
  const auto varianceGlobal = ((countGlobal - 1)/countGlobal) * gobsRaw[1];
  const auto stdGlobal = std::sqrt(varianceGlobal);

  const auto factorLimit = 4.0; // TODO: Remove or make configurable.

  const auto hi = meanGlobal + factorLimit * stdGlobal;

  if (curTv > hi) {
    return false;
  }

  return true;
}

void NavierStokes::NavierStokesSolver_ADERDG::mapDiscreteMaximumPrincipleObservables(double* observables,const double* const Q) const {
  if (ns.useAdvection) {
    // TODO(Lukas) Remove this.
    std::fill_n(observables, NumberOfDMPObservables, 0.0);
    assert(NumberOfDMPObservables >= 2);
    observables[0] = Q[0];
    const auto vars = ReadOnlyVariables{Q};
    observables[1] = ns.evaluatePressure(vars.E(),
                                         vars.rho(),
                                         vars.j(),
                                         ns.getZ(Q),
                                         ns.getHeight(Q));
    if (ns.useAdvection) {
      observables[2] = ns.getZ(Q) / Q[0];
    }
  } else if (scenarioName == std::string("two-bubbles")) {
    assert(DIMENSIONS == 2 && NumberOfDMPObservables == 2);
    const auto vars = ReadOnlyVariables{Q};
    const auto pressure = ns.evaluatePressure(vars.E(),
                                         vars.rho(),
                                         vars.j(),
                                         ns.getZ(Q),
                                         ns.getHeight(Q));
    const auto temperature = ns.evaluateTemperature(vars.rho(), pressure);
    const auto potT = ns.evaluatePotentialTemperature(temperature, pressure);
    observables[0] = vars.rho();
    observables[1] = pressure;
    observables[2] = potT;
  }
}


exahype::solvers::Solver::RefinementControl NavierStokes::NavierStokesSolver_ADERDG::refinementCriterion(
    const double* luh,
    const tarch::la::Vector<DIMENSIONS, double>& center,
    const tarch::la::Vector<DIMENSIONS, double>& dx,
    const double t,
    const int level) {
  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void NavierStokes::NavierStokesSolver_ADERDG::eigenvalues(const double* const Q,const int d,double* lambda) {
  ns.evaluateEigenvalues(Q, d, lambda);
}

void NavierStokes::NavierStokesSolver_ADERDG::viscousEigenvalues(const double* const Q,const int d,double* lambda) {
  ns.evaluateDiffusiveEigenvalues(Q, d, lambda);
}

void NavierStokes::NavierStokesSolver_ADERDG::viscousFlux(const double *const Q, const double *const gradQ, double **F) {
  //ns.evaluateFlux(Q, gradQ, F, true);
  
  constexpr double gamma = 1.4;
  constexpr double gravitation = 9.81;
  constexpr double gasConstant = 287.058;
  constexpr double invGasConstant = 1.0 / gasConstant;
  constexpr double c_v = 1.0 / (gamma - 1.0) * gasConstant;
  constexpr double invCv = 1.0 / c_v;
  constexpr double mu = 0.01; // = referenceViscosity
  constexpr double Pr = 0.7;
  constexpr double kappa = 1./Pr * mu * gamma * c_v;
  

  const double invRho = 1.0/Q[0]; // Q(1)/(Q(1)*Q(1)+epsilon)
  const double j2 = Q[1]*Q[1]+Q[2]*Q[2]+Q[3]*Q[3];
  const double p = (gamma-1) * (Q[4] - 0.5 * invRho * j2 - Q[0] * gravitation * Q[5]);

  F[0][0] = Q[1];
  F[0][1] = invRho * Q[1] * Q[1] + (p - Q[7]);
  F[0][2] = invRho * Q[1] * Q[2];
  F[0][3] = invRho * Q[1] * Q[3];
  F[0][4] = invRho * Q[1] * (Q[4] + p);

  F[1][0] = Q[2];
  F[1][1] = invRho * Q[2] * Q[1];
  F[1][2] = invRho * Q[2] * Q[2] + (p - Q[7]);
  F[1][3] = invRho * Q[2] * Q[3];
  F[1][4] = invRho * Q[2] * (Q[4]+p);

  F[2][0] = Q[3];
  F[2][1] = invRho * Q[3] * Q[1];
  F[2][2] = invRho * Q[3] * Q[2];
  F[2][3] = invRho * Q[3] * Q[3] + (p - Q[7]);
  F[2][4] = invRho * Q[3] * (Q[4]+p);


  const double uu = invRho * Q[1];
  const double vv = invRho * Q[2];
  const double ww = invRho * Q[3];


  // Derivatives of velocities:
  const double uux  = invRho * (gradQ[0*5+1] - uu * gradQ[0*5+0]);
  const double vvx  = invRho * (gradQ[0*5+2] - vv * gradQ[0*5+0]);
  const double wwx  = invRho * (gradQ[0*5+3] - ww * gradQ[0*5+0]);

  const double uuy  = invRho * (gradQ[1*5+1] - uu * gradQ[1*5+0]);
  const double vvy  = invRho * (gradQ[1*5+2] - vv * gradQ[1*5+0]);
  const double wwy  = invRho * (gradQ[1*5+3] - ww * gradQ[1*5+0]);

  const double uuz  = invRho * (gradQ[2*5+1] - uu * gradQ[2*5+0]);
  const double vvz  = invRho * (gradQ[2*5+2] - vv * gradQ[2*5+0]);
  const double wwz  = invRho * (gradQ[2*5+3] - ww * gradQ[2*5+0]);


  const double invRho2 = invRho * invRho;
  const double invRho3 = invRho2 * invRho;


  const double dTdW1 = -1 * Q[4] * invRho2 + invRho3 * j2;
  const double dTdW2 = -1 * Q[1] * invRho2;
  const double dTdW3 = -1 * Q[2] * invRho2;
  const double dTdW4 = -1 * Q[3] * invRho2;

  double Tx = invCv * (dTdW1 * gradQ[0*5+0] +
      dTdW2 * gradQ[0*5+1] +
      dTdW3 * gradQ[0*5+2] +
      dTdW4 * gradQ[0*5+3] +
      invRho * gradQ[0*5+4]);

  double Ty = invCv * (dTdW1 * gradQ[1*5+0] +
      dTdW2 * gradQ[1*5+1] +
      dTdW3 * gradQ[1*5+2] +
      dTdW4 * gradQ[1*5+3] +
      invRho * gradQ[1*5+4]);

  double Tz = invCv * (dTdW1 * gradQ[2*5+0] +
      dTdW2 * gradQ[2*5+1] +
      dTdW3 * gradQ[2*5+2] +
      dTdW4 * gradQ[2*5+3] +
      invRho * gradQ[2*5+4]);


  const double divV23 = 2./3. * (uux + vvy + wwz);

  F[0][1] -= mu * (2 * uux - divV23);
  F[0][2] -= mu * (uuy + vvx);
  F[0][3] -= mu * (uuz + wwx);
  F[0][4] -= mu * (2 * uux - divV23) * uu + mu * (uuy + vvx) * vv + mu * (uuz + wwx) * ww;

  F[1][1] -= mu * (uuy + vvx);
  F[1][2] -= mu * (2 * vvy - divV23);
  F[1][3] -= mu * (vvz + wwy);
  F[1][4] -= mu * (uuy + vvx) * uu + mu * (2 * vvy - divV23) * vv + mu * (vvz + wwy) * ww;

  F[2][1] -= mu * (uuz + wwx);
  F[2][2] -= mu * (vvz + wwy);
  F[2][3] -= mu * (2 * wwz - divV23);
  F[2][4] -= mu * (uuz + wwx) * uu + mu * (vvz + wwy) * vv + mu * (2 * wwz - divV23) * ww;

    // Gravity happens in y direction in 2D and in z direction in 3D
  Tz -= (gravitation * (gamma - 1)) * invGasConstant;

  // Heat flux
  F[0][4] -= kappa * Tx;
  F[1][4] -= kappa * Ty;
  F[2][4] -= kappa * Tz;
}


void NavierStokes::NavierStokesSolver_ADERDG::viscousFlux2(const double *const Q, const double *const P, const double *const *const gradQ, double **F) {
  constexpr double gamma = 1.4;
  constexpr double gravitation = 9.81;
  constexpr double gasConstant = 287.058;
  constexpr double invGasConstant = 1.0 / gasConstant;
  constexpr double c_v = 1.0 / (gamma - 1.0) * gasConstant;
  constexpr double invCv = 1.0 / c_v;
  constexpr double mu = 0.01; // = referenceViscosity
  constexpr double Pr = 0.7;
  constexpr double kappa = 1./Pr * mu * gamma * c_v;
  

  const double invRho = 1.0/Q[0]; // Q(1)/(Q(1)*Q(1)+epsilon)
  const double j2 = Q[1]*Q[1]+Q[2]*Q[2]+Q[3]*Q[3];
  const double p = (gamma-1) * (Q[4] - 0.5 * invRho * j2 - Q[0] * gravitation * P[0]);

  F[0][0] = Q[1];
  F[0][1] = invRho * Q[1] * Q[1] + (p - P[2]);
  F[0][2] = invRho * Q[1] * Q[2];
  F[0][3] = invRho * Q[1] * Q[3];
  F[0][4] = invRho * Q[1] * (Q[4] + p);

  F[1][0] = Q[2];
  F[1][1] = invRho * Q[2] * Q[1];
  F[1][2] = invRho * Q[2] * Q[2] + (p - P[2]);
  F[1][3] = invRho * Q[2] * Q[3];
  F[1][4] = invRho * Q[2] * (Q[4]+p);

  F[2][0] = Q[3];
  F[2][1] = invRho * Q[3] * Q[1];
  F[2][2] = invRho * Q[3] * Q[2];
  F[2][3] = invRho * Q[3] * Q[3] + (p - P[2]);
  F[2][4] = invRho * Q[3] * (Q[4]+p);


  const double uu = invRho * Q[1];
  const double vv = invRho * Q[2];
  const double ww = invRho * Q[3];


  // Derivatives of velocities:
  const double uux  = invRho * (gradQ[0][1] - uu * gradQ[0][0]);
  const double vvx  = invRho * (gradQ[0][2] - vv * gradQ[0][0]);
  const double wwx  = invRho * (gradQ[0][3] - ww * gradQ[0][0]);

  const double uuy  = invRho * (gradQ[1][1] - uu * gradQ[1][0]);
  const double vvy  = invRho * (gradQ[1][2] - vv * gradQ[1][0]);
  const double wwy  = invRho * (gradQ[1][3] - ww * gradQ[1][0]);

  const double uuz  = invRho * (gradQ[2][1] - uu * gradQ[2][0]);
  const double vvz  = invRho * (gradQ[2][2] - vv * gradQ[2][0]);
  const double wwz  = invRho * (gradQ[2][3] - ww * gradQ[2][0]);


  const double invRho2 = invRho * invRho;
  const double invRho3 = invRho2 * invRho;


  const double dTdW1 = -1 * Q[4] * invRho2 + invRho3 * j2;
  const double dTdW2 = -1 * Q[1] * invRho2;
  const double dTdW3 = -1 * Q[2] * invRho2;
  const double dTdW4 = -1 * Q[3] * invRho2;

  double Tx = invCv * (dTdW1 * gradQ[0][0] +
      dTdW2 * gradQ[0][1] +
      dTdW3 * gradQ[0][2] +
      dTdW4 * gradQ[0][3] +
      invRho * gradQ[0][4]);

  double Ty = invCv * (dTdW1 * gradQ[1][0] +
      dTdW2 * gradQ[1][1] +
      dTdW3 * gradQ[1][2] +
      dTdW4 * gradQ[1][3] +
      invRho * gradQ[1][4]);

  double Tz = invCv * (dTdW1 * gradQ[2][0] +
      dTdW2 * gradQ[2][1] +
      dTdW3 * gradQ[2][2] +
      dTdW4 * gradQ[2][3] +
      invRho * gradQ[2][4]);


  const double divV23 = 2./3. * (uux + vvy + wwz);

  F[0][1] -= mu * (2 * uux - divV23);
  F[0][2] -= mu * (uuy + vvx);
  F[0][3] -= mu * (uuz + wwx);
  F[0][4] -= mu * (2 * uux - divV23) * uu + mu * (uuy + vvx) * vv + mu * (uuz + wwx) * ww;

  F[1][1] -= mu * (uuy + vvx);
  F[1][2] -= mu * (2 * vvy - divV23);
  F[1][3] -= mu * (vvz + wwy);
  F[1][4] -= mu * (uuy + vvx) * uu + mu * (2 * vvy - divV23) * vv + mu * (vvz + wwy) * ww;

  F[2][1] -= mu * (uuz + wwx);
  F[2][2] -= mu * (vvz + wwy);
  F[2][3] -= mu * (2 * wwz - divV23);
  F[2][4] -= mu * (uuz + wwx) * uu + mu * (vvz + wwy) * vv + mu * (2 * wwz - divV23) * ww;

    // Gravity happens in y direction in 2D and in z direction in 3D
  Tz -= (gravitation * (gamma - 1)) * invGasConstant;

  // Heat flux
  F[0][4] -= kappa * Tx;
  F[1][4] -= kappa * Ty;
  F[2][4] -= kappa * Tz;
}


void NavierStokes::NavierStokesSolver_ADERDG::viscousFlux_vect(const double *const Q, const double *const P, const double *const *const gradQ, double **F) {
  
  constexpr double gamma = 1.4;
  constexpr double gravitation = 9.81;
  constexpr double gasConstant = 287.058;
  constexpr double invGasConstant = 1.0 / gasConstant;
  constexpr double c_v = 1.0 / (gamma - 1.0) * gasConstant;
  constexpr double invCv = 1.0 / c_v;
  constexpr double mu = 0.01; // = referenceViscosity
  constexpr double Pr = 0.7;
  constexpr double kappa = 1./Pr * mu * gamma * c_v;
  
  //std::fill_n(F[0], 5*VectStride, 0.0);
  //std::fill_n(F[1], 5*VectStride, 0.0);
  //std::fill_n(F[2], 5*VectStride, 0.0);
  
  // for stability p needs to be computed exactly
  double pp[VectStride] __attribute__((aligned(ALIGNMENT)));
  #pragma omp simd
  #pragma vector aligned
  for(int i=0; i<VectLength; i++) {
    pp[i] = (gamma-1.0) * (Q[4*VectStride+i] - 0.5 / Q[0*VectStride+i] * (Q[1*VectStride+i]*Q[1*VectStride+i]+Q[2*VectStride+i]*Q[2*VectStride+i]+Q[3*VectStride+i]*Q[3*VectStride+i]) - Q[0*VectStride+i] * gravitation * P[0*VectStride+i]);
  }
  
  #pragma omp simd
  #pragma vector aligned
  for(int i=0; i<VectLength; i++) {

    const double invRho = 1.0/Q[0*VectStride+i]; // Q(1)/(Q(1)*Q(1)+epsilon)
    //const double p = (gamma-1) * (Q[4*VectStride+i] - 0.5 * invRho * j2 - Q[0*VectStride+i] * gravitation * P[0*VectStride+i]);

    F[0][0*VectStride+i] = Q[1*VectStride+i];
    F[0][1*VectStride+i] = invRho * Q[1*VectStride+i] * Q[1*VectStride+i] + (pp[i] - P[2*VectStride+i]);
    F[0][2*VectStride+i] = invRho * Q[1*VectStride+i] * Q[2*VectStride+i];
    F[0][3*VectStride+i] = invRho * Q[1*VectStride+i] * Q[3*VectStride+i];
    F[0][4*VectStride+i] = invRho * Q[1*VectStride+i] * (Q[4*VectStride+i] + pp[i]);

    F[1][0*VectStride+i] = Q[2*VectStride+i];
    F[1][1*VectStride+i] = invRho * Q[2*VectStride+i] * Q[1*VectStride+i];
    F[1][2*VectStride+i] = invRho * Q[2*VectStride+i] * Q[2*VectStride+i] + (pp[i] - P[2*VectStride+i]);
    F[1][3*VectStride+i] = invRho * Q[2*VectStride+i] * Q[3*VectStride+i];
    F[1][4*VectStride+i] = invRho * Q[2*VectStride+i] * (Q[4*VectStride+i]+pp[i]);

    F[2][0*VectStride+i] = Q[3*VectStride+i];
    F[2][1*VectStride+i] = invRho * Q[3*VectStride+i] * Q[1*VectStride+i];
    F[2][2*VectStride+i] = invRho * Q[3*VectStride+i] * Q[2*VectStride+i];
    F[2][3*VectStride+i] = invRho * Q[3*VectStride+i] * Q[3*VectStride+i] + (pp[i] - P[2*VectStride+i]);
    F[2][4*VectStride+i] = invRho * Q[3*VectStride+i] * (Q[4*VectStride+i]+pp[i]);


    const double uu = invRho * Q[1*VectStride+i];
    const double vv = invRho * Q[2*VectStride+i];
    const double ww = invRho * Q[3*VectStride+i];


    // Derivatives of velocities:
    const double uux  = invRho * (gradQ[0][1*VectStride+i] - uu * gradQ[0][0*VectStride+i]);
    const double vvx  = invRho * (gradQ[0][2*VectStride+i] - vv * gradQ[0][0*VectStride+i]);
    const double wwx  = invRho * (gradQ[0][3*VectStride+i] - ww * gradQ[0][0*VectStride+i]);

    const double uuy  = invRho * (gradQ[1][1*VectStride+i] - uu * gradQ[1][0*VectStride+i]);
    const double vvy  = invRho * (gradQ[1][2*VectStride+i] - vv * gradQ[1][0*VectStride+i]);
    const double wwy  = invRho * (gradQ[1][3*VectStride+i] - ww * gradQ[1][0*VectStride+i]);

    const double uuz  = invRho * (gradQ[2][1*VectStride+i] - uu * gradQ[2][0*VectStride+i]);
    const double vvz  = invRho * (gradQ[2][2*VectStride+i] - vv * gradQ[2][0*VectStride+i]);
    const double wwz  = invRho * (gradQ[2][3*VectStride+i] - ww * gradQ[2][0*VectStride+i]);


    const double invRho2 = invRho * invRho;
    const double invRho3 = invRho2 * invRho;


    const double dTdW1 = -1 * Q[4*VectStride+i] * invRho2 + invRho3 * Q[1*VectStride+i]*Q[1*VectStride+i]+Q[2*VectStride+i]*Q[2*VectStride+i]+Q[3*VectStride+i]*Q[3*VectStride+i];
    const double dTdW2 = -1 * Q[1*VectStride+i] * invRho2;
    const double dTdW3 = -1 * Q[2*VectStride+i] * invRho2;
    const double dTdW4 = -1 * Q[3*VectStride+i] * invRho2;

    double Tx = invCv * (dTdW1 * gradQ[0][0*VectStride+i] +
        dTdW2 * gradQ[0][1*VectStride+i] +
        dTdW3 * gradQ[0][2*VectStride+i] +
        dTdW4 * gradQ[0][3*VectStride+i] +
        invRho * gradQ[0][4*VectStride+i]);

    double Ty = invCv * (dTdW1 * gradQ[1][0*VectStride+i] +
        dTdW2 * gradQ[1][1*VectStride+i] +
        dTdW3 * gradQ[1][2*VectStride+i] +
        dTdW4 * gradQ[1][3*VectStride+i] +
        invRho * gradQ[1][4*VectStride+i]);

    double Tz = invCv * (dTdW1 * gradQ[2][0*VectStride+i] +
        dTdW2 * gradQ[2][1*VectStride+i] +
        dTdW3 * gradQ[2][2*VectStride+i] +
        dTdW4 * gradQ[2][3*VectStride+i] +
        invRho * gradQ[2][4*VectStride+i]);


    const double divV23 = 2./3. * (uux + vvy + wwz);

    F[0][1*VectStride+i] -= mu * (2 * uux - divV23);
    F[0][2*VectStride+i] -= mu * (uuy + vvx);
    F[0][3*VectStride+i] -= mu * (uuz + wwx);
    F[0][4*VectStride+i] -= mu * (2 * uux - divV23) * uu + mu * (uuy + vvx) * vv + mu * (uuz + wwx) * ww;

    F[1][1*VectStride+i] -= mu * (uuy + vvx);
    F[1][2*VectStride+i] -= mu * (2 * vvy - divV23);
    F[1][3*VectStride+i] -= mu * (vvz + wwy);
    F[1][4*VectStride+i] -= mu * (uuy + vvx) * uu + mu * (2 * vvy - divV23) * vv + mu * (vvz + wwy) * ww;

    F[2][1*VectStride+i] -= mu * (uuz + wwx);
    F[2][2*VectStride+i] -= mu * (vvz + wwy);
    F[2][3*VectStride+i] -= mu * (2 * wwz - divV23);
    F[2][4*VectStride+i] -= mu * (uuz + wwx) * uu + mu * (vvz + wwy) * vv + mu * (2 * wwz - divV23) * ww;

      // Gravity happens in y direction in 2D and in z direction in 3D
    Tz -= (gravitation * (gamma - 1)) * invGasConstant;

    // Heat flux
    F[0][4*VectStride+i] -= kappa * Tx;
    F[1][4*VectStride+i] -= kappa * Ty;
    F[2][4*VectStride+i] -= kappa * Tz;
  }
}



void NavierStokes::NavierStokesSolver_ADERDG::boundaryConditions( double* const fluxIn, const double* const stateIn, const double* const gradStateIn, const double* const luh, const tarch::la::Vector<DIMENSIONS, double>& cellCentre, const tarch::la::Vector<DIMENSIONS,double>&  cellSize, const double t,const double dt, const int direction, const int orientation) {

#ifdef OPT_KERNELS
  double stateOut[NavierStokes::NavierStokesSolver_ADERDG_kernels::aderdg::getBndFaceSize()] __attribute__((aligned(ALIGNMENT))) = {0.0};
  double fluxOut[ NavierStokes::NavierStokesSolver_ADERDG_kernels::aderdg::getBndFluxSize()] __attribute__((aligned(ALIGNMENT))) = {0.0};
  const int faceIndex = 2*direction+orientation;

  NavierStokes::NavierStokesSolver_ADERDG_kernels::aderdg::boundaryConditions(*static_cast<NavierStokesSolver_ADERDG*>(this), fluxOut, stateOut, fluxIn, stateIn, gradStateIn, &cellCentre[0], &cellSize[0], t, dt, faceIndex, direction);


  if (orientation == 0) {
    riemannSolver(fluxOut,fluxIn,stateOut,stateIn,t,dt,cellSize,direction,true,faceIndex);
  }
  else {
    riemannSolver(fluxIn,fluxOut,stateIn,stateOut,t,dt,cellSize,direction,true,faceIndex);
  }

  // TODO(Lukas): Support non hydrostatic wall bcs for opt. kernels

#else // OPT_KERNELS

 #if DIMENSIONS == 2
  constexpr int basisSize     = (Order+1);
#else
  constexpr int basisSize     = (Order+1) * (Order+1);
#endif
  constexpr int sizeStateOut = (NumberOfVariables+NumberOfParameters)*basisSize;
  constexpr int sizeFluxOut  = NumberOfVariables*basisSize;

  constexpr int totalSize = sizeStateOut + sizeFluxOut;
  double* block = new double[totalSize];

  double* memory = block;

  double* stateOut = memory; memory+=sizeStateOut;
  double* fluxOut  = memory; memory+=sizeFluxOut;

  const int faceIndex = 2*direction+orientation;

  kernels::aderdg::generic::c::boundaryConditions<true, NavierStokesSolver_ADERDG>(*static_cast<NavierStokesSolver_ADERDG*>(this),fluxOut,stateOut,fluxIn,stateIn,gradStateIn, cellCentre,cellSize,t,dt,faceIndex,direction);

  if (orientation==0) {
    double* FL = fluxOut; const double* const QL = stateOut;
    double* FR =  fluxIn;  const double* const QR = stateIn;

    riemannSolver(FL,FR,QL,QR,t,dt,cellSize,direction,true,faceIndex);
  }
  else {
    double* FL =  fluxIn;  const double* const QL = stateIn;
    double* FR = fluxOut; const double* const QR = stateOut;

    riemannSolver(FL,FR,QL,QR,t,dt,cellSize,direction,true,faceIndex);
  }

  if (scenario->getBoundaryType(faceIndex) == NavierStokes::BoundaryType::wall ||
      scenario->getBoundaryType(faceIndex) == NavierStokes::BoundaryType::freeSlipWall ||
      scenario->getBoundaryType(faceIndex) == NavierStokes::BoundaryType::movingWall) {
#if DIMENSIONS == 2
    kernels::idx2 idx_F(Order + 1, NumberOfVariables);
    for (int i = 0; i < (Order + 1); ++i) {
      // Set energy flux to zero!
      fluxIn[idx_F(i, NavierStokesSolver_ADERDG_Variables::shortcuts::E)] = 0.0;
      //ns.setZ(fluxIn + idx_F(i, 0), 0.0);
    }
#else
   // TODO(Lukas) Is this correct for 3D? Untested!
    kernels::idx3 idx_F(Order + 1, Order + 1, NumberOfVariables);
    for (int i = 0; i < (Order + 1); ++i) {
      for (int j = 0; j < (Order + 1); ++j) {
        // Set energy flux to zero!
        fluxIn[idx_F(i, j, NavierStokesSolver_ADERDG_Variables::shortcuts::E)] = 0.0;
      }
    }
#endif // DIMENSIONS == 2
  }

  delete[] block;

#endif // OPT_KERNELS

  
}



double NavierStokes::NavierStokesSolver_ADERDG::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellSize) {
  #ifdef OPT_KERNELS
  double dt = NavierStokes::NavierStokesSolver_ADERDG_kernels::aderdg::stableTimeStepSize(*static_cast<NavierStokesSolver_ADERDG*>(this), luh, 1./cellSize[0] );
  #else
  double dt = kernels::aderdg::generic::c::stableTimeStepSize<NavierStokesSolver_ADERDG,true>(*static_cast<NavierStokesSolver_ADERDG*>(this),luh,cellSize);
  #endif
  
  return (0.7/0.9) * dt;
}

void NavierStokes::NavierStokesSolver_ADERDG::riemannSolver(double* FL_,double* FR_,const double* const QL_,const double* const QR_,const double t, const double dt, const tarch::la::Vector<DIMENSIONS, double>& cellSize, const int direction, bool isBoundaryFace, int faceIndex) {
  // The optimised Riemann solver is broken for some reason, use normal one instead.
#ifdef OPT_KERNELS
  using namespace NavierStokes::NavierStokesSolver_ADERDG_kernels::aderdg;
  double FL[converter::getFFaceGenArraySize()];
  double FR[converter::getFFaceGenArraySize()];
  double QL[converter::getQFaceGenArraySize()];
  double QR[converter::getQFaceGenArraySize()];
  
  converter::FFace_optimised2generic(FL_,FL);
  converter::FFace_optimised2generic(FR_,FR);
  converter::QFace_optimised2generic(QL_,QL);
  converter::QFace_optimised2generic(QR_,QR);
#else
  double* FL=FL_;
  double* FR=FR_;
  const double* QL=QL_;
  const double* QR=QR_;
#endif

  kernels::aderdg::generic::c::riemannSolverNonlinear<false,true, NavierStokesSolver_ADERDG>(*static_cast<NavierStokesSolver_ADERDG*>(this),FL,FR,QL,QR,t,dt,cellSize,direction);
  
#ifdef OPT_KERNELS
  converter::FFace_generic2optimised(FL,FL_);
  converter::FFace_generic2optimised(FR,FR_);
#endif 
}
double ** NavierStokes::NavierStokesSolver_ADERDG::weights = kernels::legendre::weights;
