// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "MaxwellSolver.h"

#include "MaxwellSolver_Variables.h"
#include "kernels/GaussLegendreBasis.h"
#include <cstring> // memset
#include "kernels/KernelUtils.h" // matrix indexing

tarch::logging::Log Maxwell::MaxwellSolver::_log( "Maxwell::MaxwellSolver" );

void cavityProblem(double* const Q, const double* const x, const double t){
    //epsilon and mu
    Q[6] = 1.0;
    Q[7] = 1.0;
    //E
    Q[0] = std::cos(t) * (-1)*std::cos(M_PI*x[0])*std::sin(M_PI*x[1])*std::sin(M_PI*x[2]);
    Q[1] = 0.0;
    Q[2] = std::cos(t) * std::sin(M_PI*x[0])*std::sin(M_PI*x[1])*std::cos(M_PI*x[2]);
    //H
    double mult = std::sqrt(Q[6]/3/Q[7])*std::sin(t);
    Q[3] = - mult* std::sin(M_PI*x[0])*std::cos(M_PI*x[1])*std::cos(M_PI*x[2]);
    Q[4] = 2*mult* std::cos(M_PI*x[0])*std::sin(M_PI*x[1])*std::cos(M_PI*x[2]);
    Q[5] = - mult* std::cos(M_PI*x[0])*std::cos(M_PI*x[1])*std::sin(M_PI*x[2]);

}

void Maxwell::MaxwellSolver::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
}

void Maxwell::MaxwellSolver::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 6 + 0
  // @todo Please implement/augment if required
  if (tarch::la::equals(t,0.0)) {
    cavityProblem(Q,x,0.0);
  }
}

void Maxwell::MaxwellSolver::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,
  const double * const fluxIn,const double* const stateIn,
  double* const fluxOut,double* const stateOut) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 6 + 0
    constexpr int nVar = Maxwell::AbstractMaxwellSolver::NumberOfVariables;
    constexpr int order = Maxwell::AbstractMaxwellSolver::Order;
    constexpr int basisSize = order + 1;
    constexpr int nDim = DIMENSIONS;

  double Qgp[nVar];
  std::memset(stateOut, 0, nVar * sizeof(double));
  std::memset(fluxOut, 0,  nVar * sizeof(double));

  double** F = new double *[nDim];
  for (int i=0;i<nDim;i++) F[i]=new double[nVar];

  for(int i=0; i < basisSize; i++)  { // i == time
     const double weight = kernels::legendre::weights[order][i];
     const double xi = kernels::legendre::nodes[order][i];
     const double ti = t + xi * dt;

     cavityProblem(Qgp, x, ti);
     Maxwell::MaxwellSolver::flux(Qgp, F);
     for(int m=0; m < nVar; m++) {
        stateOut[m] += weight * Qgp[m];
        fluxOut[m] += weight * F[normalNonZero][m];
     }
  }
  // Exact boundary conditions
}

exahype::solvers::Solver::RefinementControl Maxwell::MaxwellSolver::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) {
  // @todo Please implement/augment if required
  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void Maxwell::MaxwellSolver::eigenvalues(const double* const Q,const int d,double* const lambda) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 6 + 0
  lambda[0] =  std::sqrt(Q[6]*Q[7]);
  lambda[1] = -std::sqrt(Q[6]*Q[7]);
  lambda[2] =  std::sqrt(Q[6]*Q[7]);
  lambda[3] = -std::sqrt(Q[6]*Q[7]);
  lambda[4] = 0.0;
  lambda[5] = 0.0;
}





void Maxwell::MaxwellSolver::flux(const double* const Q,double** const F) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 6 + 0
  double Hx = Q[0];
  double Hy = Q[1];
  double Hz = Q[2];
  double Ex = Q[3];
  double Ey = Q[4];
  double Ez = Q[5];

  F[0][0] =  0.0;
  F[0][1] =  Hz;
  F[0][2] = -Hy;
  F[0][3] =  0.0;
  F[0][4] = -Ez;
  F[0][5] =  Ey;
  F[0][6] = Q[6];
  F[0][7] = Q[7];
  
  F[1][0] = -Hz;
  F[1][1] =  0.0;
  F[1][2] =  Hx;
  F[1][3] =  Ez;
  F[1][4] = 0.0;
  F[1][5] = -Ex;
  F[1][6] = Q[6];
  F[1][7] = Q[7];
  
  F[2][0] =  Hy;
  F[2][1] = -Hx;
  F[2][2] = 0.0;
  F[2][3] = -Ey;
  F[2][4] =  Ex;
  F[2][5] = 0.0;
  F[2][6] = Q[6];
  F[2][7] = Q[7];
  
}


void Maxwell::MaxwellSolver::multiplyMaterialParameterMatrix(const double* const Q, double* const rhs){
    //identity for now
    //later multiply with mu and epsilon
    double epsilon = Q[6];
    double mu = Q[7];

    constexpr int nDim = DIMENSIONS;
    for(int i = 0; i < nDim; i++){
        for(int j = 0; j < 3; j++){
            rhs[i*6+j] *= epsilon;
            rhs[i*6+j+3] *= mu;
        }
    }
}

