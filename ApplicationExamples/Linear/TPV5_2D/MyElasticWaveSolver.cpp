// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "MyElasticWaveSolver.h"

#include "MyElasticWaveSolver_Variables.h"

#include <algorithm>
#include "kernels/KernelUtils.h"
#include "kernels/DGMatrices.h"
#if defined(_GLL)
#include "kernels/GaussLobattoQuadrature.h"
#else
#include "kernels/GaussLegendreQuadrature.h"
#endif


tarch::logging::Log Elastic::MyElasticWaveSolver::_log( "Elastic::MyElasticWaveSolver" );


void Elastic::MyElasticWaveSolver::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  // @todo Please implement/augment if required

  //initPointSourceLocations(cmdlineargs,constants);
  initPointSourceLocations();
  double fault_position= 40.0/27*(27-1)*0.5;
  
  //transformation = new CurvilinearTransformation(MyElasticWaveSolver::Order+1,
  //						 _coarsestMeshLevel, fault_position,
  //						 &_domainOffset[0],
  //						 &_domainSize[0]);  
}

void Elastic::MyElasticWaveSolver::adjustSolution(double* const luh, const tarch::la::Vector<DIMENSIONS,double>& center, const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
  // Dimensions                        = 2
  // Number of variables + parameters  = 7 + 10
  // @todo Please implement/augment if required


  int level=std::round(log(_domainSize[0]/dx[0])/log(3.)) + 1;

  if (tarch::la::equals(t,0.0)) {
    constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
    constexpr int basisSize = MyElasticWaveSolver::Order+1;
    int numberOfData=MyElasticWaveSolver::NumberOfParameters+MyElasticWaveSolver::NumberOfVariables;

    kernels::idx3 id_xyf(basisSize,basisSize,numberOfData);
    kernels::idx2 id_xy(basisSize,basisSize);

    constexpr int num_nodes=MyElasticWaveSolver::Order+1;

    double gl_vals_x[num_nodes*num_nodes];
    double gl_vals_y[num_nodes*num_nodes];
   

    double jacobian[num_nodes*num_nodes];
    double q_x[num_nodes*num_nodes];
    double q_y[num_nodes*num_nodes];
   
  
    double r_x[num_nodes*num_nodes];
    double r_y[num_nodes*num_nodes];

    double offset_x=center[0]-0.5*dx[0];
    double offset_y=center[1]-0.5*dx[1];

    double width_x=dx[0];
    double width_y=dx[1];

    // if( level <= getCoarsestMeshLevel()){ 
//       //transformation->genCoordinates(center,
//       //                                dx,    
//       //				     gl_vals_x,gl_vals_y,
//       //				     jacobian,
//       //				     q_x,q_y,
//       //				     r_x,r_y);

//       //double x  =  (offset_x+width_x*kernels::gaussLobattoNodes[basisSize-1][basisSize-1-i]);
//       //double y  =  (offset_y+width_y*kernels::gaussLobattoNodes[basisSize-1][basisSize-1-j]);

//      double x  =  (offset_x+width_x*kernels::gaussLegendreNodes[basisSize-1][i]);
//      double y  =  (offset_y+width_y*kernels::gaussLegendreNodes[basisSize-1][j]);
    
      
//     }
    
    //initialise luh
    for (int j=0; j< num_nodes; j++){
      for (int i=0; i< num_nodes; i++){

	double x  =  (offset_x+width_x*kernels::gaussLegendreNodes[basisSize-1][i]);
	double y  =  (offset_y+width_y*kernels::gaussLegendreNodes[basisSize-1][j]);

	// if( level <= getCoarsestMeshLevel()){ 
// 	  double x= gl_vals_x[id_xy(j,i)];
// 	  double y= gl_vals_y[id_xy(j,i)];

	  
// 	}
	    
	    
	    
	// velocity
	luh[id_xyf(j,i,0)]  = 0; //std::exp(-((x-20)*(x-20) + (y-10)*(y-10))/9);
	luh[id_xyf(j,i,1)]  = 0; //std::exp(-((x-20)*(x-20) + (y-10)*(y-10))/9);
	    
	// stress field
	luh[id_xyf(j,i,2)]  = 0;
	luh[id_xyf(j,i,3)]  = 0;
	luh[id_xyf(j,i,4)]  = 0;
	  

	// displacements
	luh[id_xyf(j,i,5)]  = 0;
	luh[id_xyf(j,i,6)]  = 0;
       
	    
	    
	// material parameters
	luh[id_xyf(j,i,numberOfVariables)]  = 2.670; //rho
	luh[id_xyf(j,i,numberOfVariables+1)] = 6.0; //cp
	luh[id_xyf(j,i,numberOfVariables+2)] = 3.464; //cs
	  
	if( level <= getCoarsestMeshLevel()){ 
	  // Jacobian
	  luh[id_xyf(j,i,numberOfVariables+3)] = 1.0; //jacobian[id_xy(j,i)];
	    
	  // q_x, q_y
	  luh[id_xyf(j,i,numberOfVariables+4)]  = 1.0; //q_x[id_xy(j,i)];
	  luh[id_xyf(j,i,numberOfVariables+5)]  = 0.0; //q_y[id_xy(j,i)];
	    
	    
	  // r_x, r_y
	  luh[id_xyf(j,i,numberOfVariables+6)] = 0.0; //r_x[id_xy(j,i)];
	  luh[id_xyf(j,i,numberOfVariables+7)] = 1.0; //r_y[id_xy(j,i)];
	 
	    
	  // x,y
	  luh[id_xyf(j,i,numberOfVariables+8)] = x; //gl_vals_x[id_xy(j,i)];
	  luh[id_xyf(j,i,numberOfVariables+9)] = y; //gl_vals_y[id_xy(j,i)];
	    
	}
	  
      }
    }
  }
}

void Elastic::MyElasticWaveSolver::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,
						  const double * const fluxIn,const double* const stateIn,
						  double* const fluxOut,double* const stateOut) {
  // Dimensions                        = 2
  // Number of variables + parameters  = 7 + 10

  // @todo Please implement/augment if required
  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  constexpr int numberOfParameters = MyElasticWaveSolver::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables+numberOfParameters;
 

  for (int i = 0; i<numberOfData; i++){
    stateOut[i] = stateIn[i];
  }
 
  for (int i = 0; i< numberOfVariables; i++){
    fluxOut[i] =  fluxIn[i];
  }
  
}

exahype::solvers::Solver::RefinementControl Elastic::MyElasticWaveSolver::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) {
  // @todo Please implement/augment if required
  //return exahype::solvers::Solver::RefinementControl::Keep;

  //if(tarch::la::equals(t,0.0)){
   //  return exahype::solvers::Solver::RefinementControl::Keep;
 //  }
 
  double left_vertex[DIMENSIONS];
  double right_vertex[DIMENSIONS];

  for(int i = 0 ; i<DIMENSIONS; i++){
    left_vertex[i]  = center[i] - dx[i]*0.5;
    right_vertex[i] = center[i] + dx[i]*0.5;
  }

  double fault_position= 40.0/27*(27-1)*0.5;

  double abs_velocity;

  double abs_shear_velocity;

  for(int j =0; j< (Order+1); j++){
    for(int i=0 ; i< (Order+1); i++){
      abs_velocity = 0;
      abs_shear_velocity = 0;
      for(int l=1 ; l< DIMENSIONS; l++){
  	abs_shear_velocity= abs_velocity + luh[i, j, l]*luh[i, j, l];
      }
      abs_shear_velocity = std::sqrt(abs_shear_velocity);

      for(int l=0 ; l< DIMENSIONS; l++){
  	abs_velocity= abs_velocity + luh[i, j, l]*luh[i, j, l];
      }
      abs_velocity = std::sqrt(abs_velocity);
    }
  }



  
  //abs_velocity = 0.1;

  bool elementOnHypocenter = (left_vertex[1] > 6.0) && (right_vertex[1] < 9.0);
  bool elementOnFault =  std::abs(center[0]-fault_position) < 2*dx[0];
  bool elementOnFault_inner =  std::abs(center[0]-fault_position) < dx[0];
  bool FaultSlipping =  abs_shear_velocity >= 0.05;
  bool shaking =  abs_velocity >= 0.25;


   if(tarch::la::equals(t,0.0)){

     //if(elementOnHypocenter && ((level >= getCoarsestMeshLevel()) && (level <= getCoarsestMeshLevel()+1))){
     //  return exahype::solvers::Solver::RefinementControl::Refine;
     //}
     // if(elementOnHypocenter && ((level >= getCoarsestMeshLevel()) && (level <= getCoarsestMeshLevel()+1)) && elementOnFault){
     //   return exahype::solvers::Solver::RefinementControl::Refine;
     // }
     // else{
     // return exahype::solvers::Solver::RefinementControl::Keep;
     // }

     return exahype::solvers::Solver::RefinementControl::Keep;
   }

   if(elementOnHypocenter && ((level >= getCoarsestMeshLevel()) && (level <= getCoarsestMeshLevel()+1)) &&  elementOnFault_inner){
       return exahype::solvers::Solver::RefinementControl::Refine;
     }
  

  if(elementOnFault && (level == getCoarsestMeshLevel() && FaultSlipping)){
    return exahype::solvers::Solver::RefinementControl::Refine;
  }

  if(elementOnFault_inner && (level == getCoarsestMeshLevel()+1 && FaultSlipping)){
    return exahype::solvers::Solver::RefinementControl::Refine;
  }
  else if (level > getCoarsestMeshLevel()){
return exahype::solvers::Solver::RefinementControl::Erase;
}

  if((level == getCoarsestMeshLevel() &&  shaking)){
    return exahype::solvers::Solver::RefinementControl::Refine;
  }
 else if (level > getCoarsestMeshLevel()){
return exahype::solvers::Solver::RefinementControl::Erase;
}
//return exahype::solvers::Solver::RefinementControl::Keep;

  //if(level == getCoarsestMeshLevel() && FaultSlipping){
  //  return exahype::solvers::Solver::RefinementControl::Refine;
  //}

 
  
  
  //return exahype::solvers::Solver::RefinementControl::Keep;
  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void Elastic::MyElasticWaveSolver::eigenvalues(const double* const Q,const int d,double* const lambda) {
  // Dimensions                        = 2
  // Number of variables + parameters  = 7 + 10
  
  // @todo Please implement/augment if required

  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  

  double cp = Q[numberOfVariables+1];
  double cs = Q[numberOfVariables+2];

  double q_x;
  double q_y;
  double r_x;
  double r_y;
  
  extractTransformation(Q,q_x,q_y,r_x,r_y);
   
  lambda[0] = std::sqrt(q_x*q_x + q_y*q_y)*cp;
  lambda[1] = std::sqrt(q_x*q_x + q_y*q_y)*cs;
  lambda[2] = std::sqrt(r_x*r_x + r_y*r_y)*cp;
  lambda[3] = std::sqrt(r_x*r_x + r_y*r_y)*cs;
  
  lambda[4] = 1.0;
  lambda[5] = 1.0;
  lambda[6] = 1.0;
}


void Elastic::MyElasticWaveSolver::flux(const double* const Q,double** const F) {
  // Dimensions                        = 2
  // Number of variables + parameters  = 7 + 10
  
  // @todo Please implement/augment if required

  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;

  double sigma_xx=Q[2];
  double sigma_yy=Q[3];
  double sigma_xy=Q[4];

  double jacobian=Q[numberOfVariables+3];
  double q_x;
  double q_y;
  double r_x;
  double r_y;
  
  extractTransformation(Q,q_x,q_y,r_x,r_y);
  
  F[0][0] = -jacobian*(q_x*sigma_xx+q_y*sigma_xy);
  F[0][1] = -jacobian*(q_x*sigma_xy+q_y*sigma_yy);
  F[0][2] = 0.0;
  F[0][3] = 0.0;
  F[0][4] = 0.0;
  F[0][5] = 0.0;
  F[0][6] = 0.0;

  F[1][0] = -jacobian*(r_x*sigma_xx+r_y*sigma_xy);
  F[1][1] = -jacobian*(r_x*sigma_xy+r_y*sigma_yy);
  F[1][2] = 0.0;
  F[1][3] = 0.0;
  F[1][4] = 0.0;
  F[1][5] = 0.0;
  F[1][6] = 0.0;
  
}


//You can either implement this method or modify fusedSource
void Elastic::MyElasticWaveSolver::algebraicSource(const double* const Q,double* const S) {
  // @todo Please implement/augment if required

  double u = Q[0];
  double v = Q[1];

  S[0] = 0.0;
  S[1] = 0.0;
  S[2] = 0.0;
  S[3] = 0.0;
  S[4] = 0.0;
  S[5] = -u;
  S[6] = -v;
}

void  Elastic::MyElasticWaveSolver::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  // @todo Please implement/augment if required

  double q_x;
  double q_y;
  double r_x;
  double r_y;

  double u_q=gradQ[0];    
  double v_q=gradQ[1];

  double u_r=gradQ[7];
  double v_r=gradQ[8];

  extractTransformation(Q,q_x,q_y,r_x,r_y);
  
  BgradQ[0] = 0;
  BgradQ[1] = 0;
  BgradQ[2] = -q_x*u_q;
  BgradQ[3] = -q_y*v_q;
  BgradQ[4] = -(q_y*u_q+q_x*v_q);
  BgradQ[5] = 0.0;
  BgradQ[6] = 0.0;
  
  BgradQ[7] = 0.0;
  BgradQ[8] = 0.0;
  BgradQ[9] = -r_x*u_r;
  BgradQ[10] = -r_y*v_r;
  BgradQ[11] = -(r_y*u_r+r_x*v_r);
  BgradQ[12] = 0.0;
  BgradQ[13] = 0.0;

}


void  Elastic::MyElasticWaveSolver::initPointSourceLocations(){
  // @todo Please implement/augment if required

 pointSourceLocation[0][0]=0;
 pointSourceLocation[0][1]=0;

}

void  Elastic::MyElasticWaveSolver::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector, int n) {
  // @todo Please implement/augment if required

static tarch::logging::Log _log("MyLinearWaveSolver::pointSource");

 constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  double jacobian = Q[numberOfVariables+3];
  
  double pi = 3.14159265359;
  double sigma = 0.1149;
  double t0 = 0.7;
  double f = 0.0;
  
  double M0 = 0000.0/jacobian;

  if(n == 0){
    
    f = M0*(1.0/(sigma*std::sqrt(2.0*pi)))*(std::exp(-((t-t0)*(t-t0))/(2.0*sigma*sigma)));

    forceVector[0] = 0.0;
    forceVector[1] = 0.0;
    forceVector[2] = 0.0;
    forceVector[3] = 0;
    forceVector[4] = 0;
    forceVector[5] = 0;
    forceVector[6] = 0.0;
  }
  
}

/**
 * @TODO LR : document
 */


void Elastic::MyElasticWaveSolver::multiplyMaterialParameterMatrix(const double* const Q, double* const rhs) {

  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;

  const double rho  = Q[numberOfVariables];   // km/s
  const double cp   = Q[numberOfVariables+1];   // km/s
  const double cs   = Q[numberOfVariables+2];   // km/s
  
  double mu = rho*cs*cs;
  double lam = rho*cp*cp-2.0*mu;
  double rho_jacobian = Q[numberOfVariables+3]*rho;

  rhs[0] = 1.0/rho_jacobian*rhs[0];
  rhs[1] = 1.0/rho_jacobian*rhs[1];
  
  double rhs_2= (2*mu+lam)*rhs[2]+lam*rhs[3];
  double rhs_3= (2*mu+lam)*rhs[3]+lam*rhs[2];
  
  rhs[2]=rhs_2;
  rhs[3]=rhs_3;  

  rhs[4]=mu*rhs[4];

  rhs[5]=rhs[5];
  rhs[6]=rhs[6];  


  rhs[7] = 1.0/rho_jacobian*rhs[7];
  rhs[8] = 1.0/rho_jacobian*rhs[8];
  
  double rhs_7= (2*mu+lam)*rhs[9]+lam*rhs[10];
  double rhs_8= (2*mu+lam)*rhs[10]+lam*rhs[9];
  
  rhs[9]=rhs_7;
  rhs[10]=rhs_8; 
 
  rhs[11]=mu*rhs[11];

  rhs[12]=rhs[12];
  rhs[13]=rhs[13]; 
}


void Elastic::MyElasticWaveSolver::riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double dt,const int normalNonZeroIndex, bool isBoundaryFace, int faceIndex) {
  
  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  constexpr int numberOfVariables2 = numberOfVariables*numberOfVariables;
  constexpr int numberOfParameters = MyElasticWaveSolver::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables+numberOfParameters;
  constexpr int basisSize          = MyElasticWaveSolver::Order+1;
  constexpr int order              = basisSize - 1;
  
  kernels::idx2 idx_QLR(basisSize, numberOfData);
  kernels::idx2 idx_FLR(basisSize, numberOfVariables);
  
  double rho_p,cp_p,cs_p, mu_p,lam_p;
  double rho_m,cp_m,cs_m, mu_m,lam_m;  

  double norm_p_qr, norm_m_qr;

  //check if the face lies on a fault
  double fault_position= 40.0/27*(27-1)*0.5;
  bool is_fault0= true;
  bool is_fault= true;

  //  for (int j = 0; j < basisSize; j++) {
// //     TODO: Change position to static parameter

//      is_fault=is_fault && std::abs(QL[idx_QLR(j,numberOfData-2)] - fault_position) < 1.0e-5; 

//    }
 
  
  double n_p[2]={0,0};
  double n_m[2]={0,0};
  double m_p[2]={0,0};
  double m_m[2]={0,0};
  
  for (int i = 0; i < basisSize; i++) {
    // extract parameters
    rho_m = QL[idx_QLR(i,numberOfVariables)];
    cp_m  = QL[idx_QLR(i,numberOfVariables+1)];
    cs_m  = QL[idx_QLR(i,numberOfVariables+2)];
    mu_m = cs_m*cs_m*rho_m;
    lam_m = cp_m*cp_m*rho_m-2*mu_m;

    // extract parameters
    rho_p = QR[idx_QLR(i,numberOfVariables)];
    cp_p  = QR[idx_QLR(i,numberOfVariables+1)];
    cs_p  = QR[idx_QLR(i,numberOfVariables+2)];
    mu_p = cs_p*cs_p*rho_p;
    lam_p = cp_p*cp_p*rho_p-2*mu_p;
    
    get_normals(normalNonZeroIndex, norm_p_qr, n_p, QR + idx_QLR(i,0));
    get_normals(normalNonZeroIndex, norm_m_qr, n_m, QL + idx_QLR(i,0));    
    
    double Tx_m,Ty_m,vx_m,vy_m;
    double Tx_p,Ty_p,vx_p,vy_p;

    extract_tractions_and_particle_velocity(n_p,QR+idx_QLR(i,0),Tx_p,Ty_p,vx_p,vy_p);
    extract_tractions_and_particle_velocity(n_m,QL+idx_QLR(i,0),Tx_m,Ty_m,vx_m,vy_m); 
    
    localBasis(n_p, m_p);
    localBasis(n_m, m_m);
    
    double Tn_m,Tm_m,vn_m,vm_m;
    double Tn_p,Tm_p,vn_p,vm_p;
    
    // rotate fields into l, m, n basis
    rotate_into_orthogonal_basis(n_m,m_m,Tx_m,Ty_m,Tn_m,Tm_m);
    rotate_into_orthogonal_basis(n_m,m_m,vx_m,vy_m,vn_m,vm_m);
    rotate_into_orthogonal_basis(n_p,m_p,Tx_p,Ty_p,Tn_p,Tm_p);
    rotate_into_orthogonal_basis(n_p,m_p,vx_p,vy_p,vn_p,vm_p);      
    
    // extract local s-wave and p-wave impedances
    double zs_p=rho_p*cs_p;
    double zs_m=rho_m*cs_m;
    double zp_p=rho_p*cp_p;
    double zp_m=rho_m*cp_m;


    // impedance must be greater than zero !
    if (zp_p <= 0.0 || zp_m <= 0.0 || zs_p <= 0.0 || zs_m <= 0.0){
      std::cout<<zs_p<<" "<<zs_m<<" "<<zp_p<<" "<<zp_m<<"\n";
      std::cout<<" Impedance must be greater than zero ! "<< std::endl;
      std::exit(-1);
    }
    
    // generate interface data preserving the amplitude of the outgoing charactertritics
    // and satisfying interface conditions exactly.
    
    double vn_hat_p,vm_hat_p,vn_hat_m,vm_hat_m;        
    double Tn_hat_p,Tm_hat_p,Tn_hat_m,Tm_hat_m;

    double FLn,FLm,FRn,FRm; 
    double FL_n,FL_m,FR_n,FR_m;
    double FLx,FLy,FRx,FRy;
    double FL_x,FL_y,FR_x,FR_y;


    double Sn_m,Sm_m,Sn_p,Sm_p;
    double Sx_m,Sy_m,Sx_p,Sy_p;

    // TODO: Change position to static parameter

    is_fault=is_fault0 && std::abs(QL[idx_QLR(i,numberOfData-2)] - fault_position) < 1.0e-5;

    
    if(is_fault){
      double x[2] = {QR[idx_QLR(i,numberOfData-2)], QR[idx_QLR(i,numberOfData-1)]};
      
      Sx_p = QR[idx_QLR(i,numberOfVariables-2)];
      Sy_p = QR[idx_QLR(i,numberOfVariables-1)];
     
      
      Sx_m = QL[idx_QLR(i,numberOfVariables-2)];
      Sy_m = QL[idx_QLR(i,numberOfVariables-1)];
      
      
      rotate_into_orthogonal_basis(n_m,m_m,Sx_m,Sy_m,Sn_m,Sm_m);
      rotate_into_orthogonal_basis(n_p,m_p,Sx_p,Sy_p,Sn_p,Sm_p);
      
      double S =  std::sqrt((Sm_p- Sm_m)*(Sm_p- Sm_m));
      
      SlipWeakeningFriction(vn_p,vn_m, Tn_p,Tn_m, zp_p, zp_m, 
                            vn_hat_p , vn_hat_m, Tn_hat_p,Tn_hat_m, 
                            vm_p,vm_m, Tm_p,Tm_m, zs_p, zs_m, 
                            vm_hat_p, vm_hat_m, Tm_hat_p,Tm_hat_m,  
                            m_p, n_p, x, S);

      //(double vn_p,double vn_m, double Tn_p, double Tn_m, double zn_p , double zn_m, 
      //                                                   double& vn_hat_p, double& vn_hat_m, double& Tn_hat_p, double& Tn_hat_m, 
      //                                                   double vm_p,double vm_m, double Tm_p, double Tm_m, double zm_p , double zm_m,
      //                                                   double& vm_hat_p, double& vm_hat_m, double& Tm_hat_p, double& Tm_hat_m,  
      // double* const m, double* const n, double* const x,  double S)

      //std::cout << vn_hat_m << "  " << vn_hat_m << "  " << vn_hat_m << " "<< vn_hat_m <<std::endl;
      
      
    }else{
      if (isBoundaryFace) {
	double r= faceIndex==2 ? 1 : 0;
	riemannSolver_boundary(faceIndex,r,vn_m,vm_m,Tn_m,Tm_m,zp_m,zs_m,vn_hat_m,vm_hat_m,Tn_hat_m,Tm_hat_m);
	riemannSolver_boundary(faceIndex,r,vn_p,vm_p,Tn_p,Tm_p,zp_p,zs_p,vn_hat_p,vm_hat_p,Tn_hat_p,Tm_hat_p);
      }else{
	riemannSolver_Nodal(vn_p,vn_m, Tn_p, Tn_m, zp_p , zp_m, vn_hat_p , vn_hat_m, Tn_hat_p, Tn_hat_m);
	riemannSolver_Nodal(vm_p,vm_m, Tm_p, Tm_m, zs_p , zs_m, vm_hat_p , vm_hat_m, Tm_hat_p, Tm_hat_m);
      }
    }
    
    // generate fluctuations in the local basis coordinates: n, m
    generate_fluctuations_left(zp_m,Tn_m,Tn_hat_m,vn_m,vn_hat_m,FLn);
    generate_fluctuations_left(zs_m,Tm_m,Tm_hat_m,vm_m,vm_hat_m,FLm);
    generate_fluctuations_right(zp_p,Tn_p,Tn_hat_p,vn_p,vn_hat_p,FRn);
    generate_fluctuations_right(zs_p,Tm_p,Tm_hat_p,vm_p,vm_hat_p,FRm);

    FL_n = FLn/zp_m;
    if(zs_m > 0){
      FL_m = FLm/zs_m;
    }else{
      FL_m=0;
    }
    
    FR_n = FRn/zp_p;
    if(zs_p > 0){    
      FR_m = FRm/zs_p;
    }else{
      FR_m=0;
    }
    
    // rotate back to the physical coordinates x, y, z
    rotate_into_physical_basis(n_m,m_m,FLn,FLm,FLx,FLy);
    rotate_into_physical_basis(n_p,m_p,FRn,FRm,FRx,FRy);
    rotate_into_physical_basis(n_m,m_m,FL_n,FL_m,FL_x,FL_y);
    rotate_into_physical_basis(n_p,m_p,FR_n,FR_m,FR_x,FR_y);
     
    // construct flux fluctuation vectors obeying the eigen structure of the PDE
    // and choose physically motivated penalties such that we can prove
    // numerical stability.
    
    FR[idx_FLR(i, 0)] = norm_p_qr/rho_p*FRx;
    FL[idx_FLR(i, 0)] = norm_m_qr/rho_m*FLx;
    
    FR[idx_FLR(i, 1)] = norm_p_qr/rho_p*FRy;
    FL[idx_FLR(i, 1)] = norm_m_qr/rho_m*FLy;
    
    FL[idx_FLR(i, 2)] = norm_m_qr*((2*mu_m+lam_m)*n_m[0]*FL_x+lam_m*n_m[1]*FL_y);
    FL[idx_FLR(i, 3)] = norm_m_qr*((2*mu_m+lam_m)*n_m[1]*FL_y+lam_m*n_m[0]*FL_x);
    
    FR[idx_FLR(i, 2)] = -norm_p_qr*((2*mu_p+lam_p)*n_p[0]*FR_x+lam_p*n_p[1]*FR_y);
    FR[idx_FLR(i, 3)] = -norm_p_qr*((2*mu_p+lam_p)*n_p[1]*FR_y+lam_p*n_p[0]*FR_x);
    
    FL[idx_FLR(i, 4)] = norm_m_qr*mu_m*(n_m[1]*FL_x + n_m[0]*FL_y);
    FR[idx_FLR(i, 4)] = -norm_p_qr*mu_p*(n_p[1]*FR_x + n_p[0]*FR_y);

    FL[idx_FLR(i, 5)] = 0;
    FR[idx_FLR(i, 5)] = 0;

    FL[idx_FLR(i, 6)] = 0;
    FR[idx_FLR(i, 6)] = 0;
  }
}


void Elastic::MyElasticWaveSolver::extract_tractions_and_particle_velocity(double* const n,const double* const Q, double& Tx,double& Ty,double& vx,double& vy){

  double sigma_xx = Q[2];
  double sigma_yy = Q[3];
  double sigma_xy = Q[4];
  
  
  Tx = n[0]*sigma_xx + n[1]*sigma_xy;
  Ty = n[0]*sigma_xy + n[1]*sigma_yy;   
  
  vx = Q[0];
  vy = Q[1];   
}

void Elastic::MyElasticWaveSolver::rotate_into_orthogonal_basis(double* const n,double* const m, double Tx,double Ty, double& Tn, double& Tm){
  Tn= Tx*n[0] + Ty*n[1];
  Tm= Tx*m[0] + Ty*m[1];
}

void Elastic::MyElasticWaveSolver::rotate_into_physical_basis(double* const n,double* const m, double Fn,double Fm, double& Fx, double& Fy){

  Fx = n[0]*Fn + m[0]*Fm;
  Fy = n[1]*Fn + m[1]*Fm;
  
}

void Elastic::MyElasticWaveSolver::generate_fluctuations_left(double z,  double T,double T_hat,double v, double v_hat, double& F){
  F = 0.5*(z*(v-v_hat) + (T-T_hat));
}

void Elastic::MyElasticWaveSolver::generate_fluctuations_right(double z,  double T,double T_hat,double v, double v_hat, double& F){
  F = 0.5*(z*(v-v_hat) - (T-T_hat));
}

void Elastic::MyElasticWaveSolver::riemannSolver_boundary(int faceIndex,double r, double vn , double vm, double Tn , double Tm, double zp, double zs , double& vn_hat , double& vm_hat, double& Tn_hat , double& Tm_hat)
{

  if (faceIndex % 2  == 0) {

    riemannSolver_BC0(vn, Tn, zp, r, vn_hat, Tn_hat);
    riemannSolver_BC0(vm, Tm, zs, r, vm_hat, Tm_hat);
  }
      
      
  if (faceIndex % 2 == 1) {

    riemannSolver_BCn(vn, Tn, zp, r, vn_hat, Tn_hat);
    riemannSolver_BCn(vm, Tm, zs, r, vm_hat, Tm_hat);	
  }

}

void Elastic::MyElasticWaveSolver::riemannSolver_BC0(double v, double sigma, double z,  double r, double& v_hat, double& sigma_hat){
  double p = 0.5*(z*v + sigma);

  v_hat = (1+r)/z*p;
  sigma_hat = (1-r)*p;
}

void Elastic::MyElasticWaveSolver::riemannSolver_BCn(double v,double sigma, double z, double r, double& v_hat, double& sigma_hat){
  double q = 0.5*(z*v - sigma);

  v_hat = (1+r)/z*q;
  sigma_hat = -(1-r)*q;
}

void Elastic::MyElasticWaveSolver::riemannSolver_Nodal(double v_p,double v_m, double sigma_p, double sigma_m, double z_p , double z_m, double& v_hat_p , double& v_hat_m, double& sigma_hat_p, double& sigma_hat_m){
  double p=0;
  double q=0;
  double phi=0;
  double v_hat=0;
  double eta=0;

  p=z_m*v_p + sigma_p;
  q=z_p*v_m - sigma_m;

  if(z_p > 0 && z_m > 0){
    eta=(z_p*z_m)/(z_p+z_m);

    phi= eta*(p/z_p - q/z_m);
     
    sigma_hat_p=phi;
    sigma_hat_m=phi;

    v_hat_p=(q+phi)/z_m;     
    v_hat_m=(p-phi)/z_p;
  }else if(z_p > 0){
    sigma_hat_p=0;
    sigma_hat_m=sigma_m;

    v_hat_p=v_p;     
    v_hat_m=v_m;
  }else if(z_m > 0){
    sigma_hat_p=sigma_p;
    sigma_hat_m=0;

    v_hat_p=v_p;     
    v_hat_m=v_m;

  }else{
    sigma_hat_p=sigma_p;
    sigma_hat_m=sigma_m;
     
    v_hat_p=v_p;
    v_hat_m=v_m;     
  }
}


void Elastic::MyElasticWaveSolver::localBasis(double* const n, double* const m){
  m[0] = n[1];
  m[1] = n[0];
}

void Elastic::MyElasticWaveSolver::extractTransformation(const double* const Q, double& q_x,double& q_y,double& r_x,double& r_y) {

  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;

  q_x     =Q[numberOfVariables+4];
  q_y     =Q[NumberOfVariables+5];
  r_x     =Q[NumberOfVariables+6];
  r_y     =Q[NumberOfVariables+7];
}

void Elastic::MyElasticWaveSolver::get_normals(int normalNonZeroIndex,double& norm, double* const n,const double* const Q){
  double q_x;
  double q_y;
  double r_x;
  double r_y;
  
  extractTransformation(Q,q_x,q_y,r_x,r_y);
  if (normalNonZeroIndex == 0){
    norm = std::sqrt(q_x*q_x + q_y*q_y);
    n[0] = q_x/norm;
    n[1] = q_y/norm;
  }
  if (normalNonZeroIndex == 1){
    norm = std::sqrt(r_x*r_x + r_y*r_y);
    n[0] = r_x/norm;
    n[1] = r_y/norm;
  }
}

// Rupture Dynamics
void Elastic::MyElasticWaveSolver::SlipWeakeningFriction(double vn_p,double vn_m, double Tn_p, double Tn_m, double zn_p , double zn_m, 
                                                         double& vn_hat_p, double& vn_hat_m, double& Tn_hat_p, double& Tn_hat_m, 
                                                         double vm_p,double vm_m, double Tm_p, double Tm_m, double zm_p , double zm_m,
                                                         double& vm_hat_p, double& vm_hat_m, double& Tm_hat_p, double& Tm_hat_m,  
                                                         double* const m, double* const n, double* const x,  double S)
{
  // compute characteristics
  double p_m = zm_p*vm_p + Tm_p;
  double p_n = zn_p*vn_p + Tn_p;
  
 
  double q_m = zm_m*vm_m - Tm_m;
  double q_n = zn_m*vn_m - Tn_m;

  // half of the harmonic mean of Z1_s, Z2_s
  double eta_s=(zm_p*zm_m)/(zm_p+zm_m);                                    
  double eta_n=(zn_p*zn_m)/(zn_p+zn_m); 
  
  double  phi_m= eta_s*(p_m/zm_p - q_m/zm_m);
  double  phi_n= eta_n*(p_n/zn_p - q_n/zn_m);
    
  double T0_m=0;
  double T0_n=0;

  // get prestress (where normal traction is effective normal traction)
  prestress(T0_n, T0_m, x, 0.0, m, n);

  vn_hat_m = (p_n - phi_n)/zn_p;   //! continuity of normal velocity
  Tn_hat_m = phi_n;                //! continuity of normal stress
  vn_hat_p = (q_n + phi_n)/zn_m;   //! continuity of normal velocity
  Tn_hat_p = phi_n;

  double tau_lock = std::sqrt(std::pow(T0_m + phi_m, 2));
  double sigma_n = std::max(0.0, -(T0_n + phi_n));   // including prestress
  double tau_str;
  double Vel = 0.0;
  double Tl, Tm, vv_l, vv_m; 

  TauStrength(tau_str, sigma_n, S, x, 0.0);

  double fault_position= 40.0/27*(27-1)*0.5;

  double r = std::sqrt((x[0]-fault_position)*(x[0]-fault_position) + (x[1]-7.5)*(x[1]-7.5));

  
  
  if (tau_lock >= tau_str){
    slip_weakening(vv_m, Vel, Tm, phi_m+T0_m, eta_s, tau_str, sigma_n);

    Tm_hat_m = Tm - T0_m;

    Tm_hat_p = Tm - T0_m;

    //std::cout << tau_str << " " << tau_lock << " " << Tm -T0_m<< " " << vv_m << std::endl;
    
  }else{
    Tm_hat_m = phi_m;

    Tm_hat_p = phi_m;
       
    vv_m = 0.0;
    
    Vel = 0.0;
  }
   
  vm_hat_p = (Tm_hat_m + q_m)/zm_m + vv_m;
    
  vm_hat_m = (p_m - Tm_hat_p)/zm_p - vv_m;


  // if (r <= 0.1){

//     std::cout << tau_str << " " << tau_lock << " " << Tm -T0_m<< " " << vv_m << std::endl;
//   }

  
}


 // solve for slip-rate (vv):  
void Elastic::MyElasticWaveSolver::slip_weakening(double& v1, double& Vel, double& tau1,
								double phi_1, double eta, double tau_str, double sigma_n){
  
  double Phi = std::abs(phi_1);   // stress-transfer functional
  Vel = (Phi - tau_str)/eta;                    // slip-rate

  //compute slip velocities
  v1 = phi_1/(eta+tau_str/Vel);
  
  //compute shear stress on the fault
  tau1 = phi_1 - eta*v1;

  //std::cout << tau_str << " " << Phi << " " << tau1 << " " << v1 << std::endl;
  
}

void Elastic::MyElasticWaveSolver::TauStrength(double& tau_str, double sigma_n, double S, double* const x, double t)
{
  // TPV5
  double mu_s = 0.677;                          // stastic friction
  double mu_d = 0.525;                          // dynamic friction
  double sigma0 = 120.0;                        // normal stress
  double S_c = 0.40;                            // critical slip

  double fy;
  double fz;
  
  boxcar(fy, x[1],15.0);

  mu_s = mu_s + 1e10*(1.0-fy);
  double fric_coeff = mu_s - (mu_s-mu_d) * std::min(S,S_c)/S_c;     // friction coefficient
  tau_str = fric_coeff*sigma_n;     
  

  // // TPV28:
  // double mu_s = 0.677;                          // stastic friction
  // double mu_d = 0.373;                          // dynamic friction
  // double S_c = 0.40;      
  // critical slip

  // double fy;
  // double fz;
  
  // boxcar(fy, x[1]-7.5,15.0);
  // boxcar(fz, x[2]-15.0,15.0);

  // mu_s = mu_s + 1e10*(1.0-fy*fz);
  // double fric_coeff = mu_s - (mu_s-mu_d) * std::min(S,S_c)/S_c;     // friction coefficient
  // tau_str = fric_coeff*sigma_n; 
  
}


void Elastic::MyElasticWaveSolver::prestress(double& T0_n, double& T0_m, double* const x, double t, double* const m, double* const n)
{

  double sxx,syy,szz,sxy,sxz, syz;
  double Tx,Ty,Tz;

  // initial stress tensor
  initialstresstensor(sxx,syy,sxy, x);

  // extract tractions in xyz coordinates
  extract_tractions(sxx, syy, sxy, n, Tx,Ty);

  // rotate tractions into local orthogonal coordinates
  rotate_into_orthogonal_basis(n,m,Tx,Ty,T0_n,T0_m);
   
  //TPV5:
  double fy;
  //
 

  boxcar(fy, x[1]-7.5,  1.5);
  
  //
  T0_m = T0_m+11.6   *fy;




  // //====================================
  // //TPV28:
  // //====================================

  // // initial stress tensor
  // initialstresstensor(sxx,syy,szz,sxy,sxz, syz, x);


  // // extract tractions in xyz coordinates
  // extract_tractions(sxx, syy, szz, sxy, sxz, syz, n, Tx,Ty,Tz);

  // // rotate tractions into local orthogonal coordinates
  // rotate_into_orthogonal_basis(n,m,l,Tx,Ty,Tz,T0_n,T0_m,T0_l);

  // double r;
  // double tau_nuke;
  // double pi = 3.14159265359;

  // r = std::sqrt((x[1]-7.5)*(x[1]-7.5) + (x[2]-15)*(x[2]-15));

  // if (r <= 1.4){
  //   tau_nuke = 11.60;
  // }
  // else if(r >= 1.4 && r<=2.0) {
  //   tau_nuke = 5.8*(1.0 + std::cos(pi*(r-1.4)/0.6));
  // }
  // else{
  //   tau_nuke = 0.0;
  // }

  // T0_l = T0_l + tau_nuke;
    
}

double Elastic::MyElasticWaveSolver::boxcar(double& f, double x, double w) 
{
  // f(x) is boxcar of unit amplitude in (x-w,x+w)
  double tol = 1e-8;
 
  if ((-w+tol)<x && x< (w-tol)){    // inside
    f = 1.0;
    //std::cout<< x << "  " << w <<std::endl;
  }
  else if (std::abs(-w-x)<=tol || std::abs(x-w)<=tol){     // boundary
    f = 0.5;
  }
  else{    // outside
    f = 0.0;
  }
  return f;
}


void Elastic::MyElasticWaveSolver::extract_tractions(double sxx, double syy, double sxy, double* const n, double& Tx,double& Ty){
  
  Tx = n[0]*sxx + n[1]*sxy;
  Ty = n[0]*sxy + n[1]*syy;
      
}
void Elastic::MyElasticWaveSolver::initialstresstensor(double& sxx, double& syy, double& sxy, double* const x)
{
  // TPV5:
  sxx = -120.0;
  syy = 0.0;
  
  sxy =  70.0;
  

  // // TPV28:
  // sxx = -60;
  // syy = 0.0;
  // szz = 60.0;
  
  // sxy = 0.0;
  // sxz = 29.380;
  // syz = 0.00;
 
}
