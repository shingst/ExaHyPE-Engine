// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "MyElasticWaveSolver.h"

#include "MyElasticWaveSolver_Variables.h"


tarch::logging::Log Elastic::MyElasticWaveSolver::_log( "Elastic::MyElasticWaveSolver" );


void Elastic::MyElasticWaveSolver::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  // @todo Please implement/augment if required

  initPointSourceLocations();

  //double fault_position=1.0/3.0 * _domainSize[0] + _domainOffset[0]; // fault has no effect
  double fault_position= 50.0/27*26*0.5;
  transformation = new CurvilinearTransformation(MyElasticWaveSolver::Order+1,
						 _coarsestMeshLevel, fault_position,
						 &_domainOffset[0],
						 &_domainSize[0]);
}

void Elastic::MyElasticWaveSolver::adjustSolution(double* const luh, const tarch::la::Vector<DIMENSIONS,double>& center, const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 12 + 16
  // @todo Please implement/augment if required

   int level=std::round(log(_domainSize[0]/dx[0])/log(3.)) + 1;
  

   //std::cout << level <<std::endl;
   
  if (tarch::la::equals(t,0.0)) {
    constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
    constexpr int basisSize = MyElasticWaveSolver::Order+1;
    int numberOfData=MyElasticWaveSolver::NumberOfParameters+MyElasticWaveSolver::NumberOfVariables;

    kernels::idx4 id_xyzf(basisSize,basisSize,basisSize,numberOfData);
    kernels::idx3 id_xyz(basisSize,basisSize,basisSize);

    constexpr int num_nodes=MyElasticWaveSolver::Order+1;

    double gl_vals_x[num_nodes*num_nodes*num_nodes];
    double gl_vals_y[num_nodes*num_nodes*num_nodes];
    double gl_vals_z[num_nodes*num_nodes*num_nodes];

    double jacobian[num_nodes*num_nodes*num_nodes];
    double q_x[num_nodes*num_nodes*num_nodes];
    double q_y[num_nodes*num_nodes*num_nodes];
    double q_z[num_nodes*num_nodes*num_nodes];
  
    double r_x[num_nodes*num_nodes*num_nodes];
    double r_y[num_nodes*num_nodes*num_nodes];
    double r_z[num_nodes*num_nodes*num_nodes];

    double s_x[num_nodes*num_nodes*num_nodes];
    double s_y[num_nodes*num_nodes*num_nodes];
    double s_z[num_nodes*num_nodes*num_nodes];

    double offset_x=center[0]-0.5*dx[0];


    if( level <= getCoarsestMeshLevel()){ 
      transformation->genCoordinates(center,
				     dx,    
				     gl_vals_x,gl_vals_y,gl_vals_z,
				     jacobian,
				     q_x,q_y,q_z,
				     r_x,r_y,r_z,
				     s_x,s_y,s_z);
      
    }

    double xx;
    for (int k=0; k< num_nodes; k++){
      for (int j=0; j< num_nodes; j++){
	for (int i=0; i< num_nodes; i++){

	  if( level <= getCoarsestMeshLevel()){ 
	    double x= gl_vals_x[id_xyz(k,j,i)];
	    double y= gl_vals_y[id_xyz(k,j,i)];
	    double z= gl_vals_z[id_xyz(k,j,i)];

	    
	  }
	    
	    
	    
	  // velocity
	  luh[id_xyzf(k,j,i,0)]  = 0;
	  luh[id_xyzf(k,j,i,1)]  = 0;
	  luh[id_xyzf(k,j,i,2)]  = 0;
	    
	  // stress field
	  luh[id_xyzf(k,j,i,3)]  = 0;
	  luh[id_xyzf(k,j,i,4)]  = 0;
	  luh[id_xyzf(k,j,i,5)]  = 0;
	  luh[id_xyzf(k,j,i,6)]  = 0;
	  luh[id_xyzf(k,j,i,7)]  = 0;
	  luh[id_xyzf(k,j,i,8)]  = 0;

	  // displacements
	  luh[id_xyzf(k,j,i,9)]   = 0;
	  luh[id_xyzf(k,j,i,10)]  = 0;
	  luh[id_xyzf(k,j,i,11)]  = 0;
	    
	    
	  // material parameters
	  luh[id_xyzf(k,j,i,numberOfVariables)]  = 2.670; //rho
	  luh[id_xyzf(k,j,i,numberOfVariables+1)] = 6.0; //cp
	  luh[id_xyzf(k,j,i,numberOfVariables+2)] = 3.464; //cs
	  
	  if( level <= getCoarsestMeshLevel()){ 
	    // Jacobian
	    luh[id_xyzf(k,j,i,numberOfVariables+3)] = jacobian[id_xyz(k,j,i)];

	    
	    // x-cartesian
	    xx  =  (offset_x+dx[0]*kernels::gaussLegendreNodes[basisSize-1][i]);
	    luh[id_xyzf(k,j,i,numberOfVariables+4)] = xx;
	    
	    // q_x, q_y, q_z
	    luh[id_xyzf(k,j,i,numberOfVariables+5)]  = q_x[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+6)]  = q_y[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+7)]  = q_z[id_xyz(k,j,i)];
	    
	    // r_x, r_y, r_z
	    luh[id_xyzf(k,j,i,numberOfVariables+8)] = r_x[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+9)] = r_y[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+10)] = r_z[id_xyz(k,j,i)];
	    
	    // s_x, s_y, s_z
	    luh[id_xyzf(k,j,i,numberOfVariables+11)] = s_x[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+12)] = s_y[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+13)] = s_z[id_xyz(k,j,i)];
	    
	    // x,y,z
	    luh[id_xyzf(k,j,i,numberOfVariables+14)] = gl_vals_x[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+15)] = gl_vals_y[id_xyz(k,j,i)];
	    luh[id_xyzf(k,j,i,numberOfVariables+16)] = gl_vals_z[id_xyz(k,j,i)];
	  }
	  //	  std::cout << std::endl;
	  //	  std::cout << luh[id_xyzf(k,j,i,22)] << std::endl;
	  //	  std::cout << luh[id_xyzf(k,j,i,23)] << std::endl;
	  //	  std::cout << luh[id_xyzf(k,j,i,24)] << std::endl;
	}
      }
    }
  }
}

void Elastic::MyElasticWaveSolver::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,
  const double * const fluxIn,const double* const stateIn,
  double* const fluxOut,double* const stateOut) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 12 + 16

  // @todo Please implement/augment if required
  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  constexpr int numberOfParameters = MyElasticWaveSolver::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables+numberOfParameters;

  for (int i = 0; i<numberOfData; i++){
    stateOut[i] = stateIn[i];
  }
 
  for (int i = 0; i< numberOfVariables; i++){
  fluxOut[i] =  fluxIn[i];
  }
}

exahype::solvers::Solver::RefinementControl Elastic::MyElasticWaveSolver::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) {
  // @todo Please implement/augment if required
 if(!tarch::la::equals(t,0.0)){
    return exahype::solvers::Solver::RefinementControl::Keep;
  }
 
  double left_vertex[3];
  double right_vertex[3];

  for(int i = 0 ; i<DIMENSIONS; i++){
    left_vertex[i]  = center[i] - dx[i]*0.5;
    right_vertex[i] = center[i] + dx[i]*0.5;
  }

  bool elementOnSurface=left_vertex[1] < 2*dx[0];
  double fault_position= 50.0/27*26*0.5;
  bool elementOnFault =  std::abs(center[0]-fault_position) < 2*dx[0];

  if(elementOnFault && (level == getCoarsestMeshLevel())){
    return exahype::solvers::Solver::RefinementControl::Refine;
  }

  // if(elementOnSurface && (level == getCoarsestMeshLevel())){
  //   return exahype::solvers::Solver::RefinementControl::Refine;
  // }

  //bool pointSourceInElement= false; //true;

  //for(int i = 0 ; i<DIMENSIONS; i++){
  //  pointSourceInElement &= ((left_vertex[i] <= pointSourceLocation[0][i]) && (right_vertex[i] >= pointSourceLocation[0][i]));
  //}
  
  // if(pointSourceInElement){
  //   return exahype::solvers::Solver::RefinementControl::Refine;
  // }

  /*  for(int k ; k< (Order+1); k++){
    for(int j ; j< (Order+1); j++){
      for(int i ; i< (Order+1); i++){
  	double abs_velocity=sqrt(luh[]);
      }
    }
  }*/
  
  //return exahype::solvers::Solver::RefinementControl::Keep;
  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void Elastic::MyElasticWaveSolver::eigenvalues(const double* const Q,const int d,double* const lambda) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 12 + 16
  
  // @todo Please implement/augment if required
   constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  double cp = Q[numberOfVariables+1];
  double cs = Q[numberOfVariables+2];

  double q_x;
  double q_y;
  double q_z;  
  double r_x;
  double r_y;
  double r_z;
  double s_x;
  double s_y;
  double s_z;  
  
  extractTransformation(Q,q_x,q_y,q_z,r_x,r_y,r_z,s_x,s_y,s_z);
   
  lambda[0] = std::sqrt(q_x*q_x + q_y*q_y + q_z*q_z)*cp;
  lambda[1] = std::sqrt(q_x*q_x + q_y*q_y + q_z*q_z)*cs;
  lambda[2] = std::sqrt(q_x*q_x + q_y*q_y + q_z*q_z)*cs;
  
  lambda[3] = std::sqrt(r_x*r_x + r_y*r_y + r_z*r_z)*cp;
  lambda[4] = std::sqrt(r_x*r_x + r_y*r_y + r_z*r_z)*cs;
  lambda[5] = std::sqrt(r_x*r_x + r_y*r_y + r_z*r_z)*cs;
  
  lambda[6] = std::sqrt(s_x*s_x + s_y*s_y + s_z*s_z)*cp;
  lambda[7] = std::sqrt(s_x*s_x + s_y*s_y + s_z*s_z)*cs;
  lambda[8] = std::sqrt(s_x*s_x + s_y*s_y + s_z*s_z)*cs;
 
  lambda[9] =  1.0;
  lambda[10] = 1.0;
  lambda[11] = 1.0;
}


void Elastic::MyElasticWaveSolver::flux(const double* const Q,double** const F) {
  // Dimensions                        = 3
  // Number of variables + parameters  = 12 + 16
  
  // @todo Please implement/augment if required
   constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  
  double sigma_xx=Q[3];
  double sigma_yy=Q[4];
  double sigma_zz=Q[5];  
  double sigma_xy=Q[6];
  double sigma_xz=Q[7];
  double sigma_yz=Q[8];

  double jacobian=Q[numberOfVariables+3];

  double q_x;
  double q_y;
  double q_z;  
  double r_x;
  double r_y;
  double r_z;
  double s_x;
  double s_y;
  double s_z;  
  
  extractTransformation(Q,q_x,q_y,q_z,r_x,r_y,r_z,s_x,s_y,s_z);

  
  F[0][ 0] = -jacobian*(q_x*sigma_xx+q_y*sigma_xy+q_z*sigma_xz);
  F[0][ 1] = -jacobian*(q_x*sigma_xy+q_y*sigma_yy+q_z*sigma_yz);
  F[0][ 2] = -jacobian*(q_x*sigma_xz+q_y*sigma_yz+q_z*sigma_zz);
  F[0][ 3] = 0.0;
  F[0][ 4] = 0.0;
  F[0][ 5] = 0.0;
  F[0][ 6] = 0.0;
  F[0][ 7] = 0.0;
  F[0][ 8] = 0.0;
  F[0][ 9] = 0.0;
  F[0][10] = 0.0;
  F[0][11] = 0.0;
  
  F[1][ 0] = -jacobian*(r_x*sigma_xx+r_y*sigma_xy+r_z*sigma_xz);
  F[1][ 1] = -jacobian*(r_x*sigma_xy+r_y*sigma_yy+r_z*sigma_yz);
  F[1][ 2] = -jacobian*(r_x*sigma_xz+r_y*sigma_yz+r_z*sigma_zz);
  F[1][ 3] = 0.0;
  F[1][ 4] = 0.0;
  F[1][ 5] = 0.0;
  F[1][ 6] = 0.0;
  F[1][ 7] = 0.0;
  F[1][ 8] = 0.0;
  F[1][ 9] = 0.0;
  F[1][10] = 0.0;
  F[1][11] = 0.0;

  F[2][ 0] = -jacobian*(s_x*sigma_xx+s_y*sigma_xy+s_z*sigma_xz);
  F[2][ 1] = -jacobian*(s_x*sigma_xy+s_y*sigma_yy+s_z*sigma_yz);
  F[2][ 2] = -jacobian*(s_x*sigma_xz+s_y*sigma_yz+s_z*sigma_zz);
  F[2][ 3] = 0.0;
  F[2][ 4] = 0.0;
  F[2][ 5] = 0.0;
  F[2][ 6] = 0.0;
  F[2][ 7] = 0.0;
  F[2][ 8] = 0.0;
  F[2][ 9] = 0.0;
  F[2][10] = 0.0;
  F[2][11] = 0.0;
  
  
  
}


//You can either implement this method or modify fusedSource
void Elastic::MyElasticWaveSolver::algebraicSource(const double* const Q,double* const S) {
  // @todo Please implement/augment if required
  
  double u = Q[0];
  double v = Q[1];
  double w = Q[2];
  
  S[0] = 0.0;
  S[1] = 0.0;
  S[2] = 0.0;
  S[3] = 0.0;
  S[4] = 0.0;
  S[5] = 0.0;
  S[6] = 0.0;
  S[7] = 0.0;
  S[8] = 0.0;
  S[9] =  -u;
  S[10] = -v;
  S[11] = -w;
}

void  Elastic::MyElasticWaveSolver::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  // @todo Please implement/augment if required

  double u_q = gradQ[0];
  double v_q = gradQ[1];
  double w_q = gradQ[2];

  double u_r = gradQ[12];
  double v_r = gradQ[13];
  double w_r = gradQ[14];

  double u_s = gradQ[24];
  double v_s = gradQ[25];
  double w_s = gradQ[26];

  double q_x;
  double q_y;
  double q_z;  
  double r_x;
  double r_y;
  double r_z;
  double s_x;
  double s_y;
  double s_z;  
  
  extractTransformation(Q,q_x,q_y,q_z,r_x,r_y,r_z,s_x,s_y,s_z);
  
  // velocities
  BgradQ[0] = 0;
  BgradQ[1] = 0;
  BgradQ[2] = 0;

  // stresses
  BgradQ[3] =-q_x*u_q;
  BgradQ[4] =-q_y*v_q;
  BgradQ[5] =-q_z*w_q;
  BgradQ[6] =-(q_y*u_q+q_x*v_q); //sigma_xy
  BgradQ[7] =-(q_z*u_q+q_x*w_q); //sigma_xz
  BgradQ[8] =-(q_z*v_q+q_y*w_q); //sigma_yz
  
  //displacements
  BgradQ[9] =  0.0;  //
  BgradQ[10] = 0.0;  //
  BgradQ[11] = 0.0;  //

  // velocities
  BgradQ[12]= 0;
  BgradQ[13]= 0;
  BgradQ[14]= 0;

  // stresses
  BgradQ[15]=-r_x*u_r;
  BgradQ[16]=-r_y*v_r;
  BgradQ[17]=-r_z*w_r;
  BgradQ[18]=-(r_y*u_r+r_x*v_r); //sigma_xy
  BgradQ[19]=-(r_z*u_r+r_x*w_r); //sigma_xz
  BgradQ[20]=-(r_z*v_r+r_y*w_r); //sigma_yz

  //displacements
  BgradQ[21] = 0.0; //
  BgradQ[22] = 0.0; //
  BgradQ[23] = 0.0; //

  // velocities
  BgradQ[24]= 0;
  BgradQ[25]= 0;
  BgradQ[26]= 0;

  // stresses
  BgradQ[27]=-s_x*u_s;
  BgradQ[28]=-s_y*v_s;
  BgradQ[29]=-s_z*w_s;
  BgradQ[30]=-(s_y*u_s+s_x*v_s); //sigma_xy
  BgradQ[31]=-(s_z*u_s+s_x*w_s); //sigma_xz
  BgradQ[32]=-(s_z*v_s+s_y*w_s); //sigma_yz

  //displacements
  BgradQ[33] = 0.0; //
  BgradQ[34] = 0.0; //
  BgradQ[35] = 0.0; //
  
}

void  Elastic::MyElasticWaveSolver::initPointSourceLocations() {
  constexpr double a_x = 0.0;
  constexpr double a_y = 0.0;
  constexpr double a_z = 0.0;
  
  constexpr double b_x = 1.0;
  constexpr double b_y = 1.0;
  constexpr double b_z = 1.0;

  constexpr double blockWidth_y = (b_y-a_y);
  constexpr double blockWidth_x = (b_x-a_x);
  constexpr double blockWidth_z = (b_z-a_z);

  double x1,y1,z1;
  double fault_ref_x,fault_ref_y,fault_ref_z;
    
  x1 = 15.0;
  y1 = 8.0;
  z1 = 15.0;
  
  fault_ref_x = (x1-a_x)/(blockWidth_x);
  fault_ref_y = (y1-a_y)/(blockWidth_y);
  fault_ref_z = (z1-a_z)/(blockWidth_z);
  
  pointSourceLocation[0][0]=fault_ref_x;
  pointSourceLocation[0][1]=fault_ref_y;
  pointSourceLocation[0][2]=fault_ref_z;

  // x1 = 7.5;
  // y1 = 5.0;
  // z1 = 5.0;
  // fault_ref_x = (x1-a_x)/(blockWidth_x);
  // fault_ref_y = (y1-a_y)/(blockWidth_y);
  // fault_ref_z = (z1-a_z)/(blockWidth_z);
    
  // pointSourceLocation[1][0] = fault_ref_x;
  // pointSourceLocation[1][1] = fault_ref_y;
  // pointSourceLocation[1][2] = fault_ref_z;

  // x1 = 5.0;
  // y1 = 2.5;
  // z1 = 5.0;
  // fault_ref_x = (x1-a_x)/(blockWidth_x);
  // fault_ref_y = (y1-a_y)/(blockWidth_y);
  // fault_ref_z = (z1-a_z)/(blockWidth_z);

  // pointSourceLocation[2][0] = fault_ref_x;
  // pointSourceLocation[2][1] = fault_ref_y;
  // pointSourceLocation[2][2] = fault_ref_z;

  // x1 = 5.0;
  // y1 = 7.5;
  // z1 = 5.0;
  // fault_ref_x = (x1-a_x)/(blockWidth_x);
  // fault_ref_y = (y1-a_y)/(blockWidth_y);
  // fault_ref_z = (z1-a_z)/(blockWidth_z);
  
  // pointSourceLocation[3][0] = fault_ref_x;
  // pointSourceLocation[3][1] = fault_ref_y;
  // pointSourceLocation[3][2] = fault_ref_z;
}


void  Elastic::MyElasticWaveSolver::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector,int n) {

  static tarch::logging::Log _log("MyLinearWaveSolver::pointSource");

  double jacobian = 1.0; //Q[12];
  
  double pi = 3.14159265359;
  double sigma = 0.1149;
  double t0 = 0.7;
  double f = 0.0;
  
  double M0 = 0000.0/jacobian;

  if(n == 0){
    
    f = M0*(1.0/(sigma*std::sqrt(2.0*pi)))*(std::exp(-((t-t0)*(t-t0))/(2.0*sigma*sigma)));

    forceVector[0] = 0.0;
    forceVector[1] = 0.0;
    forceVector[2] = 0.0;
    forceVector[3] = f;
    forceVector[4] = f;
    forceVector[5] = f;
    forceVector[6] = 0.0;
    forceVector[7] = 0.0;
    forceVector[8] = 0.0;
    forceVector[9] = 0.0;
  }
  
  // }else if(n == 1){
    
  //   f = 0*M0*(1.0/(sigma*std::sqrt(2.0*pi)))*(std::exp(-((t-t0)*(t-t0))/(2.0*sigma*sigma)));

  //   forceVector[0] = 0.0;
  //   forceVector[1] = 0.0;
  //   forceVector[2] = 0.0;
  //   forceVector[3] = 0.*f;
  //   forceVector[4] = 0.*f;
  //   forceVector[5] = 0.*f;
  //   forceVector[6] = 0.0;
  //   forceVector[7] = 0.0;
  //   forceVector[8] = 0.0;
    
  // }else if(n == 2){
    
  //   f = 0*M0*(1.0/(sigma*std::sqrt(2.0*pi)))*(std::exp(-((t-t0)*(t-t0))/(2.0*sigma*sigma)));
  
  //   forceVector[0] = 0.0;
  //   forceVector[1] = 0.0;
  //   forceVector[2] = 0.0;
  //   forceVector[3] = 0.*f;
  //   forceVector[4] = 0.*f;
  //   forceVector[5] = 0.*f;
  //   forceVector[6] = 0.0;
  //   forceVector[7] = 0.0;
  //   forceVector[8] = 0.0;
  // }else if(n == 3){
    
  //   f = 0*M0*(1.0/(sigma*std::sqrt(2.0*pi)))*(std::exp(-((t-t0)*(t-t0))/(2.0*sigma*sigma)));

  //   forceVector[0] = 0.0;
  //   forceVector[1] = 0.0;
  //   forceVector[2] = 0.0;
  //   forceVector[3] = 0.*f;
  //   forceVector[4] = 0.*f;
  //   forceVector[5] = 0.*f;
  //   forceVector[6] = 0.0;
  //   forceVector[7] = 0.0;
  //   forceVector[8] = 0.0;
  // }
}

    /**
     * @TODO LR : document
     */
void Elastic::MyElasticWaveSolver::multiplyMaterialParameterMatrix(const double* const Q, double* const rhs) {
  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  double rho = Q[numberOfVariables];  
  double c_p = Q[ numberOfVariables+1];
  double c_s = Q[ numberOfVariables+2];  
  double mu     = rho*c_s*c_s;
  double lambda = rho*c_p*c_p-2*mu;
  double jacobian = Q[ numberOfVariables+3];  
  double rho_jacobian_inv=1.0/(rho*jacobian);

  rhs[0]=rho_jacobian_inv * rhs[0];
  rhs[1]=rho_jacobian_inv * rhs[1];
  rhs[2]=rho_jacobian_inv * rhs[2];
  
  double lam_temp = lambda * (rhs[3] + rhs[4] + rhs[5]);
  rhs[3]=(2*mu) * rhs[3] +lam_temp;
  rhs[4]=(2*mu) * rhs[4] +lam_temp;
  rhs[5]=(2*mu) * rhs[5] +lam_temp;

  rhs[6]= mu*rhs[6];
  rhs[7]= mu*rhs[7];
  rhs[8]= mu*rhs[8];
  
  rhs[9]=  rhs[9];
  rhs[10]= rhs[10];
  rhs[11]= rhs[11];


  rhs[12] = rho_jacobian_inv * rhs[12];
  rhs[13] = rho_jacobian_inv * rhs[13];
  rhs[14] = rho_jacobian_inv * rhs[14];

  
  lam_temp = lambda * (rhs[15] + rhs[16] + rhs[17]);

  rhs[15]=(2*mu) * rhs[15] +lam_temp;
  rhs[16]=(2*mu) * rhs[16] +lam_temp;
  rhs[17]=(2*mu) * rhs[17] +lam_temp;

  rhs[18]= mu*rhs[18];
  rhs[19]= mu*rhs[19];
  rhs[20]= mu*rhs[20];
  
  rhs[21]= rhs[21];
  rhs[22]= rhs[22];
  rhs[23]= rhs[23];

  rhs[24] = rho_jacobian_inv * rhs[24];
  rhs[25] = rho_jacobian_inv * rhs[25];
  rhs[26] = rho_jacobian_inv * rhs[26];
  
  lam_temp = lambda * (rhs[27] + rhs[28] + rhs[29]);

  rhs[27]=(2*mu) * rhs[27] +lam_temp;
  rhs[28]=(2*mu) * rhs[28] +lam_temp;
  rhs[29]=(2*mu) * rhs[29] +lam_temp;

  rhs[30]= mu*rhs[30];
  rhs[31]= mu*rhs[31];
  rhs[32]= mu*rhs[32];
  
  rhs[33]= rhs[33];
  rhs[34]= rhs[34];
  rhs[35]= rhs[35];
}

void Elastic::MyElasticWaveSolver::extractTransformation(const double* const Q,
							 double& q_x,double& q_y,double& q_z,
							 double& r_x,double& r_y,double& r_z,
							 double& s_x,double& s_y,double& s_z) {
  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  q_x     =Q[numberOfVariables + 5];
  q_y     =Q[numberOfVariables + 6];
  q_z     =Q[numberOfVariables + 7];
  r_x     =Q[numberOfVariables + 8];
  r_y     =Q[numberOfVariables + 9];
  r_z     =Q[numberOfVariables + 10];
  s_x     =Q[numberOfVariables + 11];
  s_y     =Q[numberOfVariables + 12];
  s_z     =Q[numberOfVariables + 13];
}

void Elastic::MyElasticWaveSolver::riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double dt,const int normalNonZeroIndex, bool isBoundaryFace, int faceIndex){
  constexpr int numberOfVariables  = MyElasticWaveSolver::NumberOfVariables;
  constexpr int numberOfVariables2 = numberOfVariables*numberOfVariables;
  constexpr int numberOfParameters = MyElasticWaveSolver::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables+numberOfParameters;
  constexpr int basisSize          = MyElasticWaveSolver::Order+1;
  constexpr int order              = basisSize - 1;

  //kernels::idx3 idx_QLR(basisSize,basisSize,numberOfData);
  //kernels::idx3 idx_FLR(basisSize,basisSize,numberOfVariables);

  kernels::idx3 idx_QLR(basisSize,basisSize,numberOfData);
  kernels::idx3 idx_FLR(basisSize,basisSize,numberOfVariables);

  //check if the face lies on a fault
  bool is_fault=true;
  double fault_surface, xx, y, z;
   for (int i = 0; i < basisSize; i++) {
    for (int j = 0; j < basisSize; j++) {
      // TODO: Change position to static parameter
       double fault_position= 50.0/27*26*0.5;
       

       xx = QL[idx_QLR(i,j,NumberOfVariables+4)];
       y = QL[idx_QLR(i,j,numberOfData-2)];
       z = QL[idx_QLR(i,j,numberOfData-1)];
       
       //fault(fault_surface, y, z);


       // if (fault_surface <= -0.01 && std::abs(xx - (fault_position)) < 1.0e-2){
       // 	  std::cout<<"fault surface"<<" "<<fault_surface<<" "<<xx<<"  "<<y<<" "<< z <<std::endl;
       // 	  }

       
       is_fault=is_fault && std::abs(xx - fault_position) < 1.0e-5; //std::abs(QL[idx_QLR(i,j,numberOfData-3)] - (fault_position+fault_surface)) < 1.0e-5; 
    }
  }

  double n_p[3]={0,0,0};
  double n_m[3]={0,0,0};

  double m_p[3]={0,0,0};
  double m_m[3]={0,0,0};

  double l_p[3]={0,0,0};  
  double l_m[3]={0,0,0};

  double norm_p_qr;
  double norm_m_qr;
  
  double FLn, FLm, FLl, FRn,FRm,FRl;
  double FL_n,FL_m,FL_l,FR_n,FR_m,FR_l;
  double FLx,FLy,FLz,FRx,FRy,FRz;
  double FL_x,FL_y,FL_z,FR_x,FR_y,FR_z;

  for (int i = 0; i < basisSize; i++) {
    for (int j = 0; j < basisSize; j++) {
      double rho_p=QR[idx_QLR(i,j,numberOfVariables)];
      double c_p_p=QR[idx_QLR(i,j,numberOfVariables+1)];
      double c_s_p=QR[idx_QLR(i,j,numberOfVariables+2)];
      double mu_p=c_s_p*c_s_p*rho_p;
      double lam_p = rho_p*c_p_p*c_p_p-2*mu_p;      

      double rho_m=QL[idx_QLR(i,j,numberOfVariables)];
      double c_p_m=QL[idx_QLR(i,j,numberOfVariables+1)];
      double c_s_m=QL[idx_QLR(i,j,numberOfVariables+2)];
      double mu_m=c_s_m*c_s_m*rho_m;
      double lam_m = rho_m*c_p_m*c_p_m-2*mu_m;      

      get_normals(normalNonZeroIndex, norm_p_qr, n_p, QR + idx_QLR(i,j,0));
      get_normals(normalNonZeroIndex, norm_m_qr, n_m, QL + idx_QLR(i,j,0));    

      double Tx_m,Ty_m,Tz_m,Tx_p,Ty_p,Tz_p;
      double vx_m,vy_m,vz_m,vx_p,vy_p,vz_p;
      
      extract_tractions_and_particle_velocity(n_p,QR+idx_QLR(i,j,0),Tx_p,Ty_p,Tz_p,vx_p,vy_p,vz_p );
      extract_tractions_and_particle_velocity(n_m,QL+idx_QLR(i,j,0),Tx_m,Ty_m,Tz_m,vx_m,vy_m,vz_m ); 
      
      localBasis(n_p, m_p, l_p, 3);
      localBasis(n_m, m_m, l_m, 3);

      double Tn_m,Tm_m,Tl_m,vn_m,vm_m,vl_m;
      double Tn_p,Tm_p,Tl_p,vn_p,vm_p,vl_p;

      // rotate fields into l, m, n basis
      rotate_into_orthogonal_basis(n_m,m_m,l_m,Tx_m,Ty_m,Tz_m,Tn_m,Tm_m,Tl_m);
      rotate_into_orthogonal_basis(n_m,m_m,l_m,vx_m,vy_m,vz_m,vn_m,vm_m,vl_m);
      rotate_into_orthogonal_basis(n_p,m_p,l_p,Tx_p,Ty_p,Tz_p,Tn_p,Tm_p,Tl_p);
      rotate_into_orthogonal_basis(n_p,m_p,l_p,vx_p,vy_p,vz_p,vn_p,vm_p,vl_p);      
      
  
      // extract local s-wave and p-wave impedances
      double zs_p=rho_p*c_s_p;
      double zp_p=rho_p*c_p_p;      
      double zs_m=rho_m*c_s_m;
      double zp_m=rho_m*c_p_m;
      
      // impedance must be greater than zero !
      if (zp_p <= 0.0 || zp_m <= 0.0){
	std::cout<<zs_p<<" "<<zs_m<<" "<<zp_p<<" "<<zp_m<<"\n";
	std::cout<<" Impedance must be greater than zero ! "<< std::endl;
	std::exit(-1);
      }

      // generate interface data preserving the amplitude of the outgoing charactertritics
      // and satisfying interface conditions exactly.
      double vn_hat_p,vm_hat_p,vl_hat_p,Tn_hat_p,Tm_hat_p,Tl_hat_p;        
      double vn_hat_m,vm_hat_m,vl_hat_m,Tn_hat_m,Tm_hat_m,Tl_hat_m;

      double Sn_m,Sm_m,Sl_m,Sn_p,Sm_p,Sl_p;
      double Sx_m,Sy_m,Sz_m,Sx_p,Sy_p,Sz_p;

      if(is_fault){
	double x[3] = {QR[idx_QLR(i,j,numberOfData-3)], QR[idx_QLR(i,j,numberOfData-2)], QR[idx_QLR(i,j,numberOfData-1)]};

	Sx_p = QR[idx_QLR(i,j,numberOfVariables-3)];
	Sy_p = QR[idx_QLR(i,j,numberOfVariables-2)];
	Sz_p = QR[idx_QLR(i,j,numberOfVariables-1)];

	Sx_m = QL[idx_QLR(i,j,numberOfVariables-3)];
	Sy_m = QL[idx_QLR(i,j,numberOfVariables-2)];
	Sz_m = QL[idx_QLR(i,j,numberOfVariables-1)];
	
	
	rotate_into_orthogonal_basis(n_m,m_m,l_m,Sx_m,Sy_m,Sz_m,Sn_m,Sm_m,Sl_m);
        rotate_into_orthogonal_basis(n_p,m_p,l_p,Sx_p,Sy_p,Sz_p,Sn_p,Sm_p,Sl_p);
	
	double S =  std::sqrt((Sl_p- Sl_m)*(Sl_p- Sl_m)+(Sm_p- Sm_m)*(Sm_p- Sm_m));
	
	SlipWeakeningFriction(vn_p,vn_m, Tn_p,Tn_m, zp_p , zp_m, vn_hat_p , vn_hat_m, Tn_hat_p,Tn_hat_m, vm_p,vm_m,
			      Tm_p,Tm_m, zs_p,zs_m, vm_hat_p, vm_hat_m, Tm_hat_p,Tm_hat_m, vl_p,vl_m,Tl_p,Tl_m, zs_p,
			      zs_m, vl_hat_p , vl_hat_m, Tl_hat_p,Tl_hat_m, l_m, m_m, n_m, x, S);

	 
       
	

      }else{
	if (isBoundaryFace) {
	  double r= faceIndex==2 ? 1 : 0;
	  riemannSolver_boundary(faceIndex,r,vn_m,vm_m,vl_m,Tn_m,Tm_m,Tl_m,zp_m,zs_m,vn_hat_m,vm_hat_m,vl_hat_m,Tn_hat_m,Tm_hat_m,Tl_hat_m);
	  riemannSolver_boundary(faceIndex,r,vn_p,vm_p,vl_p,Tn_p,Tm_p,Tl_p,zp_p,zs_p,vn_hat_p,vm_hat_p,vl_hat_p,Tn_hat_p,Tm_hat_p,Tl_hat_p);      
	}else{
	  riemannSolver_Nodal(vn_p,vn_m, Tn_p, Tn_m, zp_p , zp_m, vn_hat_p , vn_hat_m, Tn_hat_p, Tn_hat_m);
	  riemannSolver_Nodal(vm_p,vm_m, Tm_p, Tm_m, zs_p , zs_m, vm_hat_p , vm_hat_m, Tm_hat_p, Tm_hat_m);
	  riemannSolver_Nodal(vl_p,vl_m, Tl_p, Tl_m, zs_p , zs_m, vl_hat_p , vl_hat_m, Tl_hat_p, Tl_hat_m);
	}
      }
      
      //generate fluctuations in the local basis coordinates: n, m, l
      generate_fluctuations_left(zp_m,Tn_m,Tn_hat_m,vn_m,vn_hat_m,FLn);
      generate_fluctuations_left(zs_m,Tm_m,Tm_hat_m,vm_m,vm_hat_m,FLm);
      generate_fluctuations_left(zs_m,Tl_m,Tl_hat_m,vl_m,vl_hat_m,FLl);

      generate_fluctuations_right(zp_p,Tn_p,Tn_hat_p,vn_p,vn_hat_p,FRn);
      generate_fluctuations_right(zs_p,Tm_p,Tm_hat_p,vm_p,vm_hat_p,FRm);
      generate_fluctuations_right(zs_p,Tl_p,Tl_hat_p,vl_p,vl_hat_p,FRl);

      FL_n = FLn/zp_m;
      if(zs_m > 0){
	FL_m = FLm/zs_m;
	FL_l = FLl/zs_m;
      }else{
	FL_m=0;
	FL_l=0;
      }
    
      FR_n = FRn/zp_p;
      if(zs_p > 0){    
	FR_m = FRm/zs_p;
	FR_l = FRl/zs_p;
      }else{
	FR_m=0;
	FR_l=0;
      }
    
      // rotate back to the physical coordinates x, y, z
      rotate_into_physical_basis(n_m,m_m,l_m,FLn,FLm,FLl,FLx,FLy,FLz);
      rotate_into_physical_basis(n_m,m_m,l_m,FL_n,FL_m,FL_l,FL_x,FL_y,FL_z);
      
      rotate_into_physical_basis(n_p,m_p,l_p,FRn,FRm,FRl,FRx,FRy,FRz);
      rotate_into_physical_basis(n_p,m_p,l_p,FR_n,FR_m,FR_l,FR_x,FR_y,FR_z);
     
      // construct flux fluctuationn vectors obeying the eigen structure of the PDE
      // and choose physically motivated penalties such that we can prove
      // numerical stability.

      FR[idx_FLR(i,j, 0)] = norm_p_qr/rho_p*FRx;
      FL[idx_FLR(i,j, 0)] = norm_m_qr/rho_m*FLx;
    
      FR[idx_FLR(i,j, 1)] = norm_p_qr/rho_p*FRy;
      FL[idx_FLR(i,j, 1)] = norm_m_qr/rho_m*FLy;

      FR[idx_FLR(i,j, 2)] = norm_p_qr/rho_p*FRz;
      FL[idx_FLR(i,j, 2)] = norm_m_qr/rho_m*FLz;

      FL[idx_FLR(i,j, 3)] = norm_m_qr*((2*mu_m+lam_m)*n_m[0]*FL_x+lam_m*n_m[1]*FL_y+lam_m*n_m[2]*FL_z);
      FL[idx_FLR(i,j, 4)] = norm_m_qr*((2*mu_m+lam_m)*n_m[1]*FL_y+lam_m*n_m[0]*FL_x+lam_m*n_m[2]*FL_z);
      FL[idx_FLR(i,j, 5)] = norm_m_qr*((2*mu_m+lam_m)*n_m[2]*FL_z+lam_m*n_m[0]*FL_x+lam_m*n_m[1]*FL_y);

      FR[idx_FLR(i,j, 3)] = -norm_p_qr*((2*mu_p+lam_p)*n_p[0]*FR_x+lam_p*n_p[1]*FR_y+lam_p*n_p[2]*FR_z);
      FR[idx_FLR(i,j, 4)] = -norm_p_qr*((2*mu_p+lam_p)*n_p[1]*FR_y+lam_p*n_p[0]*FR_x+lam_p*n_p[2]*FR_z);
      FR[idx_FLR(i,j, 5)] = -norm_p_qr*((2*mu_p+lam_p)*n_p[2]*FR_z+lam_p*n_p[0]*FR_x+lam_p*n_p[1]*FR_y);
    
      FL[idx_FLR(i,j, 6)] =  norm_m_qr*mu_m*(n_m[1]*FL_x + n_m[0]*FL_y);
      FL[idx_FLR(i,j, 7)] =  norm_m_qr*mu_m*(n_m[2]*FL_x + n_m[0]*FL_z);
      FL[idx_FLR(i,j, 8)] =  norm_m_qr*mu_m*(n_m[2]*FL_y + n_m[1]*FL_z);

      FR[idx_FLR(i,j, 6)] = -norm_p_qr*mu_p*(n_p[1]*FR_x + n_p[0]*FR_y);
      FR[idx_FLR(i,j, 7)] = -norm_p_qr*mu_p*(n_p[2]*FR_x + n_p[0]*FR_z);
      FR[idx_FLR(i,j, 8)] = -norm_p_qr*mu_p*(n_p[2]*FR_y + n_p[1]*FR_z);

      FL[idx_FLR(i,j, 9)] = 0;
      FR[idx_FLR(i,j, 9)] = 0;
      
      FL[idx_FLR(i,j, 10)] = 0;
      FR[idx_FLR(i,j, 10)] = 0;
      
      FL[idx_FLR(i,j, 11)] = 0;
      FR[idx_FLR(i,j, 11)] = 0;
      

      //if(is_fault){
      //	double slip_rate= std::sqrt((vl_hat_p- vl_hat_m)*(vl_hat_p- vl_hat_m)+(vm_hat_p- vm_hat_m)*(vm_hat_p- vm_hat_m));
      //	FL[idx_FLR(i,j, 9)] = -slip_rate;
      //	FR[idx_FLR(i,j, 9)] = -slip_rate;
      //}else{
      //	FL[idx_FLR(i,j, 9)] = 0;
      //	FR[idx_FLR(i,j, 9)] = 0;
      //}
    }    
  }
}


//Gram Schmidt orthonormalization
void Elastic::MyElasticWaveSolver::Gram_Schmidt(double* const y, double* const z){
  double  a_yz = y[0]*z[0] + y[1]*z[1] + y[2]*z[2];

  for (int i = 0; i< 3; i++){
    z[i] = z[i] - a_yz*y[i];
  }
  
  double norm_z = std::sqrt(z[0]*z[0] + z[1]*z[1] + z[2]*z[2]);
  
  for (int i = 0; i< 3; i++){
    z[i] =  z[i]/norm_z;
  }
}

void Elastic::MyElasticWaveSolver::localBasis(double* const n, double* const m, double* const l, int d){
  if (d == 2){
      l[0] = 0.;
      l[1] = 0.;
      l[2] = 1.0;
      
      m[0] = n[1]*l[2]-n[2]*l[1];
      m[1] = -(n[0]*l[2]-n[2]*l[0]);
      m[2] = n[0]*l[1]-n[1]*l[0];
  }else if (d == 3){
      double tol, diff_norm1, diff_norm2;
      tol = 1e-12;
      m[0] = 0.;
      m[1] = 1.;
      m[2] = 0.;
      
      diff_norm1 =  std::sqrt(pow(n[0]-m[0],2) + pow(n[1]-m[1], 2) + pow(n[2]-m[2], 2));
      diff_norm2 =  std::sqrt(pow(n[0]+m[0],2) + pow(n[1]+m[1], 2) + pow(n[2]+m[2], 2));
      
      if (diff_norm1 >= tol && diff_norm2 >= tol){
      	Gram_Schmidt(n, m);
      }else{
      	  m[0] = 0.;
      	  m[1] = 0.;
      	  m[2] = 1.;
      	  Gram_Schmidt(n, m);
      }
      l[0] = n[1]*m[2]-n[2]*m[1];
      l[1] = -(n[0]*m[2]-n[2]*m[0]);
      l[2] = n[0]*m[1]-n[1]*m[0];
  }
}



void Elastic::MyElasticWaveSolver::riemannSolver_Nodal(double v_p,double v_m, double sigma_p, double sigma_m, double z_p , double z_m, double& v_hat_p , double& v_hat_m, double& sigma_hat_p, double& sigma_hat_m){
  double p=0;
  double q=0;
  double phi=0;
  double v_hat=0;
  double eta=0;

  p=z_p*v_p + sigma_p;
  q=z_m*v_m - sigma_m;

  if(z_p > 0 && z_m > 0){
    eta=(z_p*z_m)/(z_p+z_m);

    phi= eta*(p/z_p - q/z_m);
     
    sigma_hat_p=phi;
    sigma_hat_m=phi;

    v_hat_p=(q+phi)/z_m;     
    v_hat_m=(p-phi)/z_p;
  }else if(z_p > 0){
    sigma_hat_p=0;
    sigma_hat_m=sigma_m;

    v_hat_p=v_p;     
    v_hat_m=v_m;
  }else if(z_m > 0){
    sigma_hat_p=sigma_p;
    sigma_hat_m=0;

    v_hat_p=v_p;     
    v_hat_m=v_m;
  }else{
    sigma_hat_p=sigma_p;
    sigma_hat_m=sigma_m;
     
    v_hat_p=v_p;
    v_hat_m=v_m;     
  }
 }

void Elastic::MyElasticWaveSolver::riemannSolver_BC0(double v, double sigma, double z,  double r, double& v_hat, double& sigma_hat){
   double p = 0.5*(z*v + sigma);
   if(z > 0){
     v_hat = (1+r)/z*p;
     sigma_hat = (1-r)*p;
   }else{
     v_hat = v;
     sigma_hat = sigma;
   }
}

void Elastic::MyElasticWaveSolver::riemannSolver_BCn(double v,double sigma, double z, double r, double& v_hat, double& sigma_hat){
   double q = 0.5*(z*v - sigma);
   if(z > 0){
     v_hat = (1+r)/z*q;
     sigma_hat = -(1-r)*q;
   }else{
     v_hat = v;
     sigma_hat = sigma;
   }
}

void Elastic::MyElasticWaveSolver::get_normals(int normalNonZeroIndex,double& norm, double* const n,const double* const Q){

  double q_x;
  double q_y;
  double q_z;  
  double r_x;
  double r_y;
  double r_z;
  double s_x;
  double s_y;
  double s_z;  
  
  extractTransformation(Q,q_x,q_y,q_z,r_x,r_y,r_z,s_x,s_y,s_z);
  
  if (normalNonZeroIndex == 0){
    norm = std::sqrt(q_x*q_x + q_y*q_y + q_z*q_z);
    n[0] = q_x/norm;
    n[1] = q_y/norm;
    n[2] = q_z/norm;	
  }
  if (normalNonZeroIndex == 1){
    norm = std::sqrt(r_x*r_x + r_y*r_y + r_z*r_z);
    n[0] = r_x/norm;
    n[1] = r_y/norm;
    n[2] = r_z/norm;	
  }
  if (normalNonZeroIndex == 2){
    norm = std::sqrt(s_x*s_x + s_y*s_y + s_z*s_z);
    n[0] = s_x/norm;
    n[1] = s_y/norm;
    n[2] = s_z/norm;	
  }
}

void Elastic::MyElasticWaveSolver::extract_tractions_and_particle_velocity(double* const n,const double* const Q, double& Tx,double& Ty,double& Tz,double& vx,double& vy,double& vz ){
  double sigma_xx = Q[3];
  double sigma_yy = Q[4];
  double sigma_zz = Q[5];
  double sigma_xy = Q[6];
  double sigma_xz = Q[7];
  double sigma_yz = Q[8];
  
  Tx = n[0]*sigma_xx + n[1]*sigma_xy + n[2]*sigma_xz;
  Ty = n[0]*sigma_xy + n[1]*sigma_yy + n[2]*sigma_yz;
  Tz = n[0]*sigma_xz + n[1]*sigma_yz + n[2]*sigma_zz;    
  
  vx = Q[0];
  vy = Q[1];
  vz = Q[2];    
}



void Elastic::MyElasticWaveSolver::rotate_into_orthogonal_basis(double* const n,double* const m,double* const l, double Tx,double Ty,double Tz, double& Tn, double& Tm, double& Tl){
    Tn= Tx*n[0] + Ty*n[1] + Tz*n[2];
    Tm= Tx*m[0] + Ty*m[1] + Tz*m[2];
    Tl= Tx*l[0] + Ty*l[1] + Tz*l[2];
}

void Elastic::MyElasticWaveSolver::rotate_into_physical_basis(double* const n,double* const m,double* const l, double Fn,double Fm,double Fl, double& Fx, double& Fy, double& Fz){
  Fx = n[0]*Fn + m[0]*Fm + l[0]*Fl;
  Fy = n[1]*Fn + m[1]*Fm + l[1]*Fl;
  Fz = n[2]*Fn + m[2]*Fm + l[2]*Fl;
}

void Elastic::MyElasticWaveSolver::generate_fluctuations_left(double z,  double T,double T_hat,double v, double v_hat, double& F){
  F = 0.5*(z*(v-v_hat) + (T-T_hat));
}

void Elastic::MyElasticWaveSolver::generate_fluctuations_right(double z,  double T,double T_hat,double v, double v_hat, double& F){
  F = 0.5*(z*(v-v_hat) - (T-T_hat));
}

void Elastic::MyElasticWaveSolver::riemannSolver_boundary(int faceIndex,double r, double vn , double vm , double vl, double Tn , double Tm ,double Tl , double zp, double zs , double& vn_hat , double& vm_hat ,double& vl_hat , double& Tn_hat , double& Tm_hat ,double& Tl_hat)
{
  if (faceIndex % 2  == 0) {
    riemannSolver_BC0(vn, Tn, zp, r, vn_hat, Tn_hat);
    riemannSolver_BC0(vm, Tm, zs, r, vm_hat, Tm_hat);
    riemannSolver_BC0(vl, Tl, zs, r, vl_hat, Tl_hat);	
  }
      
  if (faceIndex % 2 == 1) {
    riemannSolver_BCn(vn, Tn, zp, r, vn_hat, Tn_hat);
    riemannSolver_BCn(vm, Tm, zs, r, vm_hat, Tm_hat);
    riemannSolver_BCn(vl, Tl, zs, r, vl_hat, Tl_hat);	
  }
}

// Rupture Dynamics
void Elastic::MyElasticWaveSolver::SlipWeakeningFriction(double vn_p,double vn_m, double Tn_p, double Tn_m, double zn_p , double zn_m, double& vn_hat_p , double& vn_hat_m, double& Tn_hat_p, double& Tn_hat_m, double vm_p,double vm_m, double Tm_p, double Tm_m, double zl_p , double zl_m, double& vm_hat_p , double& vm_hat_m, double& Tm_hat_p, double& Tm_hat_m, double vl_p,double vl_m, double Tl_p, double Tl_m, double zm_p , double zm_m, double& vl_hat_p , double& vl_hat_m, double& Tl_hat_p, double& Tl_hat_m, double* const l, double* const m, double* const n, double* const x,  double S)
{
  // compute characteristics
  double p_l = zl_p*vl_p + Tl_p;
  double p_m = zm_p*vm_p + Tm_p;
  double p_n = zn_p*vn_p + Tn_p;
  
  double q_l = zl_m*vl_m - Tl_m;
  double q_m = zm_m*vm_m - Tm_m;
  double q_n = zn_m*vn_m - Tn_m;

  // half of the harmonic mean of Z1_s, Z2_s
  double eta_s=(zl_p*zl_m)/(zl_p+zl_m);                                    
  double eta_n=(zn_p*zn_m)/(zn_p+zn_m); 
  
  double  phi_l= eta_s*(p_l/zl_p - q_l/zl_m);
  double  phi_m= eta_s*(p_m/zm_p - q_m/zm_m);
  double  phi_n= eta_n*(p_n/zn_p - q_n/zn_m);
    
  double T0_l=0;
  double T0_m=0;
  double T0_n=0;

  // get prestress (where normal traction is effective normal traction)
  prestress(T0_n, T0_m, T0_l, x, 0.0, l, m, n);

  vn_hat_m = (p_n - phi_n)/zn_p;   //! continuity of normal velocity
  Tn_hat_m = phi_n;                //! continuity of normal stress
  vn_hat_p = (q_n + phi_n)/zn_m;   //! continuity of normal velocity
  Tn_hat_p = phi_n;

  double tau_lock = std::sqrt(std::pow(T0_l + phi_l, 2) + std::pow(T0_m + phi_m, 2));
  double sigma_n = std::max(0.0, -(T0_n + phi_n));   // including prestress
  double tau_str;
  double Vel = 0.0;
  double Tl, Tm, vv_l, vv_m; 
  TauStrength(tau_str, sigma_n, S, x, 0.0);
  
  if (tau_lock >= tau_str){
    slip_weakening(vv_m,  vv_l, Vel, Tm, Tl, phi_m+T0_m, phi_l+T0_l, eta_s, tau_str, sigma_n);

    Tm_hat_m = Tm - T0_m;
    Tl_hat_m = Tl - T0_l;

    Tm_hat_p = Tm - T0_m;
    Tl_hat_p = Tl - T0_l;
  }else{
    Tm_hat_m = phi_m;
    Tl_hat_m = phi_l;

    Tm_hat_p = phi_m;
    Tl_hat_p = phi_l;
       
    vv_m = 0.0;
    vv_l = 0.0;
    
    Vel = 0.0;
  }
   
  vm_hat_p = (Tm_hat_m + q_m)/zm_m + vv_m;
  vl_hat_p = (Tl_hat_m + q_l)/zl_m + vv_l;
    
  vm_hat_m = (p_m - Tm_hat_p)/zm_p - vv_m;
  vl_hat_m = (p_l - Tl_hat_p)/zl_p - vv_l;

  
}

  // solve for slip-rate (vv):  
void Elastic::MyElasticWaveSolver::slip_weakening(double& v1, double& v2, double& Vel, double& tau1, double& tau2,
								double phi_1, double phi_2, double eta, double tau_str, double sigma_n){
  
  double Phi = std::sqrt(std::pow(phi_1, 2) + std::pow(phi_2, 2));   // stress-transfer functional
  Vel = (Phi - tau_str)/eta;                // slip-rate

  //compute slip velocities
  v1 = phi_1/(eta+tau_str/Vel);
  v2 = phi_2/(eta+tau_str/Vel);
  
  //compute shear stress on the fault
  tau1 = phi_1 - eta*v1;
  tau2 = phi_2 - eta*v2;
}

void Elastic::MyElasticWaveSolver::TauStrength(double& tau_str, double sigma_n, double S, double* const x, double t)
{
  // // TPV5
  // double mu_s = 0.677;                          // stastic friction
  // double mu_d = 0.525;                          // dynamic friction
  // double sigma0 = 120.0;                        // normal stress
  // double S_c = 0.40;                            // critical slip

  // double fy;
  // double fz;
  
  // boxcar(fy, x[1]-7.5,15.0);
  // boxcar(fz, x[2]-15.0,15.0);

  // mu_s = mu_s + 1e10*(1.0-fy*fz);
  // double fric_coeff = mu_s - (mu_s-mu_d) * std::min(S,S_c)/S_c;     // friction coefficient
  // tau_str = fric_coeff*sigma_n;     
  // fault strength

  // TPV28:
  double mu_s = 0.677;                          // stastic friction
  double mu_d = 0.373;                          // dynamic friction
  double S_c = 0.40;                            // critical slip

  double fy;
  double fz;
  
  boxcar(fy, x[1],15.0);
  boxcar(fz, x[2]-25,18.0);

  mu_s = mu_s + 1e10*(1.0-fy*fz);
  double fric_coeff = mu_s - (mu_s-mu_d) * std::min(S,S_c)/S_c;     // friction coefficient
  tau_str = fric_coeff*sigma_n;        
}

double Elastic::MyElasticWaveSolver::boxcar(double& f, double x, double w) 
{
  // f(x) is boxcar of unit amplitude in (x-w,x+w)
  double tol = 1e-8;
 
  if ((-w+tol)<x && x< (w-tol)){    // inside
    f = 1.0;
    //std::cout<< x << "  " << w <<std::endl;
  }
  else if (std::abs(-w-x)<=tol || std::abs(x-w)<=tol){     // boundary
    f = 0.5;
  }
  else{    // outside
    f = 0.0;
  }
  return f;
}

void Elastic::MyElasticWaveSolver::prestress(double& T0_n, double& T0_m, double& T0_l, double* const x, double t, double* const l, double* const m, double* const n)
{

  double sxx,syy,szz,sxy,sxz, syz;
  double Tx,Ty,Tz;

  // // initial stress tensor
  // initialstresstensor(sxx,syy,szz,sxy,sxz, syz, x);

  // //std::cout<< sxx << " " << syy << "  " << szz << " " << sxy << " " << sxz << "  " << syz <<std::endl;

  // // extract tractions in xyz coordinates
  // extract_tractions(sxx, syy, szz, sxy, sxz, syz, n, Tx,Ty,Tz);

  // // rotate tractions into local orthogonal coordinates
  // rotate_into_orthogonal_basis(n,m,l,Tx,Ty,Tz,T0_n,T0_m,T0_l);

  // //std::cout<< T0_n << " " << T0_m << "  " << T0_l << std::endl;
   
  // //TPV5:
  // double fy;
  // double fz;
  // //
  // boxcar(fy, x[1]-7.5,  1.5);
  // boxcar(fz, x[2]-7.5, 1.5);
  // //
  // T0_l = T0_l+8.0   *fy*fz;

  // boxcar(fy, x[1]-7.5,  1.5);
  // boxcar(fz, x[2]-15.0, 1.5);
  // //
  // T0_l = T0_l+11.6   *fy*fz;

  // boxcar(fy, x[1]-7.5,  1.5);
  // boxcar(fz, x[2]-22.5, 1.5);
  // //
  // T0_l = T0_l-8.0   *fy*fz;



  //====================================
  //TPV28:
  //====================================

  // initial stress tensor
  initialstresstensor(sxx,syy,szz,sxy,sxz, syz, x);


  // extract tractions in xyz coordinates
  extract_tractions(sxx, syy, szz, sxy, sxz, syz, n, Tx,Ty,Tz);

  // rotate tractions into local orthogonal coordinates
  rotate_into_orthogonal_basis(n,m,l,Tx,Ty,Tz,T0_n,T0_m,T0_l);

  double r;
  double tau_nuke;
  double pi = 3.14159265359;

  r = std::sqrt((x[1]-7.5)*(x[1]-7.5) + (x[2]-25.0)*(x[2]-25.0));

  if (r <= 1.4){
    tau_nuke = 11.60;
  }
  else if(r >= 1.4 && r<=2.0) {
    tau_nuke = 5.8*(1.0 + std::cos(pi*(r-1.4)/0.6));
  }
  else{
    tau_nuke = 0.0;
  }

  T0_l = T0_l + tau_nuke;
    
}


void Elastic::MyElasticWaveSolver::extract_tractions(double sxx, double syy, double szz, double sxy, double sxz, double syz, double* const n, double& Tx,double& Ty,double& Tz){
  
  Tx = n[0]*sxx + n[1]*sxy + n[2]*sxz;
  Ty = n[0]*sxy + n[1]*syy + n[2]*syz;
  Tz = n[0]*sxz + n[1]*syz + n[2]*szz;    
      
}
void Elastic::MyElasticWaveSolver::initialstresstensor(double& sxx, double& syy, double& szz, double& sxy, double& sxz, double& syz, double* const x)
{
  // // TPV5:
  // sxx = -120.0;
  // syy = 0.0;
  // szz = 0.0;
  
  // sxy =  0.0;
  // sxz = 70.0;
  // syz = 0.0;

  // TPV28:
  sxx = -60;
  syy = 0.0;
  szz = -60.0;
  
  sxy = 0.0;
  sxz = 29.380;
  syz = 0.00;
 
}



void Elastic::MyElasticWaveSolver::fault(double& fault_surface, double y, double z){
  double pi = 3.14159265359;
  
  fault_surface=0.0;

  //Geometry for TPV28
  double r1, r2;
  fault_surface=0.;
  
  r1 = std::sqrt((z-14.5)*(z-14.5) + (y-7.5)*(y-7.5));
  r2 = std::sqrt((z-35.5)*(z-35.5) + (y-7.5)*(y-7.5));

  
  if (r1 <= 3.0) {
    fault_surface = -0.3*(1.0 + std::cos(pi*r1/3.0));
  }

  if (r2 <= 3.0) {
    fault_surface = -0.3*(1.0 + std::cos(pi*r2/3.0));
  }

  

}

