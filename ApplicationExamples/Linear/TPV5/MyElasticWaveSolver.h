#ifndef __MyElasticWaveSolver_CLASS_HEADER__
#define __MyElasticWaveSolver_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <ostream>

#include "AbstractMyElasticWaveSolver.h"

/**
 * We use Peano's logging
 */
#include "tarch/logging/Log.h"
#include "tarch/la/Vector.h"
#include "tarch/la/Vector.h"
#include "tarch/plotter/griddata/unstructured/vtk/VTUTextFileWriter.h"

#include "CurvilinearTransformation.h"

namespace Elastic{
  class MyElasticWaveSolver;
}

class Elastic::MyElasticWaveSolver : public Elastic::AbstractMyElasticWaveSolver {
  private:
    /**
     * Log device
     */
    static tarch::logging::Log _log;
    CurvilinearTransformation* transformation;
    tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter* faultWriter;
    tarch::plotter::griddata::unstructured::UnstructuredGridWriter::VertexWriter* vertexWriter;
    tarch::plotter::griddata::unstructured::UnstructuredGridWriter::CellWriter*   cellWriter;
    tarch::plotter::griddata::Writer::CellDataWriter* dataWriter;


    static int outputCounter;
    
    
  public:
    //MyElasticWaveSolver(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,exahype::solvers::Solver::TimeStepping timeStepping);
    MyElasticWaveSolver(
			const double maximumMeshSize,
			const int maximumMeshDepth,
			const int haloCells,
			const int haloBufferCells,
			const int limiterBufferCells,
			const int regularisedFineGridLevels,
			const exahype::solvers::Solver::TimeStepping timeStepping,const int DMPObservables
			);

    /**
     * Initialise the solver.
     *
     * \param[in] cmdlineargs the command line arguments.
     */
    void init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) final override;

    /**
     * Patchwise adjust
     * @TODO LR : Document
     */
    void adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) final override;

    /**
     * Compute the eigenvalues of the flux tensor per coordinate direction \p d.
     *
     * \param[in] Q  the conserved variables associated with a quadrature node
     *               as C array (already allocated).
     * \param[in] d  the column of the flux vector (d=0,1,...,DIMENSIONS).
     * \param[inout] lambda the eigenvalues as C array (already allocated).
     */
    void eigenvalues(const double* const Q,const int d,double* const lambda) final override;
    
    /**
     * Impose boundary conditions at a point on a boundary face
     * within the time interval [t,t+dt].
     *
     * \param[in]    x         the physical coordinate on the face.
     * \param[in]    t         the start of the time interval.
     * \param[in]    dt        the width of the time interval.
     * \param[in]    faceIndex indexing of the face (0 -- {x[0]=xmin}, 1 -- {x[1]=xmax}, 2 -- {x[1]=ymin}, 3 -- {x[2]=ymax}, and so on,
     *                         where xmin,xmax,ymin,ymax are the bounds of the cell containing point x.
     * \param[in]    d         the coordinate direction the face normal is pointing to.
     * \param[in]    QIn       the conserved variables at point x from inside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     * \param[in]    FIn       the normal fluxes at point x from inside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     * \param[inout] QOut      the conserved variables at point x from outside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     * \param[inout] FOut      the normal fluxes at point x from outside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     */
    void boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) final override;
    
    /**
     * Evaluate the refinement criterion within a cell.
     *
     * \note Instead of a variables array at a single quadrature point we give
     * you all NumberOfVariables*(Order+1)^DIMENSIONS solution degrees of freedom.
     *
     * \note Use this function and ::adjustSolution to set initial conditions.
     *
     * \param[in]    centre    The centre of the cell.
     * \param[in]    dx        The extent of the cell.
     * \param[in]    t         the start of the time interval.
     * \param[in]    dt        the width of the time interval.
     * \return One of exahype::solvers::Solver::RefinementControl::{Erase,Keep,Refine}.
     */
    exahype::solvers::Solver::RefinementControl refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& centre,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) override;
    
    //PDE

    /**
     * Compute the flux tensor.
     *
     * \param[in]    Q the conserved variables (and parameters) associated with a quadrature point
     *                 as C array (already allocated).
     * \param[inout] F the fluxes at that point as C array (already allocated).
     */
    void flux(const double* const Q,double** const F) final override;


    /**
     * Compute the nonconservative term $B(Q) \nabla Q$.
     * 
     * This function shall return a vector BgradQ which holds the result
     * of the full term. To do so, it gets the vector Q and the matrix
     * gradQ which holds the derivative of Q in each spatial direction.
     * Currently, the gradQ is a continous storage and users can use the
     * kernels::idx2 class in order to compute the positions inside gradQ.
     *
     * @TODO: Check if the following is still right:
     * 
     * !!! Warning: BgradQ is a vector of size NumberOfVariables if you
     * use the ADER-DG kernels for nonlinear PDEs. If you use
     * the kernels for linear PDEs, it is a tensor with dimensions
     * Dim x NumberOfVariables.
     * 
     * \param[in]   Q   the vector of unknowns at the given position
     * \param[in]   gradQ   the gradients of the vector of unknowns,
     *                  stored in a linearized array.
     * \param[inout]  The vector BgradQ (extends nVar), already allocated. 
     *
     **/
    void nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) final override;
    void algebraicSource(const double* const Q,double* const S) final override;

    /**
     * Compute a pointSource contribution.
     * 
     * @TODO: Document me, please.
    **/
    void initPointSourceLocations();
    void pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector,int n) override;

    /**
     * @TODO LR : document
     */
    void multiplyMaterialParameterMatrix(const double* const Q, double* const rhs) final override;
    
    void extractTransformation(const double* const Q,
			       double& q_x,double& q_y,double& q_z,
			       double& r_x,double& r_y,double& r_z,
			       double& s_x,double& s_y,double& s_z);

    //void riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double t,const double dt, const tarch::la::Vector<DIMENSIONS, double>& lengthScale,const int direction, bool isBoundaryFace, int faceIndex) override;
    void riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double t,const double dt, const tarch::la::Vector<DIMENSIONS, double>& lengthScale,const int direction, bool isBoundaryFace, int faceIndex) override;
    void riemannSolver_Nodal(double v_p,double v_m, double sigma_p, double sigma_m, double z_p , double z_m, double& v_hat_p , double& v_hat_m, double& sigma_hat_p, double& sigma_hat_m);
    void riemannSolver_boundary(int faceIndex,double r, double vn , double vm , double vl, double Tn , double Tm ,double Tl , double zp, double zs,  double& vn_hat , double& vm_hat ,double& vl_hat , double& Tn_hat , double& Tm_hat ,double& Tl_hat);
    
    void riemannSolver_BC0(double v, double sigma, double z,  double r, double& v_hat, double& sigma_hat);
    void riemannSolver_BCn(double v, double sigma, double z,  double r, double& v_hat, double& sigma_hat);

    void localBasis(double* const n, double* const m, double* const l, int d);
    void Gram_Schmidt(double* const y, double* const z);
    
    void generate_fluctuations_right(double z,  double T,double T_hat,double v, double v_hat, double& F);
    void generate_fluctuations_left(double z,  double T,double T_hat,double v, double v_hat, double& F);
    void rotate_into_physical_basis(double* const n,double* const m,double* const l, double Fn,double Fm,double Fl, double& Fx, double& Fy, double& Fz);
    void rotate_into_orthogonal_basis(double* const n,double* const m,double* const l, double Tx,double Ty,double Tz, double& Tn, double& Tm, double& Tl);
    void extract_tractions_and_particle_velocity(double* const n, const double* const Q, double& Tx,double& Ty,double& Tz,double& vx,double& vy,double& vz );
    void get_normals(int normalNonZeroIndex,double& norm, double* const n,const double* const Q);
    void extract_tractions(double sxx, double syy, double szz, double sxy, double sxz, double syz, double* const n, double& Tx,double& Ty,double& Tz);
    void initialstresstensor(double& sxx, double& syy, double& szz, double& sxy, double& sxz, double& syz, double* const x);


    //rupture Dynamics

    void prestress(double& T0_n, double& T0_m, double& T0_l, double* const x, double t, double* const l, double* const m, double* const n);
    double boxcar(double& f, double x, double w);
    void TauStrength(double& tau_str, double sigma_n, double S, double* const x, double t);
    void slip_weakening(double& v1, double& v2, double& Vel, double& tau1, double& tau2,
			double phi_1, double phi_2, double eta, double tau_str, double sigma_n);
    void SlipWeakeningFriction(double vn_p,double vn_m, double Tn_p, double Tn_m, double zp_p , double zp_m, double& vn_hat_p , double& vn_hat_m, double& Tn_hat_p, double& Tn_hat_m, double vm_p,double vm_m, double Tm_p, double Tm_m, double zl_p , double zl_m, double& vm_hat_p , double& vm_hat_m, double& Tm_hat_p, double& Tm_hat_m, double vl_p,double vl_m, double Tl_p, double Tl_m, double zm_p , double zm_m, double& vl_hat_p , double& vl_hat_m, double& Tl_hat_p, double& Tl_hat_m, double* const l, double* const m, double* const n, double* const x, double S);
    void beginTimeStep(const double minTimeStamp) override;
};



#endif // __MyElasticWaveSolver_CLASS_HEADER__
