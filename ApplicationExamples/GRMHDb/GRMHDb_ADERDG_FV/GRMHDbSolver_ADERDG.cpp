// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "GRMHDbSolver_ADERDG.h"

#include "GRMHDbSolver_ADERDG_Variables.h"

// User defined calls
#include "Tools.h"
#include "PDE.h"
#include "InitialData.h"
#include "TECPLOTinterface.h"
#include "tarch/parallel/Node.h"
#include "tarch/la/MatrixVectorOperations.h"

#include "GRMHDbSolver_FV.h"  // for FV patchsize and ghostlayerwidth

#include <algorithm>

#include <cstring> // memset

#include <string>

#include <math.h>

#include "peano/utils/Loop.h"

#include "kernels/KernelUtils.h" // matrix indexing
#include "kernels/GaussLegendreBasis.h"


#include "tarch/multicore/BooleanSemaphore.h"

#include "tarch/multicore/Lock.h"

tarch::logging::Log GRMHDb::GRMHDbSolver_ADERDG::_log( "GRMHDb::GRMHDbSolver_ADERDG" );


void GRMHDb::GRMHDbSolver_ADERDG::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  // Tip: You find documentation for this method in header file "GRMHDb::GRMHDbSolver_ADERDG.h".
  
  // @todo Please implement/augment if required

	constexpr int order = GRMHDb::AbstractGRMHDbSolver_ADERDG::Order;
	constexpr int basisSize = AbstractGRMHDbSolver_FV::PatchSize;
	constexpr int Ghostlayers = AbstractGRMHDbSolver_FV::GhostLayerWidth;
    int mpirank = tarch::parallel::Node::getInstance().getRank();

	/**************************************************************************/
	static tarch::multicore::BooleanSemaphore initializationSemaphoreDG;
	tarch::multicore::Lock lock(initializationSemaphoreDG);
	/***************************************************/
	// everything in here is thread-safe w.r.t. the lock
	// call Fortran routines
	/***********************/

	//printf("\n******************************************************************");
	//printf("\n**************<<<  INIT TECPLOT    >>>****************************");
	//printf("\n******************************************************************");
     inittecplot_(&order,&basisSize,&Ghostlayers);
	 printf("\n******************************************************************");
	 printf("\n**************<<<  INIT PDE SETUP  >>>****************************");
	 printf("\n******************************************************************");
     pdesetup_(&mpirank);
	 printf("\n******************************************************************");
	 printf("\n**************<<<       DONE       >>>****************************");
	 printf("\n******************************************************************");
  //fflush(stdout);


	/************/
	 lock.free();
	 // everything afterwards is not thread-safe anymore w.r.t. the lock
	 /**************************************************************************/
}

void GRMHDb::GRMHDbSolver_ADERDG::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
  // Tip: You find documentation for this method in header file "GRMHDb::GRMHDbSolver_ADERDG.h".
  // Tip: See header file "GRMHDb::AbstractGRMHDbSolver_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // Dimensions                        = 3
  // Number of variables + parameters  = 19 + 0
  // @todo Please implement/augment if required
	//const int numberOfData = GRMHDb::AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
  if (tarch::la::equals(t,0.0)) {
  
    Q[0] = 0.0;
    Q[1] = 0.0;
    Q[2] = 0.0;
    Q[3] = 0.0;
    Q[4] = 0.0;
    Q[5] = 0.0;
    Q[6] = 0.0;
    Q[7] = 0.0;
    Q[8] = 0.0;
    Q[9] = 0.0;
    Q[10] = 0.0;
    Q[11] = 0.0;
    Q[12] = 0.0;
    Q[13] = 0.0;
    Q[14] = 0.0;
    Q[15] = 0.0;
    Q[16] = 0.0;
    Q[17] = 0.0;
    Q[18] = 0.0;


	/**************************************************************************/
	static tarch::multicore::BooleanSemaphore initialDataSemaphoreDG;
	tarch::multicore::Lock lock(initialDataSemaphoreDG);
	/***************************************************/
	// everything in here is thread-safe w.r.t. the lock
	// call Fortran routines
	/***********************/
	/*
	double x3D[3] = {0.};
	for(int i=0;i<DIMENSIONS;i++){
	    x3D[i]=x[i];
        }*/

    initialdata_(x, &t, Q);

	/************/
	lock.free();
	// everything afterwards is not thread-safe anymore w.r.t. the lock
	/**************************************************************************/

	//Q[3] = Q[0];
	//Q[0] = exp(-(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]) / 8.0);
	//Q[1] = sin(x[1])*sin(x[0]);
	//Q[2] = sin(x[2]);
//	for (int i = 3; i < nVar; i++) {
//		Q[i] = cos(x[0]);
//	}
  }
}


void GRMHDb::GRMHDbSolver_ADERDG::boundaryValues(const double* const x, const double t, const double dt, const int faceIndex, const int normalNonZero, 
	const double * const fluxIn, const double* const stateIn, const double* const gradStateIn, 
	double *fluxOut, double* stateOut) {
  // Tip: You find documentation for this method in header file "GRMHDb::GRMHDbSolver_ADERDG.h".
  // Tip: See header file "GRMHDb::AbstractGRMHDbSolver_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  constexpr int numberOfVariables = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
  constexpr int numberOfParameters = AbstractGRMHDbSolver_ADERDG::NumberOfParameters;
  constexpr int numberOfData = numberOfVariables + numberOfParameters;
  //constexpr int numberOfData = AbstractGRMHDbSolver_FV::NumberOfVariables;
  const int order = GRMHDb::AbstractGRMHDbSolver_ADERDG::Order;
  const int basisSize = order + 1;
  const int nDim = DIMENSIONS;
  double Qgp[numberOfData],*F[nDim], Fs[nDim][numberOfData];


  // Dimensions                        = 3
  // Number of variables + parameters  = 19 + 0

  // @todo Please implement/augment if required
  stateOut[0] = 0.0;
  stateOut[1] = 0.0;
  stateOut[2] = 0.0;
  stateOut[3] = 0.0;
  stateOut[4] = 0.0;
  stateOut[5] = 0.0;
  stateOut[6] = 0.0;
  stateOut[7] = 0.0;
  stateOut[8] = 0.0;
  stateOut[9] = 0.0;
  stateOut[10] = 0.0;
  stateOut[11] = 0.0;
  stateOut[12] = 0.0;
  stateOut[13] = 0.0;
  stateOut[14] = 0.0;
  stateOut[15] = 0.0;
  stateOut[16] = 0.0;
  stateOut[17] = 0.0;
  stateOut[18] = 0.0;

  fluxOut[0] = 0.0;
  fluxOut[1] = 0.0;
  fluxOut[2] = 0.0;
  fluxOut[3] = 0.0;
  fluxOut[4] = 0.0;
  fluxOut[5] = 0.0;
  fluxOut[6] = 0.0;
  fluxOut[7] = 0.0;
  fluxOut[8] = 0.0;
  fluxOut[9] = 0.0;
  fluxOut[10] = 0.0;
  fluxOut[11] = 0.0;
  fluxOut[12] = 0.0;
  fluxOut[13] = 0.0;
  fluxOut[14] = 0.0;
  fluxOut[15] = 0.0;
  fluxOut[16] = 0.0;
  fluxOut[17] = 0.0;
  fluxOut[18] = 0.0;


 /* stateOut[0] = exp(-(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]) / 8.0);
  stateOut[1] = sin(x[1])*sin(x[0]);
  stateOut[2] = sin(x[2]);
  for (int i = 3; i < numberOfData; i++) {
	  stateOut[i] = cos(x[0]);
  }
  fluxOut[0] = exp(-(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]) / 8.0);
  fluxOut[1] = sin(x[1])*sin(x[0]);
  fluxOut[2] = sin(x[2]);
  for (int i = 3; i < numberOfData; i++) {
	  fluxOut[i] = cos(x[0]);
  }*/
 
 
 //// STANDARD ANALYTICAL BOUNDARY CONDITIONS:

 for(int dd=0; dd<nDim; dd++) F[dd] = Fs[dd];

 for(int i=0; i < basisSize; i++)  { // i == time
	  const double weight = kernels::legendre::weights[order][i];
	  const double xi = kernels::legendre::nodes[order][i];
	  double ti = t + xi * dt;

	  initialdata_(x, &ti, Qgp);
	  //pdeflux_(F[0], F[1], F[2], Qgp);
	  flux(Qgp, F);
          for(int m=0; m < numberOfData; m++) {
		  stateOut[m] += weight * Qgp[m];
		  fluxOut[m] += weight * Fs[normalNonZero][m];
	  }
 }

/*
  // THIS IS FOR THE 1D Riemann problems (invisicd reflective boundary conditions at the y boundaries)
  if (normalNonZero == 0) {
	  // STANDARD ANALYTICAL BOUNDARY CONDITIONS:
	  for (int dd = 0; dd < nDim; dd++) F[dd] = Fs[dd];

	  for (int i = 0; i < basisSize; i++) { // i == time
		  const double weight = kernels::legendre::weights[order][i];
		  const double xi = kernels::legendre::nodes[order][i];
		  double ti = t + xi * dt;

		  initialdata_(x, &ti, Qgp);
		  //pdeflux_(F[0], F[1], F[2], Qgp);
		  flux(Qgp, F);
		  for (int m = 0; m < numberOfData; m++) {
			  stateOut[m] += weight * Qgp[m];
			  fluxOut[m] += weight * Fs[normalNonZero][m];
		  }
	  }
  }
  else { // inviscid wall boundary conditions (pure reflection)
	  std::copy_n(stateIn, numberOfVariables, stateOut);
	  stateOut[1 + normalNonZero] = -stateOut[1 + normalNonZero]; 
	  flux(stateOut, F); 
	  std::copy_n(F[normalNonZero], numberOfVariables, fluxOut);
  }
*/

  /*
	for(int m=0; m < numberOfData; m++) {
	stateOut[m] = stateIn[m];
	fluxOut[m] = fluxIn[m];
	}
	*/
}

exahype::solvers::Solver::RefinementControl GRMHDb::GRMHDbSolver_ADERDG::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) {
  // Tip: You find documentation for this method in header file "GRMHDb::GRMHDbSolver_ADERDG.h".
  // Tip: See header file "GRMHDb::AbstractGRMHDbSolver_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // Tip: See header file "peano/utils/Loop.h" for dimension-agnostic for loops.
  
  //  Example: Loop over all pointwise state variables (plus parameters)
  //
  //  constexpr int sizeOfQ = NumberOfVariables+NumberOfParameters;
  //  dfor(i,Order+1) {
  //    const int iLinearised = dLinearised(i,Order+1);
  //    const double* const Q = luh + iLinearised * sizeOfQ; // pointwise state variables (plus parameters)
  //    // use Q[0], Q[1], ... Q[sizeOfQ-1]
  //  }
  
  // @todo Please implement/augment if required
        //return exahype::solvers::Solver::RefinementControl::Keep;	
	//constexpr int numberOfVariables = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	//constexpr int numberOfParameters = AbstractGRMHDbSolver_ADERDG::NumberOfParameters;
	//constexpr int numberOfData = numberOfVariables + numberOfParameters;
	//constexpr int numberOfData = AbstractGRMHDbSolver_FV::NumberOfVariables;
	//const int order = GRMHDb::AbstractGRMHDbSolver_ADERDG::Order;
	//const int basisSize = order + 1;
	//const int nDim = DIMENSIONS; 
        
        //printf("\n******* refinementCriterion *****************");
	
	
        //return exahype::solvers::Solver::RefinementControl::Keep;

	
	double dr;
    if(DIMENSIONS == 2){
        dr = dx[0] * dx[0] + dx[1] * dx[1];
    }else{
        dr = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];
        }

        
        dr = sqrt(dr);
        
        double radiusC;
    if(DIMENSIONS == 2){
        radiusC = center[0] * center[0] + center[1] * center[1];
    }else{
        radiusC = center[0] * center[0] + center[1] * center[1] + center[2] * center[2];
        }

        if(radiusC > 0.){
                radiusC = sqrt(radiusC);
        }
        if (radiusC-0.5*dr < 8.33) {
          if (radiusC + 0.5*dr > 7.95) {
            return exahype::solvers::Solver::RefinementControl::Refine;
          }
          else{
           if (level <= getCoarsestMeshLevel()+1) {
                 return exahype::solvers::Solver::RefinementControl::Refine;
            }
            else{
                return exahype::solvers::Solver::RefinementControl::Erase; 
            }
          }            
	}
	else{
	 
	 return exahype::solvers::Solver::RefinementControl::Erase;
	}
	if (level > getCoarsestMeshLevel())  return exahype::solvers::Solver::RefinementControl::Erase;
        return exahype::solvers::Solver::RefinementControl::Keep;
}


//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void GRMHDb::GRMHDbSolver_ADERDG::eigenvalues(const double* const Q,const int d,double* const lambda) {
  // Tip: You find documentation for this method in header file "GRMHDb::GRMHDbSolver_ADERDG.h".
  // Tip: See header file "GRMHDb::AbstractGRMHDbSolver_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // Dimensions                        = 3
  // Number of variables + parameters  = 19 + 0
  
	constexpr int numberOfVariables = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	constexpr int numberOfParameters = AbstractGRMHDbSolver_ADERDG::NumberOfParameters;
	constexpr int numberOfData = numberOfVariables + numberOfParameters;
	//for (int i = 5; i < 8; i++) {
	//	printf("\nQ[%d]=%f", i, Q[i]);
	//	assertion(!std::isnan(Q[i]));
	//}
	//printf("\n******* ADERDG::eigenvalues *****************");
  // @todo Please implement/augment if required
  lambda[0] = 1.0;
  lambda[1] = 1.0;
  lambda[2] = 1.0;
  lambda[3] = 1.0;
  lambda[4] = 1.0;
  lambda[5] = 1.0;
  lambda[6] = 1.0;
  lambda[7] = 1.0;
  lambda[8] = 1.0;
  lambda[9] = 1.0;
  lambda[10] = 1.0;
  lambda[11] = 1.0;
  lambda[12] = 1.0;
  lambda[13] = 1.0;
  lambda[14] = 1.0;
  lambda[15] = 1.0;
  lambda[16] = 1.0;
  lambda[17] = 1.0;
  lambda[18] = 1.0;

  //return;

  double nv[DIMENSIONS] = {0.};
  nv[d] = 1.0;
  pdeeigenvalues_(lambda, Q, nv);
}



void GRMHDb::GRMHDbSolver_ADERDG::referenceSolution(const double* const x,double t, double* Q) {
	//const int numberOfData = GRMHDb::AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	//const int numberOfData = GRMHDb::AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	constexpr int numberOfVariables = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	constexpr int numberOfParameters = AbstractGRMHDbSolver_ADERDG::NumberOfParameters;
	constexpr int numberOfData = numberOfVariables + numberOfParameters;
	//constexpr int numberOfData = AbstractGRMHDbSolver_FV::NumberOfVariables;
	int iErr;
	double Qcons[numberOfData];
	iErr = 0;

       // printf("\n******* :referenceSolution  *****************");
/*
        double x3D[3]={0.};
        for(int i=0;i<DIMENSIONS;i++){
          x3D[i]=x[i];
        }*/
        //printf("x3d_ADERDG:  %f,  %f",x3D[0],x3D[1]);
	//printf("\nSONO QUI IN referenceSolution ADERDG");
	initialdata_(x, &t, &Qcons[0]);
	
	//// test:
	//Q[0] = exp(-(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]) / 8.0);
	//	Q[1] = sin(x[1])*sin(x[0]);
	//	Q[2] = sin(x[2]);
	//for (int i = 3; i < numberOfData; i++) {
	//	Q[i] = cos(x[0]);
	//}
	pdecons2prim_(Q, &Qcons[0], &iErr);
}


void GRMHDb::GRMHDbSolver_ADERDG::flux(const double* const Q,double** const F) {
  // Tip: You find documentation for this method in header file "GRMHDb::GRMHDbSolver_ADERDG.h".
  // Tip: See header file "GRMHDb::AbstractGRMHDbSolver_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  // Dimensions                        = 3
  // Number of variables + parameters  = 19 + 0
  
  // @todo Please implement/augment if required
  F[0][0] = 0.0;
  F[0][1] = 0.0;
  F[0][2] = 0.0;
  F[0][3] = 0.0;
  F[0][4] = 0.0;
  F[0][5] = 0.0;
  F[0][6] = 0.0;
  F[0][7] = 0.0;
  F[0][8] = 0.0;
  F[0][9] = 0.0;
  F[0][10] = 0.0;
  F[0][11] = 0.0;
  F[0][12] = 0.0;
  F[0][13] = 0.0;
  F[0][14] = 0.0;
  F[0][15] = 0.0;
  F[0][16] = 0.0;
  F[0][17] = 0.0;
  F[0][18] = 0.0;
  
  F[1][0] = 0.0;
  F[1][1] = 0.0;
  F[1][2] = 0.0;
  F[1][3] = 0.0;
  F[1][4] = 0.0;
  F[1][5] = 0.0;
  F[1][6] = 0.0;
  F[1][7] = 0.0;
  F[1][8] = 0.0;
  F[1][9] = 0.0;
  F[1][10] = 0.0;
  F[1][11] = 0.0;
  F[1][12] = 0.0;
  F[1][13] = 0.0;
  F[1][14] = 0.0;
  F[1][15] = 0.0;
  F[1][16] = 0.0;
  F[1][17] = 0.0;
  F[1][18] = 0.0;
  
#ifdef Dim3
  F[2][0] = 0.0;
  F[2][1] = 0.0;
  F[2][2] = 0.0;
  F[2][3] = 0.0;
  F[2][4] = 0.0;
  F[2][5] = 0.0;
  F[2][6] = 0.0;
  F[2][7] = 0.0;
  F[2][8] = 0.0;
  F[2][9] = 0.0;
  F[2][10] = 0.0;
  F[2][11] = 0.0;
  F[2][12] = 0.0;
  F[2][13] = 0.0;
  F[2][14] = 0.0;
  F[2][15] = 0.0;
  F[2][16] = 0.0;
  F[2][17] = 0.0;
  F[2][18] = 0.0;
#endif
  
    if(DIMENSIONS == 2){
		constexpr int numberOfVariables = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
		constexpr int numberOfParameters = AbstractGRMHDbSolver_ADERDG::NumberOfParameters;
		constexpr int numberOfData = numberOfVariables + numberOfParameters;
		double F_3[numberOfData];
		pdeflux_(F[0], F[1],F_3, Q);
	}else{
		pdeflux_(F[0], F[1],F[2], Q);
	}
   

  //pdeflux_(&F[0][0], Q);
 
}



void  GRMHDb::GRMHDbSolver_ADERDG::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  // Tip: You find documentation for this method in header file "GRMHDb::GRMHDbSolver_ADERDG.h".
  // Tip: See header file "GRMHDb::AbstractGRMHDbSolver_ADERDG.h" for toolkit generated compile-time 
  //      constants such as Order, NumberOfVariables, and NumberOfParameters.
  
  // @todo Please implement/augment if required
  BgradQ[0] = 0.0;
  BgradQ[1] = 0.0;
  BgradQ[2] = 0.0;
  BgradQ[3] = 0.0;
  BgradQ[4] = 0.0;
  BgradQ[5] = 0.0;
  BgradQ[6] = 0.0;
  BgradQ[7] = 0.0;
  BgradQ[8] = 0.0;
  BgradQ[9] = 0.0;
  BgradQ[10] = 0.0;
  BgradQ[11] = 0.0;
  BgradQ[12] = 0.0;
  BgradQ[13] = 0.0;
  BgradQ[14] = 0.0;
  BgradQ[15] = 0.0;
  BgradQ[16] = 0.0;
  BgradQ[17] = 0.0;
  BgradQ[18] = 0.0;
  pdencp_(BgradQ, Q, gradQ);
}

void GRMHDb::GRMHDbSolver_ADERDG::mapDiscreteMaximumPrincipleObservables(
	double* const observables,
	const double* const Q) const {
	
                if (NumberOfDMPObservables>0) {
                        std::copy_n(Q,NumberOfDMPObservables,observables);
                }
/*
	for (int i = 0; i < NumberOfVariables; ++i) {
		observables[i] = Q[i];
	}*/
}



bool GRMHDb::GRMHDbSolver_ADERDG::vetoDiscreteMaximumPrincipleDecision(
		const double* const                         solution,
		const double* const                         localObservablesMin,
		const double* const                         localObservablesMax,
		const bool                                  wasTroubledInPreviousTimeStep,
		const tarch::la::Vector<DIMENSIONS, double>& center,
		const tarch::la::Vector<DIMENSIONS, double>& dx,
		const double                                timeStamp) const {
	

  //printf("\n ************* vetoDiscreteMaximumPrincipleDecision ***************");

	return false; // do not veto = false; veto = true;	

	//int limvalue;
	//int NumberOfObservables;
	//NumberOfObservables=1;
	//pdelimitervalue_(&limvalue,&center[0]);
	//pdelimitervalue_(&limvalue,&center[0],&NumberOfObservables, observablesMin, observablesMax);
	//if(limvalue>0){
	  //  return false;
	//}else{
	  //  return true;
	//};
	  //return false;
	  
	  
	  double dr;
    if(DIMENSIONS == 2){
        dr = dx[0] * dx[0] + dx[1] * dx[1];
    }else{
    	dr = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];
    	}
	dr = sqrt(dr);
	double radiusC;
    if(DIMENSIONS == 2){
        radiusC = center[0] * center[0] + center[1] * center[1];
    }else{
        radiusC = center[0] * center[0] + center[1] * center[1] + center[2] * center[2];
        }
	if (radiusC > 0.) {
		radiusC = sqrt(radiusC);
	}
	if (radiusC + 0.5*dr < 8.05) {
		return false;
	}
	else {
		return true;
	}
	
}

bool GRMHDb::GRMHDbSolver_ADERDG::isPhysicallyAdmissible(
	const double* const solution,
	const double* const observablesMin, const double* const observablesMax,
	const bool wasTroubledInPreviousTimeStep,
	const tarch::la::Vector<DIMENSIONS, double>& center,
	const tarch::la::Vector<DIMENSIONS, double>& dx,
	const double t) const {
	
	
  //printf("\n ************* isPhysicallyAdmissible ***************");

	return false; // false = limit all
  //int limvalue;
  //int NumberOfObservables;
  //NumberOfObservables=1;
  //pdelimitervalue_(&limvalue,&center[0]);
  //pdelimitervalue_(&limvalue,&center[0],&NumberOfObservables, observablesMin, observablesMax);
  //if(limvalue>0){
	//  return false;
  //}else{
	//  return true;
  //};
	//return false;
#ifdef Dim2
	double dr;
	dr = dx[0] * dx[0] + dx[1] * dx[1];
        dr = sqrt(dr);
	double radiusC;
		radiusC = center[0] * center[0] + center[1] * center[1];
	if (radiusC > 0.) {
		radiusC = sqrt(radiusC);		
	}		
        if (radiusC + 0.5*dr > 8.05 && radiusC-0.5*dr < 8.35) {
	//if (radiusC > 7.6 && radiusC < 8.5) {
		return false;
	}
	else {
		return true;
	}
#else
	double dr;
	dr = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];
	dr = sqrt(dr);
	double radiusC;
	radiusC = center[0] * center[0] + center[1] * center[1] + center[2] * center[2];
	if (radiusC > 0.) {
		radiusC = sqrt(radiusC);
	}
	if (radiusC + 0.5*dr > 8.05 && radiusC - 0.5*dr < 8.35) {
		//if (radiusC > 7.6 && radiusC < 8.5) {
		return false;
	}
	else {
		return true;
	}
#endif
}

#ifdef OPT_KERNELS

#include "kernels/GRMHDb_GRMHDbSolver_ADERDG/Kernels.h"


using namespace GRMHDb::GRMHDbSolver_ADERDG_kernels::aderdg;

void GRMHDb::GRMHDbSolver_ADERDG::riemannSolver(double* const FL, double* const FR, const double* const QL, const double* const QR, const double t, const double dt, const tarch::la::Vector<DIMENSIONS, double>& lengthScale, const int direction, bool isBoundaryFace, int faceIndex) {
	assertion2(direction >= 0, dt, direction);
	assertion2(direction<DIMENSIONS, dt, direction);
	GRMHDb::GRMHDbSolver_ADERDG_kernels::aderdg::riemannSolver(*static_cast<GRMHDbSolver_ADERDG*>(this), FL, FR, QL, QR, t, dt, direction);
	constexpr int order = GRMHDb::AbstractGRMHDbSolver_ADERDG::Order;
	constexpr int basisSize = order + 1;
	constexpr int numberOfVariables = GRMHDb::GRMHDbSolver_ADERDG_kernels::aderdg::getNumberOfVariablePadded();   //              AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	// avoid spurious numerical diffusion (ony for Cowling approximation)
	
#ifdef Dim2
	kernels::idx2 idx_FLR(basisSize, numberOfVariables);
        for (int i = 0; i < basisSize; i++) {
                        //resetNumericalDiffusionOnADM(FL + idx_FLR(i, j, 0));
                        //resetNumericalDiffusionOnADM(FR + idx_FLR(i, j, 0));
                        double* FLL = FL + idx_FLR(i, 0);
                        double* FRR = FR + idx_FLR(i, 0);
                        for (int m = 9; m < numberOfVariables; m++) {
                                FLL[m] = 0.0;
                                FRR[m] = 0.0;
                }
        }
#else
	kernels::idx3 idx_FLR(basisSize, basisSize, numberOfVariables);
	for (int i = 0; i < basisSize; i++) {
		for (int j = 0; j < basisSize; j++) {
			//resetNumericalDiffusionOnADM(FL + idx_FLR(i, j, 0));
			//resetNumericalDiffusionOnADM(FR + idx_FLR(i, j, 0));
			double* FLL = FL + idx_FLR(i, j, 0);
			double* FRR = FR + idx_FLR(i, j, 0);
			for (int m = 9; m < numberOfVariables; m++) {
				FLL[m] = 0.0;
				FRR[m] = 0.0;
			}
		}
	}
#endif

}


#else

#include "kernels/aderdg/generic/Kernels.h" 
void GRMHDb::GRMHDbSolver_ADERDG::riemannSolver(double* const FL, double* const FR, const double* const QL, const double* const QR, const double t, const double dt, const tarch::la::Vector<DIMENSIONS, double>& dx, const int direction, bool isBoundaryFace, int faceIndex) {
	assertion2(direction >= 0, dt, direction);
	assertion2(direction<DIMENSIONS, dt, direction);
	kernels::aderdg::generic::c::riemannSolverNonlinear<true, false, GRMHDbSolver_ADERDG>(*static_cast<GRMHDbSolver_ADERDG*>(this), FL, FR, QL, QR, t, dt, dx, direction);
 

	constexpr int order = GRMHDb::AbstractGRMHDbSolver_ADERDG::Order;
	constexpr int basisSize = order + 1;
	constexpr int numberOfVariables = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	// avoid spurious numerical diffusion (ony for Cowling approximation)
	
	//printf("\n******* RIEMANN SOLVER *****************");
	
#ifdef Dim2	
	kernels::idx2 idx_FLR(basisSize, numberOfVariables);
	for (int i = 0; i < basisSize; i++) {
			//resetNumericalDiffusionOnADM(FL + idx_FLR(i, j, 0));
			//resetNumericalDiffusionOnADM(FR + idx_FLR(i, j, 0));
			double* FLL = FL + idx_FLR(i, 0);
			double* FRR = FR + idx_FLR(i, 0);
			for (int m = 9; m < numberOfVariables; m++) {
				FLL[m] = 0.0;
				FRR[m] = 0.0;
		}
	}
#else
	kernels::idx3 idx_FLR(basisSize, basisSize, numberOfVariables);
	for (int i = 0; i < basisSize; i++) {
		for (int j = 0; j < basisSize; j++) {
			//resetNumericalDiffusionOnADM(FL + idx_FLR(i, j, 0));
			//resetNumericalDiffusionOnADM(FR + idx_FLR(i, j, 0));
			double* FLL = FL + idx_FLR(i, j, 0);
			double* FRR = FR + idx_FLR(i, j, 0);
			for (int m = 9; m < numberOfVariables; m++) {
				FLL[m] = 0.0;
				FRR[m] = 0.0;
			}
		}
	}
#endif


}
#endif

