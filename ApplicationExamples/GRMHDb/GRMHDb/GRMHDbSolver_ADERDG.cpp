// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "GRMHDbSolver_ADERDG.h"
#include "GRMHDbSolver_ADERDG_Variables.h"

// User defined calls
#include "Tools.h"
#include "PDE.h"
#include "InitialData.h"
#include "TECPLOTinterface.h"
#include "tarch/parallel/Node.h"
#include "tarch/la/MatrixVectorOperations.h"

#include <algorithm>

#include <cstring> // memset

#include <string>

#include <math.h>

#include "peano/utils/Loop.h"

#include "kernels/KernelUtils.h" // matrix indexing
#include "kernels/GaussLegendreQuadrature.h"

tarch::logging::Log GRMHDb::GRMHDbSolver_ADERDG::_log( "GRMHDb::GRMHDbSolver_ADERDG" );


void GRMHDb::GRMHDbSolver_ADERDG::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
	// @todo Please implement/augment if required
	int mpirank = tarch::parallel::Node::getInstance().getRank();
	const int order = GRMHDb::AbstractGRMHDbSolver_ADERDG::Order;	
	constexpr int basisSize = 7; //AbstractGRMHDbSolver_FV::PatchSize;	
	constexpr int Ghostlayers = 2; //AbstractGRMHDbSolver_FV::GhostLayerWidth;
	//printf("\n******************************************************************");
	//printf("\n**************<<<  INIT TECPLOT    >>>****************************");
	//printf("\n******************************************************************");
	inittecplot_(&order,&order,&basisSize,&Ghostlayers);
	//printf("\n******************************************************************");
	//printf("\n**************<<<  INIT PDE SETUP  >>>****************************");
	//printf("\n******************************************************************");
	pdesetup_(&mpirank);
	//printf("\n******************************************************************");
	//printf("\n**************<<<       DONE       >>>****************************");
	//printf("\n******************************************************************");
	fflush(stdout);

}

void GRMHDb::GRMHDbSolver_ADERDG::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
	// Dimensions                        = 3
	// Number of variables + parameters  = 19 + 0
	// @todo Please implement/augment if required
	if (tarch::la::equals(t,0.0)) {
		Q[0] = 0.0;
		Q[1] = 0.0;
		Q[2] = 0.0;
		Q[3] = 0.0;
		Q[4] = 0.0;
		Q[5] = 0.0;
		Q[6] = 0.0;
		Q[7] = 0.0;
		Q[8] = 0.0;
		Q[9] = 0.0;
		Q[10] = 0.0;
		Q[11] = 0.0;
		Q[12] = 0.0;
		Q[13] = 0.0;
		Q[14] = 0.0;
		Q[15] = 0.0;
		Q[16] = 0.0;
		Q[17] = 0.0;
		Q[18] = 0.0;
		initialdata_(x, &t, Q);
	}
}

void GRMHDb::GRMHDbSolver_ADERDG::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {
	const int nVar = GRMHDb::AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
	const int order = GRMHDb::AbstractGRMHDbSolver_ADERDG::Order;
	const int basisSize = order + 1;
	const int nDim = DIMENSIONS;
	double Qgp[nVar],*F[nDim], Fs[nDim][nVar];


	// Dimensions                        = 3
	// Number of variables + parameters  = 19 + 0

	// @todo Please implement/augment if required
	stateOut[0] = 0.0;
	stateOut[1] = 0.0;
	stateOut[2] = 0.0;
	stateOut[3] = 0.0;
	stateOut[4] = 0.0;
	stateOut[5] = 0.0;
	stateOut[6] = 0.0;
	stateOut[7] = 0.0;
	stateOut[8] = 0.0;
	stateOut[9] = 0.0;
	stateOut[10] = 0.0;
	stateOut[11] = 0.0;
	stateOut[12] = 0.0;
	stateOut[13] = 0.0;
	stateOut[14] = 0.0;
	stateOut[15] = 0.0;
	stateOut[16] = 0.0;
	stateOut[17] = 0.0;
	stateOut[18] = 0.0;

	fluxOut[0] = 0.0;
	fluxOut[1] = 0.0;
	fluxOut[2] = 0.0;
	fluxOut[3] = 0.0;
	fluxOut[4] = 0.0;
	fluxOut[5] = 0.0;
	fluxOut[6] = 0.0;
	fluxOut[7] = 0.0;
	fluxOut[8] = 0.0;
	fluxOut[9] = 0.0;
	fluxOut[10] = 0.0;
	fluxOut[11] = 0.0;
	fluxOut[12] = 0.0;
	fluxOut[13] = 0.0;
	fluxOut[14] = 0.0;
	fluxOut[15] = 0.0;
	fluxOut[16] = 0.0;
	fluxOut[17] = 0.0;
	fluxOut[18] = 0.0;

	for(int dd=0; dd<nDim; dd++) F[dd] = Fs[dd];

	for(int i=0; i < basisSize; i++)  { // i == time
		const double weight = kernels::gaussLegendreWeights[order][i];
		const double xi = kernels::gaussLegendreNodes[order][i];
		double ti = t + xi * dt;

		initialdata_(x, &ti, Qgp);
		//pdeflux_(F[0], F[1], F[2], Qgp);
		flux(Qgp, F);
		for(int m=0; m < nVar; m++) {
			stateOut[m] += weight * Qgp[m];
			fluxOut[m] += weight * Fs[normalNonZero][m];
		}
	}
	/*
	   for(int m=0; m < nVar; m++) {
	   stateOut[m] = stateIn[m];
	   fluxOut[m] = fluxIn[m];
	   }
	 */
}

exahype::solvers::Solver::RefinementControl GRMHDb::GRMHDbSolver_ADERDG::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) {
	// @todo Please implement/augment if required
	return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void GRMHDb::GRMHDbSolver_ADERDG::eigenvalues(const double* const Q,const int d,double* const lambda) {
	// Dimensions                        = 3
	// Number of variables + parameters  = 19 + 0

	// @todo Please implement/augment if required
	lambda[0] = 1.0;
	lambda[1] = 1.0;
	lambda[2] = 1.0;
	lambda[3] = 1.0;
	lambda[4] = 1.0;
	lambda[5] = 1.0;
	lambda[6] = 1.0;
	lambda[7] = 1.0;
	lambda[8] = 1.0;
	lambda[9] = 1.0;
	lambda[10] = 1.0;
	lambda[11] = 1.0;
	lambda[12] = 1.0;
	lambda[13] = 1.0;
	lambda[14] = 1.0;
	lambda[15] = 1.0;
	lambda[16] = 1.0;
	lambda[17] = 1.0;
	lambda[18] = 1.0;
	double nv[3] = {0.};
	nv[d] = 1;
	pdeeigenvalues_(lambda, Q, nv);
}



void GRMHDb::GRMHDbSolver_ADERDG::referenceSolution(const double* const x,double t, double* const Q) { 

	initialdata_(x, &t, Q);
}


void GRMHDb::GRMHDbSolver_ADERDG::flux(const double* const Q,double** const F) {
	// Dimensions                        = 3
	// Number of variables + parameters  = 19 + 0

	// @todo Please implement/augment if required
	F[0][0] = 0.0;
	F[0][1] = 0.0;
	F[0][2] = 0.0;
	F[0][3] = 0.0;
	F[0][4] = 0.0;
	F[0][5] = 0.0;
	F[0][6] = 0.0;
	F[0][7] = 0.0;
	F[0][8] = 0.0;
	F[0][9] = 0.0;
	F[0][10] = 0.0;
	F[0][11] = 0.0;
	F[0][12] = 0.0;
	F[0][13] = 0.0;
	F[0][14] = 0.0;
	F[0][15] = 0.0;
	F[0][16] = 0.0;
	F[0][17] = 0.0;
	F[0][18] = 0.0;

	F[1][0] = 0.0;
	F[1][1] = 0.0;
	F[1][2] = 0.0;
	F[1][3] = 0.0;
	F[1][4] = 0.0;
	F[1][5] = 0.0;
	F[1][6] = 0.0;
	F[1][7] = 0.0;
	F[1][8] = 0.0;
	F[1][9] = 0.0;
	F[1][10] = 0.0;
	F[1][11] = 0.0;
	F[1][12] = 0.0;
	F[1][13] = 0.0;
	F[1][14] = 0.0;
	F[1][15] = 0.0;
	F[1][16] = 0.0;
	F[1][17] = 0.0;
	F[1][18] = 0.0;

	F[2][0] = 0.0;
	F[2][1] = 0.0;
	F[2][2] = 0.0;
	F[2][3] = 0.0;
	F[2][4] = 0.0;
	F[2][5] = 0.0;
	F[2][6] = 0.0;
	F[2][7] = 0.0;
	F[2][8] = 0.0;
	F[2][9] = 0.0;
	F[2][10] = 0.0;
	F[2][11] = 0.0;
	F[2][12] = 0.0;
	F[2][13] = 0.0;
	F[2][14] = 0.0;
	F[2][15] = 0.0;
	F[2][16] = 0.0;
	F[2][17] = 0.0;
	F[2][18] = 0.0;

	if(DIMENSIONS == 2){
		const int nVar = GRMHDb::AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
		double F_3[nVar];
		pdeflux_(F[0], F[1],F_3, Q);
	}else{
		pdeflux_(F[0], F[1],F[2], Q);
	}

}



void  GRMHDb::GRMHDbSolver_ADERDG::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
	// @todo Please implement/augment if required
	BgradQ[0] = 0.0;
	BgradQ[1] = 0.0;
	BgradQ[2] = 0.0;
	BgradQ[3] = 0.0;
	BgradQ[4] = 0.0;
	BgradQ[5] = 0.0;
	BgradQ[6] = 0.0;
	BgradQ[7] = 0.0;
	BgradQ[8] = 0.0;
	BgradQ[9] = 0.0;
	BgradQ[10] = 0.0;
	BgradQ[11] = 0.0;
	BgradQ[12] = 0.0;
	BgradQ[13] = 0.0;
	BgradQ[14] = 0.0;
	BgradQ[15] = 0.0;
	BgradQ[16] = 0.0;
	BgradQ[17] = 0.0;
	BgradQ[18] = 0.0;
	pdencp_(BgradQ, Q, gradQ);
}

void GRMHDb::GRMHDbSolver_ADERDG::mapDiscreteMaximumPrincipleObservables(
		double* const observables, const int NumberOfVariables,
		const double* const Q) const {
	for (int i = 0; i < NumberOfVariables; ++i) {
		observables[i] = Q[i];
	}
}
bool GRMHDb::GRMHDbSolver_ADERDG::isPhysicallyAdmissible(
		const double* const solution,
		const double* const observablesMin, const double* const observablesMax,
		const bool wasTroubledInPreviousTimeStep,
		const tarch::la::Vector<DIMENSIONS, double>& center,
		const tarch::la::Vector<DIMENSIONS, double>& dx,
		const double t) const {
	//int limvalue;
	//int NumberOfObservables;
	//NumberOfObservables=1;
	//pdelimitervalue_(&limvalue,&center[0]);
	//pdelimitervalue_(&limvalue,&center[0],&NumberOfObservables, observablesMin, observablesMax);
	//if(limvalue>0){
	//  return false;
	//}else{
	//  return true;

	//};
	return true;
}

/* @TODO LR : document
*/
