// This file was generated by the ExaHyPE toolkit.
// It will not be overwritten.
//
//
// ========================
//   www.exahype.eu
// ========================
#include "ErrorWriter.h"
#include "Tools.h"
#include "PDE.h"
#include "GRMHDbSolver_ADERDG.h"
#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/KernelUtils.h"
#include <cmath>

#include <fstream>
#include <iostream>
using namespace std;

#include "peano/utils/Loop.h"
#include "kernels/aderdg/generic/c/sizes.cpph"
#include "kernels/KernelUtils.h" // matrix indexing

#include "tarch/la/VectorOperations.h"

#include <algorithm>

#include <iomanip>

GRMHDb::ErrorWriter::ErrorWriter() : exahype::plotters::ADERDG2UserDefined::ADERDG2UserDefined(){
  // @TODO Please insert your code here.
}


void GRMHDb::ErrorWriter::plotPatch(
    const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch,
    const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* u,
    double timeStamp) {
  // @TODO Please insert your code here.
  constexpr int numberOfVariables  = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
  constexpr int numberOfParameters = AbstractGRMHDbSolver_ADERDG::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables+numberOfParameters;
  constexpr int basisSize          = AbstractGRMHDbSolver_ADERDG::Order+1;
  constexpr int order              = basisSize-1;

  double x[DIMENSIONS];

  kernels::idx4 idx(basisSize,basisSize,basisSize,numberOfData);
  dfor(i,basisSize) {
     double w_dV = 1.0;
     for (int d=0; d<DIMENSIONS; d++) {
       x[d]  = offsetOfPatch[d] + sizeOfPatch[d] * kernels::gaussLegendreNodes[order][i(d)];
       w_dV *= sizeOfPatch[d] * kernels::gaussLegendreWeights[order][i(d)];
     }

     double uAna[numberOfVariables];
     GRMHDbSolver_ADERDG::referenceSolution(x,timeStamp,uAna);

     const double* uNum = u + idx ( (DIMENSIONS==3) ? i(2) : 0, i(1), i(0), 0);

     for (int v=0; v<numberOfVariables; v++) {
        const double uDiff = std::abs(uNum[v]-uAna[v]);
        errorL2[v]   += uDiff*uDiff * w_dV;
        errorL1[v]   += uDiff * w_dV;
        errorLInf[v]  = std::max( errorLInf[v], uDiff );

        normL1Ana[v]  += std::abs(uAna[v]) * w_dV;
        normL2Ana[v]  += uAna[v] * uAna[v] * w_dV;
        normLInfAna[v] = std::max( normLInfAna[v], std::abs(uAna[v]) );
     }
  }
}

void GRMHDb::ErrorWriter::startPlotting( double time) {
  // @TODO Please insert your code here.
  _timeStamp = time;

  std::fill_n(errorL1,  AbstractGRMHDbSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(errorL2,  AbstractGRMHDbSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(errorLInf,AbstractGRMHDbSolver_ADERDG::NumberOfVariables, 0.0);
  
  std::fill_n(normL1Ana,  AbstractGRMHDbSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(normL2Ana,  AbstractGRMHDbSolver_ADERDG::NumberOfVariables, 0.0);
  std::fill_n(normLInfAna,AbstractGRMHDbSolver_ADERDG::NumberOfVariables, 0.0);
}

void GRMHDb::ErrorWriter::finishPlotting() {
  constexpr int numberOfVariables = AbstractGRMHDbSolver_ADERDG::NumberOfVariables;
  ofstream myfile;
  int mpirank = tarch::parallel::Node::getInstance().getRank();

  for (int v=0; v<numberOfVariables; v++) {
    errorL2[v]   = sqrt(errorL2[v]);
    normL2Ana[v] = sqrt(normL2Ana[v]);
  }

  //if (tarch::la::equals(mpirank, 0)) {
    if (tarch::la::equals(_timeStamp, 0.0)) {
    myfile.open("./output/ErrorNorms.dat", ios::trunc);
    myfile << "*********************************************" << std::endl;
    myfile << "**Errors for ADER-DG solver with order=" << AbstractGRMHDbSolver_ADERDG::Order << "**" << std::endl;
    myfile << "*********************************************" << std::endl;
    myfile << "---------------------------------------------" << std::endl;
    myfile << "variable:\t";
    for (int v = 0; v < numberOfVariables; v++) {
      myfile << v << " \t ";
    }
    myfile << std::endl;
    myfile.close();
    }
  //}

  //if (tarch::la::equals(mpirank, 0)) {
		myfile.open("./output/ErrorNorms.dat", ios::app);
		myfile << "*********************************************" << std::endl;
		myfile << "t_eval : " << _timeStamp << std::endl;
  //}
  /*
  std::cout << "**Errors for ADER-DG solver with order="<<AbstractGRMHDbSolver_ADERDG::Order<<"**" << std::endl;
  std::cout << "t_eval : "<<_timeStamp << std::endl;
  std::cout << "variable     : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << v << " \t ";
  }
  std::cout << std::endl;

  std::cout << "absErrorL1   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL1[v] << " \t ";
  }
  std::cout << std::endl;

  std::cout << "absErrorL2   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL2[v] << " \t ";
  }
  std::cout << std::endl;

  std::cout << "absErrorLInf : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorLInf[v] << " \t ";
  }
  std::cout << std::endl;

  std::cout << "relErrorL1   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL1[v]/normL1Ana[v] << " \t ";
  }
  std::cout << std::endl;

  std::cout << "relErrorL2   : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL2[v]/normL2Ana[v] << " \t ";
  }
  std::cout << std::endl;

  std::cout << "relErrorLInf : ";
  for (int v=0; v<numberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorLInf[v]/normLInfAna[v] << " \t ";
  }
  std::cout << std::endl;*/


  /*
    this is for the output to file
  */

  //if (tarch::la::equals(mpirank, 0)) {
		myfile << "ErrorL1:\t";
		for (int v = 0; v < numberOfVariables; v++) {
		  myfile << std::scientific << errorL1[v] << " \t ";
		}
		myfile << std::endl;

		myfile << "ErrorL2:\t";
		for (int v = 0; v < numberOfVariables; v++) {
		  myfile << std::scientific << errorL2[v] << " \t ";
		}
		myfile << std::endl;

		myfile << "ErrorLInf:\t";
		for (int v = 0; v < numberOfVariables; v++) {
		  myfile << std::scientific << errorLInf[v] << " \t ";
		}
		myfile << std::endl;
   //}


  /*
  myfile << "relErrorL1   : ";
  for (int v = 0; v < numberOfVariables; v++) {
    myfile << std::setprecision(2) << errorL1[v] / normL1Ana[v] << " \t ";
  }
  myfile << std::endl;

  myfile << "relErrorL2   : ";
  for (int v = 0; v < numberOfVariables; v++) {
    myfile << std::setprecision(2) << errorL2[v] / normL2Ana[v] << " \t ";
  }
  myfile << std::endl;

  myfile << "relErrorLInf : ";
  for (int v = 0; v < numberOfVariables; v++) {
    myfile << std::setprecision(2) << errorLInf[v] / normLInfAna[v] << " \t ";
  }
  myfile << std::endl; */

   //if (tarch::la::equals(mpirank, 0)) {
    myfile.close();
	//}
}

