{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#include <limits>

#include "{{pathToOptKernel}}/Kernels.h"

#include "{{solverHeader}}"

double {{codeNamespace}}::stableTimeStepSize(
    {{solverName}}& solver,
    const double* restrict const luh,
    const double inverseDx //Assume dx[0] == dx[1] == dx[2]
) {
  constexpr double cflFactor = {{solverName}}::CFL;
  constexpr double PNPM      = {{solverName}}::PNPM;
  
  double lambda[{{nVar}}] __attribute__((aligned(ALIGNMENT))) = {0.0};
  double dt = std::numeric_limits<double>::max();
  
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) { //xyz
    double denominator = 0.0;
    for (int d = 0; d < {{nDim}}; d++) {
#ifdef USE_IPO
      #pragma forceinline recursive
#endif
      solver.{{solverName}}::eigenvalues(luh+({{nData}}*xyz), d, lambda);
      
      double maxEigenvalue = 0.0;
      for (int n = 0; n < {{nVar}}; n++) {
        maxEigenvalue = std::max(fabs(lambda[n]), maxEigenvalue);
      }
      {% if useViscousFlux %}
      double maxEigenvalueVisc = 0.0;
      solver.{{solverName}}::viscousEigenvalues(luh+({{nData}}*xyz), d, lambda);
      for (int n = 0; n < {{nVar}}; n++) {
	maxEigenvalueVisc = std::max(std::abs(lambda[n]), maxEigenvalueVisc);
      }
      maxEigenvalue += maxEigenvalueVisc * (2.0/PNPM) * inverseDx;
      {% endif %}
      denominator += maxEigenvalue * inverseDx; //Assume dx[0] == dx[1] == dx[2]
    }

    dt = std::min(dt, cflFactor * PNPM / denominator);  // order = nDof-1

  }

  return dt;
}
