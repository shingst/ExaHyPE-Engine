#
# This is the ExaHyPE Makefile.
#
# It was originally generated by the Peano Development Tools (PDT), but then carefully
# edited by a number of people. Please consider reading the ExaHyPE Guidebook for an idea
# of the ExaHyPE build system.
#
# For the introduction, it is worthwile to say that each ExaHyPE Application (PDE) has it's
# own Makefile which however only calls this Makefile here.
#
# The dialect of this Makefile is GNU Make.
#


# *********************************************************************************************
# README
# *********************************************************************************************
#
# Available configuration Parameters for ExaHyPE
#
# export variable  |  default-value  |  further values         |  description
#----------------------------------------------------------------------------------------------
# ARCHITECTURE        CPU               Phi, KNL, HSW, SKX         Hardware-plattfrom
# COMPILER            Intel             GNU, Manual                Used compiler (and linker)
# MODE                Release           Debug,                     Verbosity and Debug level
#                                       Asserts,PeanoProfile,Profile          
# SHAREDMEM           None              OMP, TBB, CPP14            Shared-memory parallelisation
# DISTRIBUTEDMEM      None              MPI                        Distributed-memory parallelisation
# BOUNDARYCONDITIONS  None              Periodic                   Type of boundary conditions
# USE_IPO             Off               On, Unsafe                 IPO during compilation (intel only)
# *********************************************************************************************

SHELL = bash
tolower = $(shell echo $(1) | tr '[:upper:]' '[:lower:]')

#USE_IPO unsafe => on with unsafe flag enabled
USE_IPO_INTERN=$(call tolower,$(USE_IPO))
ifeq ($(USE_IPO),)
	USE_IPO_INTERN=off
else ifeq ($(call tolower,$(USE_IPO)),unsafe)
	USE_IPO_INTERN=on
	IPO_UNSAFE_FLAG=-DUNSAFE_IPO
else
	IPO_UNSAFE_FLAG=
endif


ifeq ($(call tolower,$(USE_IPO_INTERN)),on)
	SOLVERKERNELS_IPO_OBJ=$(PROJECT_PATH)/solver_ipo.o
else
	SOLVERKERNELS_IPO_OBJ=
endif

# ************************************************

#
# Set default values of configuration parameters
ifeq ($(ARCHITECTURE),)
	ARCHITECTURE=CPU
endif
ifeq ($(COMPILER),)
	COMPILER=Intel
endif
ifeq ($(MODE),)
	MODE=Release
endif
ifeq ($(SHAREDMEM),)
	SHAREDMEM=None
endif
ifeq ($(DISTRIBUTEDMEM),)
	DISTRIBUTEDMEM=None
endif
ifeq ($(BOUNDARYCONDITIONS),)
	BOUNDARYCONDITIONS=None
endif

ifeq ($(call tolower,$(GPROF)),on)
	COMPILER_CFLAGS += -pg 
	COMPILER_LFLAGS += -pg 
endif

# other valid options are: c++14.
ifeq ($(CPP_STANDARD),)
	CPP_STANDARD=c++11
endif

# ************************************************

ifeq ($(call tolower,$(USE_IPO_INTERN)),on)
	ifneq ($(call tolower,$(COMPILER)),intel)
$(error USE_IPO=on only works with COMPILER=Intel)
	endif
endif



# ************************************************
#
#Set compiler and linker flags for the different Debug/Release modes
#These are only Peano/ExaHyPE flags. Nothing that has to do with the
#compiler. 
#
#

ifeq ($(call tolower,$(MODE)),release)
	# Settings for the Release mode
	# ----------------------------------------------
	COMPILER_CFLAGS +=  -DTrackGridStatistics
	#COMPILER_LFLAGS +=

else ifeq ($(call tolower,$(MODE)),debug)
	# Settings for the Debug mode
	# --------------------------------------------
	COMPILER_CFLAGS += -DDebug -DAsserts -DTrackGridStatistics
	#COMPILER_LFLAGS +=
	
else ifeq ($(call tolower,$(MODE)),asserts)
	# Settings for the Asserts mode
	# --------------------------------------------
	COMPILER_CFLAGS += -DAsserts -DTrackGridStatistics
	#COMPILER_LFLAGS +=
	
else ifeq ($(call tolower,$(MODE)),profile)
	# Settings for the Profile mode
	# --------------------------------------------
	#COMPILER_CFLAGS += 
	#COMPILER_LFLAGS +=

else ifeq ($(call tolower,$(MODE)),peanoprofile)
	# Settings for the PeanoProfile mode
	# --------------------------------------------
	COMPILER_CFLAGS += -DPerformanceAnalysis -DTrackGridStatistics
	#COMPILER_LFLAGS +=
	
else ifeq ($(call tolower,$(MODE)),itac)
	# Settings for the ITAC mode
	# --------------------------------------------
	ifneq ($(call tolower,$(DISTRIBUTEDMEM)),mpi)
$(error DISTRIBUTEDMEM must equal MPI for MODE=ITAC)
	endif
	COMPILER_CFLAGS += -DUSE_ITAC -trace -I$(VT_ROOT)/include
	COMPILER_LFLAGS += -DUSE_ITAC -trace

else
	# Option not recognized
	# ----------------------------------------------
$(error Unknown option '$(MODE)' for variable [MODE])
endif



# ************************************************
#
#Set compiler and linker flags for the different conmpilers
ifeq ($(call tolower,$(COMPILER)),intel)
	# Settings for the Intel Compiler
	# ----------------------------------------------
	IPO_FLAG= -ipo
	NO_IPO_FLAG = -no-ipo
	ifndef EXAHYPE_CC 
		ifeq ($(call tolower,$(DISTRIBUTEDMEM)),mpi)
			CC=mpiicpc
		else
			CC=icpc
		endif
	else
		CC=$(EXAHYPE_CC)
	endif
	ifndef EXAHYPE_FC
		ifeq ($(call tolower,$(DISTRIBUTEDMEM)),mpi)
			FC=mpiifort
		else
			FC=ifort
		endif
	else
	  FC=$(EXAHYPE_FC)
	endif
	
	# REMOVING "-fast" as it induces compiler bugs!
	LINK_FORTRAN	  += -lifcore

	# Note, check out these ifort compiler flags:
	#   -reentrance  -recursive
	
	FCOMPILER_CFLAGS  += -r8 -cpp -auto -qopenmp-simd
	COMPILER_CFLAGS   += -restrict -std=$(CPP_STANDARD) -pedantic -Wall -qopenmp-simd
	#COMPILER_LFLAGS   +=
	
	
	ifeq ($(call tolower,$(MODE)),debug)
		COMPILER_CFLAGS  += -g3 -ggdb -debug all  
		FCOMPILER_CFLAGS += -g3 -ggdb -debug all
		COMPILER_LFLAGS  += -g3 
		ifeq ($(call tolower,$(SHAREDMEM)),tbb)
			COMPILER_CFLAGS  += -DTBB_USE_DEBUG=1
		endif
	else ifeq ($(call tolower,$(MODE)),asserts)
		COMPILER_CFLAGS += -g3
		COMPILER_LFLAGS += -g3
	else ifeq ($(call tolower,$(MODE)),profile)
		#COMPILER_CFLAGS += -p -pg -g3 -fast -ip
		COMPILER_CFLAGS += -p -pg -g3 -O3 -ip
		COMPILER_LFLAGS += -p -pg
	else
		FCOMPILER_CFLAGS  += -O2
		#COMPILER_CFLAGS   += -fast -ip
		COMPILER_CFLAGS   += -O3 -ip
	endif

	ifeq ($(call tolower,$(SHAREDMEM)),tbb)
	else
		#COMPILER_CFLAGS   += -fno-rtti
		COMPILER_LFLAGS   += -lrt
	endif
	
	ifeq ($(call tolower,$(ARCHITECTURE)),phi)
		COMPILER_CFLAGS += -mmic
		COMPILER_LFLAGS += -mmic
	else ifeq ($(call tolower,$(ARCHITECTURE)),wsm)
		COMPILER_CFLAGS  += -xSSE4.2
		FCOMPILER_CFLAGS += -xSSE4.2
		COMPILER_LFLAGS  += -xSSE4.2
	else ifeq ($(call tolower,$(ARCHITECTURE)),snb)
		COMPILER_CFLAGS  += -xAVX
		FCOMPILER_CFLAGS += -xAVX
		COMPILER_LFLAGS  += -xAVX
	else ifeq ($(call tolower,$(ARCHITECTURE)),hsw)
		COMPILER_CFLAGS  += -xCORE-AVX2 -fma
		FCOMPILER_CFLAGS += -xCORE-AVX2 -fma
		COMPILER_LFLAGS  += -xCORE-AVX2 -fma
	else ifeq ($(call tolower,$(ARCHITECTURE)),knl)
		COMPILER_CFLAGS  += -xMIC-AVX512 -fma
		FCOMPILER_CFLAGS += -xMIC-AVX512 -fma
		COMPILER_LFLAGS  += -xMIC-AVX512 -fma
	else ifeq ($(call tolower,$(ARCHITECTURE)),skx)
		COMPILER_CFLAGS  += -xCORE-AVX512 -fma
		FCOMPILER_CFLAGS += -xCORE-AVX512 -fma
		COMPILER_LFLAGS  += -xCORE-AVX512 -fma
	else ifneq ($(call tolower,$(ARCHITECTURE)),cpu)
        $(error Unknown option for variable [ARCHITECTURE])
	endif

else ifeq ($(call tolower,$(COMPILER)),gnu)
	# Settings for the GNU Compiler
	# --------------------------------------------
	ifndef EXAHYPE_CC 
		ifeq ($(call tolower,$(DISTRIBUTEDMEM)),mpi)
			CC=mpicc
		else
			CC=g++
		endif
	else
		CC=$(EXAHYPE_CC)
	endif
	ifndef EXAHYPE_FC
		ifeq ($(call tolower,$(DISTRIBUTEDMEM)),mpi)
			FC=mpifort
		else
			FC=gfortran
		endif
	else
		FC=$(EXAHYPE_FC)
	endif
	
	FCOMPILER_CFLAGS  += -fdefault-real-8 -fdefault-double-8 -ffree-line-length-none -cpp -Wall -Wno-tabs -Wno-unused-variable -fopenmp-simd
	# REMOVING "-O3"  as it creates compiler bugs!
	LINK_FORTRAN	  += -lgfortran

	COMPILER_CFLAGS   += -std=$(CPP_STANDARD) -pedantic -Wall -Drestrict=__restrict__ -pipe -D__assume_aligned=__builtin_assume_aligned -Wstrict-aliasing -fopenmp-simd
	COMPILER_LFLAGS   += -lm -lstdc++
	
	ifeq ($(call tolower,$(MODE)),debug)
		COMPILER_CFLAGS  += -O0 -ggdb
		FCOMPILER_CFLAGS += -ggdb
		ifeq ($(call tolower,$(SHAREDMEM)),tbb)
			COMPILER_CFLAGS  += -DTBB_USE_DEBUG=1
		endif
	else ifeq ($(call tolower,$(MODE)),asserts)
		COMPILER_CFLAGS  += -g3
		COMPILER_LFLAGS  += -g3
		FCOMPILER_CFLAGS += -g3
	else ifeq ($(call tolower,$(MODE)),profile)
		COMPILER_CFLAGS  += -p -pg -g3 -O3
		COMPILER_LFLAGS  += -p -pg
	else
		COMPILER_CFLAGS  += -O3
		FCOMPILER_CFLAGS += -O3
	endif

	ifeq ($(call tolower,$(SHAREDMEM)),tbb)
		#COMPILER_CFLAGS  +=
		#COMPILER_LFLAGS  +=
	else
		#COMPILER_CFLAGS  += -fno-rtti
		COMPILER_LFLAGS  += -lrt
	endif

	ifeq ($(call tolower,$(ARCHITECTURE)),knl)
		COMPILER_CFLAGS  += -march=knl
		COMPILER_LFLAGS  += -march=knl
	else ifeq ($(call tolower,$(ARCHITECTURE)),skx)
		COMPILER_CFLAGS  += -march=skylake-avx512
		COMPILER_LFLAGS  += -march=skylake-avx512
    else ifeq ($(call tolower,$(ARCHITECTURE)),snb)
		COMPILER_CFLAGS  += -march=sandybridge
		COMPILER_LFLAGS  += -march=sandybridge
	else ifeq ($(call tolower,$(ARCHITECTURE)),hsw)
		COMPILER_CFLAGS  += -march=haswell
		COMPILER_LFLAGS  += -march=haswell
	else ifeq ($(call tolower,$(ARCHITECTURE)),wsm)
		COMPILER_CFLAGS  += -march=westmere
		COMPILER_LFLAGS  += -march=westmere
	else ifneq ($(call tolower,$(ARCHITECTURE)),cpu)
		$(error Unknown option for variable [ARCHITECTURE])
	endif

else ifeq ($(call tolower,$(COMPILER)),manual)
	ifndef EXAHYPE_CC
		$(error COMPILER=manual at least requries user to set EXAHYPE_CC)
	else
		CC=$(EXAHYPE_CC)
	endif
	FC=$(EXAHYPE_FC)
else
	# Option not recognized
	# ----------------------------------------------
$(error Unknown option for variable [COMPILER])
endif






# Include files defining $CSOURCES, $FSOURCES, $FMODULESOURCES.
# They are generated by the make target "cfiles.mk" and "ffiles.mk" and contain the
# list of files to compile. Remember that make evaluates expressions lazy, thus we can
# do an include here but run the make target afterwards to fill the actual files.
-include cfiles.mk
-include cipofiles.mk
-include ffiles.mk



# Configure System
# ----------------
# These values are used to assemble the symbols SYSTEM_CFLAGS and SYSTEM_LFLAGS.
INCLUDE_TBB=$(TBB_INC)
#INCLUDE_OMP=$(OMP_INC)
INCLUDE_OMP=-fopenmp
INCLUDE_MPI=$(MPI_INC)


LINK_TBB=$(TBB_SHLIB)
#LINK_OMP=$(OMP_SHLIB)
LINK_OMP=-fopenmp
#LINK_MPI=-lpthread -lrt -lmpich
LINK_MPI=



# Assemble compiler flags for shared-memory parallelization
# -----------------------
ifeq ($(call tolower,$(SHAREDMEM)),omp)
	SYSTEM_CFLAGS   += $(INCLUDE_OMP)
	SYSTEM_LFLAGS   += $(LINK_OMP)
	COMPILER_CFLAGS += -DSharedOMP
else ifeq ($(call tolower,$(SHAREDMEM)),tbb)
	SYSTEM_CFLAGS   += $(INCLUDE_TBB)
	SYSTEM_LFLAGS   += $(LINK_TBB)
	COMPILER_CFLAGS += -DSharedTBB
else ifeq ($(call tolower,$(SHAREDMEM)),cpp14)
	SYSTEM_CFLAGS   += 
	SYSTEM_LFLAGS   += -lpthread	
	COMPILER_CFLAGS += -DSharedCPP
else ifeq ($(call tolower,$(SHAREDMEM)),tbbinvade)
	SYSTEM_CFLAGS   += $(INCLUDE_TBB)
	SYSTEM_LFLAGS   += $(LINK_TBB)
	COMPILER_CFLAGS += -DSharedTBB -DTBBInvade -DSHM_INVADE_DEBUG=4
endif


ifeq ($(call tolower,$(DISTRIBUTEDMEM)),mpi)
	COMPILER_CFLAGS += -DParallel
	COMPILER_CFLAGS += -DnoPackedRecords -DnoPersistentRegularSubtrees 
	COMPILER_CFLAGS += -DIprobeEveryKIterations=0 -DUsePeanosRLEBoundaryExchanger
endif



# Assemble Compiler Flags for boundary conditions
# -----------------------
ifeq ($(call tolower,$(BOUNDARYCONDITIONS)),periodic)
	COMPILER_CFLAGS += -DPeriodicBC
endif

#
# Linker Settings
# ---------------
# By default, I use the compiler command. But you might wanna modify it.
LL=$(CC)


#
# Remove link to Fortran library if no Fortran file is linked
# -----------------------------------------------------------
# This is a "trick" to be able to compile ExaHyPE without any Fortran compiler at all:
# Set the LINK_FORTRAN to an empty string. It contained some library before.
#
ifeq ($(call tolower,$(FOUND_ANY_FORTRAN)),no)
	LINK_FORTRAN =
endif



COBJECTS=$(CSOURCES:.cpp=.o)
CIPOOBJECTS=$(CIPOSOURCES:.cpp=.o)
FOBJECTS=$(FSOURCES:.f90=.o)
FMODULEOBJECTS=$(FMODULESOURCES:.f90=.o)
FOBJECTS+=$(FMODULEOBJECTS)


# 
# Project-wise Settings
# ---------------------
# Projects can easily hook in with the variables
#
#  PROJECT_CFLAGS   (eg. for additional include paths)
#  PROJECT_LFLAGS   (eg. for additional dynamic links)
#  PROJECT_LINK     (eg. for additional objects/archives, ia. static links)
#
# As everywhere in GNU Make, these variables can be passed as arguments to make,
#  > make PROJECT_CFLAGS=-I/my/initial/data/code/ PROJECT_LINK=/my/initial/data/code.a
# or set as environment variables.
#

all: wellsortedbuild

# try this for serial making. Parallel make of header, buildinfo and build
# results in all text over each other and a race condition when buildinfo
# has not finished yet but the main.cpp code is already compiling.

wellsortedbuild: header buildinfo ffiles.mk cfiles.mk cipofiles.mk
ifneq ($(FMODULEOBJECTS),)
		$(MAKE) $(FMODULEOBJECTS)
endif
	$(MAKE) build


buildinfo:
#	add any variables which you want to be able to see
#	in the binary when calling with --version:
	@echo "generate-buildinfo.sh > $(PROJECT_PATH)/buildinfo.h"
	@$(EXAHYPE_PATH)/generate-buildinfo.sh \
		"COMPILER = $(COMPILER)" \
		"MODE = $(MODE)" \
		"SHAREDMEM = $(SHAREDMEM)" \
		"DISTRIBUTEDMEM = $(DISTRIBUTEDMEM)" \
		"------" \
		"ARCHITECTURE = $(ARCHITECTURE)" \
		"CC = $(CC)" \
		"BOUNDARYCONDITIONS = $(BOUNDARYCONDITIONS)" \
		"------" \
		"COMPILER_CFLAGS = $(COMPILER_CFLAGS)" \
		"COMPILER_LFLAGS = $(COMPILER_LFLAGS)" \
		"FCOMPILER_CFLAGS = $(FCOMPILER_CFLAGS)" \
		"FCOMPILER_LFLAGS = $(FCOMPILER_LFLAGS)" \
		"------" \
		"EXAHYPE_PATH = $(EXAHYPE_PATH)" \
		"PROJECT_PATH = $(PROJECT_PATH)" \
		"PEANO_KERNEL_PEANO_PATH = $(PEANO_KERNEL_PEANO_PATH)" \
		"PEANO_KERNEL_TARCH_PATH = $(PEANO_KERNEL_TARCH_PATH)" \
		"------" \
		"PROJECT_CFLAGS = $(PROJECT_CFLAGS)" \
		"PROJECT_LFLAGS = $(PROJECT_LFLAGS)" \
		> $(PROJECT_PATH)/buildinfo.h
#	touch the file which loads the buildinfo in order to have the most recent ones
	touch $(EXAHYPE_PATH)/exahype/Version.cpp
	
		
cfiles.mk:
	touch cfiles.mk
	echo -n CSOURCES= > cfiles.mk
	find -H $(PEANO_KERNEL_PEANO_PATH) -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
	find -H $(PEANO_KERNEL_TARCH_PATH) -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
	find -H $(PEANO_TOOLBOX_MULTISCALELINKEDCELL_PATH) -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
	find -H $(PEANO_TOOLBOX_SHAREDMEMORY_ORACLES_PATH) -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
	find -H $(PEANO_TOOLBOX_MPI_BLANCING_PATH) -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
	find -H $(EXAHYPE_PATH) -name '*.cpp'  -not -path $(EXAHYPE_PATH)'/kernels/aderdg/generic/fortran/*' -not -path $(EXAHYPE_PATH)'/exahype/solvers/*' | tr '\n' ' ' >> cfiles.mk
ifneq (,$(findstring Yes, $(MIXEDLANG) ))  
	find -H $(EXAHYPE_PATH)'/kernels/aderdg/generic/fortran' -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
endif
ifneq ($(call tolower,$(USE_IPO_INTERN)),on)
	find -H $(EXAHYPE_PATH)'/exahype/solvers' -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
	find -L $(PROJECT_PATH) -name '*.cpp' | tr '\n' ' ' >> cfiles.mk
endif


#	ipo for kernel + application + exahype/solvers
cipofiles.mk:
	touch cipofiles.mk
	echo -n CIPOSOURCES= > cipofiles.mk
ifeq ($(call tolower,$(USE_IPO_INTERN)),on)
	find -H $(EXAHYPE_PATH)'/exahype/solvers' -name '*.cpp' | tr '\n' ' ' >> cipofiles.mk
	find -L $(PROJECT_PATH) -name '*.cpp' | tr '\n' ' ' >> cipofiles.mk
endif

ffiles.mk:
	touch ffiles.mk
#	First, write down a flag whether Fortran files have been found.
#	If no Fortran files are in the project, we don't include the fortran library in the linking in the end.
#	This works with inverted logic: "find -exec false" will return true if nothing is found.
	if find -L $(PROJECT_PATH) -name '*.f90' -exec false {} \+; then echo 'FOUND_ANY_FORTRAN=No' > ffiles.mk; else echo 'FOUND_ANY_FORTRAN=Yes' > ffiles.mk; fi
#	ALLOW mixed language Fortran applications! C.f. SRHD, MHD, Z4
#	To resolve the dependency problem  (compile fortran modules first), we detect them heuristically.
	echo -n FMODULESOURCES= >> ffiles.mk
	find -L $(PROJECT_PATH) -name '*.f90' -exec grep -il module {} \+ | tr '\n'  ' ' >> ffiles.mk
	echo >> ffiles.mk
	echo -n FSOURCES= >> ffiles.mk
	find -L $(PROJECT_PATH) -name '*.f90' -exec grep -iL module {} \+ | tr '\n' ' ' >> ffiles.mk
#	 only for the projects which use the old fortran kernels:
ifneq (,$(findstring Yes, $(MIXEDLANG) ))
	find -L $(EXAHYPE_PATH) -name '*.f90' | tr '\n' ' ' >> ffiles.mk
endif

mergeipoobjects:  $(CIPOOBJECTS)
ifeq ($(call tolower,$(USE_IPO_INTERN)),on)
	$(CC) $(PROJECT_CFLAGS) $(COMPILER_CFLAGS) $(SYSTEM_CFLAGS) -wd10015 -DUSE_IPO $(IPO_UNSAFE_FLAG) -I$(PROJECT_PATH) -I$(PEANO_TOOLBOX_MPI_BLANCING_PATH)/../ -I$(PEANO_TOOLBOX_SHAREDMEMORY_ORACLES_PATH)/../ -I$(PEANO_TOOLBOX_MULTISCALELINKEDCELL_PATH)/../ -I$(PEANO_KERNEL_PEANO_PATH)/../ -I$(PEANO_KERNEL_TARCH_PATH)/../ -I$(EXAHYPE_PATH) -I$(PROJECT_PATH) -ipo-c $(CIPOOBJECTS) -o $(SOLVERKERNELS_IPO_OBJ)
#	-wd10015: disable the specific warning from ipo-c: icpc: warning #10015: multi-file optimization .o file produced; no link
#	combine all the ipo objects into one object (with ipo between the merged objects)
endif

header:
	@echo "================================================================================"
	@echo
	@echo  www.exahype.eu
	@echo
	@echo "================================================================================"
	@echo
	@echo The project has received funding from the European Union\'s
	@echo Horizon 2020 research and innovation programme under grant
	@echo agreement No 671698 \(ExaHyPE\). It is based upon the PDE
	@echo framework Peano \(www.peano-framework.org\).
	@echo 
	@echo "================================================================================"
	@echo "Building ExaHyPE project with the following options:"
	@echo "================================================================================"
	@echo "COMPILER               = $(COMPILER)"
	@echo "MODE                   = $(MODE)"
	@echo "SHAREDMEM              = $(SHAREDMEM)"
	@echo "DISTRIBUTEDMEM         = $(DISTRIBUTEDMEM)"
	@echo "ARCHITECTURE           = $(ARCHITECTURE)"
	@echo "USE_IPO                = $(USE_IPO)"
	@echo "--------------------------------------------------------------------------------"
	@echo "EXAHYPE_CC             = $(EXAHYPE_CC)"
	@echo "EXAHYPE_FC             = $(EXAHYPE_FC)"
	@echo "--------------------------------------------------------------------------------"
	@echo "CC                     = $(CC)"
	@echo "FC                     = $(FC)"
	@echo "COMPILER_CFLAGS        = $(COMPILER_CFLAGS)"
	@echo "COMPILER_LFLAGS        = $(COMPILER_LFLAGS)"
	@echo "FCOMPILER_CFLAGS       = $(FCOMPILER_CFLAGS)"
	@echo "FCOMPILER_LFLAGS       = $(FCOMPILER_LFLAGS)"
	@echo "LINK_FORTRAN           = $(LINK_FORTRAN)"
	@echo "FOUND_ANY_FORTRAN      = $(FOUND_ANY_FORTRAN)"
	@echo "--------------------------------------------------------------------------------"
	@echo "PROJECT_CFLAGS         = $(PROJECT_CFLAGS)"
	@echo "PROJECT_LFLAGS         = $(PROJECT_LFLAGS)"
	@echo "================================================================================"
	@echo
	@echo ExaHyPE uses environment variables EXAHYPE_CC and EXAHYPE_FC for the 
	@echo C++ or Fortran compiler, respectively. If you haven\'t defined EXAHYPE_CC
	@echo and EXAHYPE_FC yourself, ExaHyPE defaults them to mpiicpc, icpc, g++, and 
	@echo so forth depending on the value of COMPILER. If you specify your own 
	@echo compilers via EXAHYPE_CC and EXAHYPE_FC, please specify a valid COMPILER 
	@echo mode nevertheless.
	@echo
	@echo The compiler variant does set various compiler and linker flags. 
	@echo You can supplement you own by setting the variables 
	@echo COMPILER_CFLAGS, COMPILER_LFLAGS, FCOMPILER_CFLAGS and FCOMPILER_LFLAGS prior 
	@echo running make.
	@echo
	@echo NOTE: If you select the compiler manually, ExaHyPE does not set any compiler 
	@echo flags, i.e. it is up  to you to initialise all compiler settings. Notably, 
	@echo you have to specify through EXAHYPE_CC which compiler to use.

build:  $(FOBJECTS) mergeipoobjects $(COBJECTS)
	$(LL) $(COBJECTS) $(FOBJECTS) $(SOLVERKERNELS_IPO_OBJ) $(PROJECT_LINK) $(LINK_FORTRAN) $(COMPILER_LFLAGS) $(NO_IPO_FLAG) $(SYSTEM_LFLAGS) $(PROJECT_LFLAGS) -o $(EXECUTABLE)
	@echo
	@echo build of ExaHyPE successful
	@echo run code with ./$(EXECUTABLE) and pass config file as argument

clean:
	rm -f $(EXECUTABLE)
	rm -f $(FOBJECTS)
	rm -f ffiles.mk
	rm -f $(COBJECTS)
	rm -f cfiles.mk
ifeq ($(call tolower,$(USE_IPO_INTERN)),on)	
	rm -f $(CIPOOBJECTS)
	rm -f $(SOLVERKERNELS_IPO_OBJ)
endif
	rm -f cipofiles.mk
	rm -f buildinfo.h
	rm -f *.mod   # Delete also all Fortran modules

# peano.a: Useful for quickly setting up external applications which use the ExaHyPE
#          code base as a library.
peano.a: $(FOBJECTS) $(COBJECTS)
#	Only the Peano object files: #$(find -H $(PEANO_KERNEL_PEANO_PATH) $(PEANO_KERNEL_TARCH_PATH) $(PEANO_TOOLBOX_MULTISCALELINKEDCELL_PATH)  $(PEANO_TOOLBOX_SHAREDMEMORY_ORACLES_PATH) $(PEANO_TOOLBOX_MPI_BLANCING_PATH) -name '*.o')
#	Since the find does not work in-place, here we just collect all object files, also from ExaHyPE:
	ar r peano.a  $(COBJECTS) $(FOBJECTS)

$(COBJECTS): %.o : %.cpp
	$(CC) $(COMPILER_CFLAGS) $(NO_IPO_FLAG) $(SYSTEM_CFLAGS) $(PROJECT_CFLAGS) -I$(PEANO_KERNEL_PEANO_PATH)/../ -I$(PEANO_KERNEL_TARCH_PATH)/../ -I$(PROJECT_PATH) -I$(PEANO_TOOLBOX_MPI_BLANCING_PATH)/../ -I$(PEANO_TOOLBOX_SHAREDMEMORY_ORACLES_PATH)/../ -I$(PEANO_TOOLBOX_MULTISCALELINKEDCELL_PATH)/../ -I$(EXAHYPE_PATH) -I$(PROJECT_PATH)  -c $< -o $@

$(CIPOOBJECTS): %.o : %.cpp
	$(CC) $(COMPILER_CFLAGS) $(IPO_FLAG) -DUSE_IPO $(IPO_UNSAFE_FLAG) $(SYSTEM_CFLAGS) $(PROJECT_CFLAGS) -I$(PEANO_KERNEL_PEANO_PATH)/../ -I$(PEANO_KERNEL_TARCH_PATH)/../  -I$(PROJECT_PATH) -I$(PEANO_TOOLBOX_MPI_BLANCING_PATH)/../ -I$(PEANO_TOOLBOX_SHAREDMEMORY_ORACLES_PATH)/../ -I$(PEANO_TOOLBOX_MULTISCALELINKEDCELL_PATH)/../ -I$(EXAHYPE_PATH) -I$(PROJECT_PATH)  -c $< -o $@

$(FOBJECTS): %.o : %.f90
	$(FC) $(FCOMPILER_CFLAGS) $(PROJECT_CFLAGS) -I$(PROJECT_PATH) -c $< -o $@
